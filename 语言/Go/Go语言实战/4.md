# 4 - 数组、切片和映射

这三种数据结构是语言核心的一部分，这里介绍它们的底层原理和使用方法。

## 4.1 - 数组的内部实现和基础功能

这是最基础的数据结构，切片和映射都是基于它实现的。

### 4.1.1 - 内部实现

和 C 语言一样，数组是固定大小、特定类型的一块连续内存空间，因此提供快速的随机访问能力。

### 4.1.2 - 声明和初始化

数组中的所有元素，如果没有显式提供初始值，就会被零初始化。具体有如下声明方式：

```go
// 5 个元素的整型数组，元素都是 0
var array [5]int

// 使用数组字面量，声明并提供初始值
array := [5]int{10, 20, 30, 40, 50}

// 此时也可以自动确定数组长度
array := [...]int{10, 20, 30, 40, 50}

// 可以只提供初始值给特定元素，索引从 0 开始
array := [5]int{1: 10, 2: 20}
```

### 4.1.3 - 使用数组

访问一个元素和 C 语言一样是 `arr[idx]`。

Go 的数组支持赋值操作，是值语义操作。值得注意的是，数组的维度可以看作它类型的一部分，从而下面的代码是非法的：

```go
var array1 [4]string
array2 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"}
array1 = array2     // 过不了编译
```

由于数组的值语义，如果希望共享元素的话，可以使用指针：

```go
array := [3]*string{new(string), new(string), new(string)}
```

### 4.1.4 - 多维数组

```go
// 零初始化的二维数组
var array [4][2]int

// 数组字面量初始化
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// 指定索引初始化
array := [4][2]int{1: {0: 20, 1: 15}, 3: {1: 12}}
```

访问元素和 C 语言一样。多维数组实际上就是元素是低维度数组的数组，因此可以这样赋值：

```go
var array1 [2]int = array[1]
```

### 4.1.5 - 在函数间传递数组

首先，函数的数组形参，需要指定数组维度：

```go
func foo(array [100]int) {
    ...
}
```

当数组很大的时候，由于数组的值语义，把数组传递给函数可能带来巨大的拷贝开销。此时可以传递数组本身的指针来避免这样的拷贝：

```go
func foo(array *[1e6]int) {
    ...
}
```

### 4.2 - 切片的内部实现和基础功能

切片则可以看作一个可变大小的数组，它实际上是基于一个数组来实现的。

### 4.2.1 - 内部实现

在一个底层数组上，它额外维护了 3 个字段，分别是：

- 指向切片首个元素的指针（不一定是数组的首元素）
- 切片的长度（切片实际使用的元素数量）
- 切片的容量（从切片首元素到数组末尾的元素数量，为切片不改变底层数组时能使用的最大元素数量）

### 4.2.2 - 创建和初始化

```go
// 长度容量都是 5
slice := make([]string, 5)

// 长度为 3，容量为 5（长度超过容量会过不了编译）
slice := make([]string, 3, 5)

// 使用切片字面量，长度和容量都是 5，由编译器自动确定
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

// 可以指定索引进行初始化，长度和容量为最后一个元素的索引加一，这里是 100
slice := []string(99: "")
```

有时候可能需要一个形式上的切片而不是一个实际上的，比如函数出错时没有必要返回一个实际的切片，则可以创建一个 nil 切片：`var slice []int`。它的指针指向 nil，长度和容量都是 0。

这和空切片不一样，空切片的指针指向一个实际的地址，长度和容量也为 0。它如下创建：

```go
slice := make([]int, 0)
slice := []int{}
```

虽然如此，对它们调用 `append`、`len`、`cap` 都是一样的结果。

### 4.2.3 使用切片

它也使用数组的方式访问元素，访问超出范围的元素会导致运行时异常。

#### 赋值

它也可以赋值，不像数组一样有维度的限制。

可以从一个切片切出另一个切片：

```go
slice := []int{10, 20, 30, 40, 50}
// 新切片的范围从原切片索引 1 的元素开始，直到索引 3 的元素为止（不含），容量直到原切片结尾
newSlice := slice[1:3]
```

此时他们是共享同一个底层数组的，一方修改了某个元素，双方都可见。

#### 增长

可以扩展切片的大小：

```go
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice = append(newSlice, 60)
```

默认情况下，这会扩展原切片的大小，然后把新元素写入切片原先的尾部的下一个位置，也就是说会改变底层的数组。完成工作以后，`append()` 返回新的切片，之所以选择这样的模式，是因为需要的大小超过了容量时，会分配一个足够大的新数组并把原数据拷贝过去再返回。

书中的 Go 版本，在切片容量小于 1000 的情况下，则分配两倍的大小；容量达到 1000 以后，则分配 1.25 倍的大小。

`append()` 一次可以添加多个元素：

```go
s1 := []int{1, 2}
s2 := []int{5, 6}

// 新增 3 4
s1 = append(s1, 3, 4)

// 新增 s2 的所有元素，用 ... 展开所有 s2
s1 = append(s1, s2...)
```

#### 第 3 个参数

上面的切片创建方式，容量是自动计算的，实际上也可以通过第三个参数给定：

```go
// 从元素 2 开始，到元素 3 为止。计算容量，从 2 开始，到 4 为止。
// 如果计算出的容量过大，则产生运行时异常
slice := source[2:3:4]

// 常见的用法是后两个参数相同，一旦调用 append() 就会分配新数组，而不会不小心改动原数组
slice := source[2:3:3]
```

#### 迭代

```go
// 对于每个元素，创建副本赋值给 value
for index, value := range slice {
    ...
}

// 使用下划线忽略索引
for _, value := range slice {
    ...
}

// 使用传统 for 循环
for index := 0; index < len(slice); index++ {
    ...
}
```

### 4.2.4 - 多维切片

```go
slice := [][]int{{10}, {100, 200}}
slice[0] = append(slice[0], 20)
```

### 4.2.5 - 在函数间传递切片

因为切片实际上相当于由指针、大小、容量组成的一个结构体，因此它的拷贝是引用语义的。把它传递给函数的开销很小。

```go
func foo(slice []int) []int {
    ...
}
```

在 64 位机上，切片的三个字段各占 8 个字节。

## 4.3 - 映射的内部实现和基础功能

类似于 C++ 的 map，这是一个存储键值对的数据结构，支持基于键的快速检索。

### 4.3.1 - 内部实现

基于哈希桶实现，通过一个哈希函数得到一个哈希值，低位用来找到对应的桶，桶里会有多个元素。每个桶里面有两块连续内存，一块相当于一个表数组，每个元素存储对应索引处的元素哈希值的高位，用来改位置存储的是哪个元素；另一块实际用来存储键值对，前面部分连续存储键，后面部分连续存储值。

### 4.3.2 - 创建和初始化

```go
dict := make(map[string]int)
dict := map[string]string{"key1": "value1", "key2": "value2"}
```

键的类型不可以是切片、函数和包含切片的结构体等，因为切片和函数具有引用语义，使用它们为键不能通过编译。

### 4.3.3 - 使用映射

和 C++ 一样使用 `mp[key]` 来访问和新增元素。

可以通过 `var mp map[key]value` 来创建一个 nil 映射，通过 nil 映射访问元素会造成运行时异常。

访问元素时，如果该元素不存在，不会出错，而是返回一个零值。

可以如下检查元素是否存在：

```go
value, exists := colors["Blue"]
if exists {
    // 元素存在
}
```

也可以对 map 进行迭代，由于底层使用哈希，元素是无序的：

```go
for key, value := range colors {
    ...
}
```

可以从 map 中删除元素：

```go
delete(mp, key)
```

### 4.3.4 - 在函数间传递映射

跟切片一样，只拷贝顶层的数据结构而不拷贝底层的数组：

```go
func fn(mp map[key]value) {
    ...
}
```
