# 3 - 打包和工具链

本章主要介绍怎么把 Go 的代码组织成包，以及一些常用的工具链。值得注意的是，由于 Go 的迭代太快，很多东西可能都已经发生了改变或者过时了。

## 3.1 - 包

一般一个代码文件夹中的所有 .go 文件组成一个包，它们总是在第一行声明自己所属的包，通常包名应该和文件夹同名。

### 3.1.1 - 包名惯例

应该使用简洁、清晰、全小写的名字。

### 3.1.2 - main 包

名字为 main 的包具有特殊的含义，每个程序必须有一个 main 包，其中必须有一个 main 函数，作为程序的主逻辑。否则，Go 无法构建一个程序。

使用 `go build` 可以构建一个程序。（在 Go Module 引入以后，绝大多数命令需要在带有 module 的目录下运行）

## 3.2 - 导入

当写下一条 `import "<package>"` 的时候，系统先在 Go 的官方库中查找导入的包，位置在 `/usr/local/go/src/` 中，如果找不到会依次搜索 `$GOPATH` 中的所有目录。

## 3.2.1 - 远程导入

Go 支持了从 URL 直接下载导入源码，如 `import "github.com/spf13/viper"`。Go 会首先在本地查找，如果找不到就从远程下载到 `$GOPATH` 以后使用。

## 3.2.2 - 命名导入

有时候可能两个包取了相同的名字，这可以通过命名导入来把其中一个进行重命名：

```go
import (
    "fmt"
    myfmt "mylib/gmt"
)
```

这样，自己的版本就被命名为 myfmt。

## 3.3 - 函数 init

每个包都可以有多个 init 函数：

```go
func init() {
    sql.Register("postgres", new(PostgresDriver))
}
```

如果这个包被导入了，那么所有的 `init()` 都会在 `main()` 之前被执行，适合用来做只能在运行期完成的初始化操作。

这个特性结合命名导入有一个特别的用法：

```go
import (
    _ "<package>"
)
```

这表示不会使用包中的任何名字。一般 Go 不允许导入未显式使用的包，这个语法可以绕过这个限制，Go 会调用其中的所有 `init()`。

## 3.4 - 使用 Go 的工具

使用 `go build` 构建二进制程序，使用 `go clean` 清除构建的程序。如果使用 `go run`，在构建以后会自动运行程序。

## 3.5 - 进一步介绍 Go 开发工具

### 3.5.1 - go vet

用于检查 Go 程序的一些常见错误，包括：

- Printf 类型不匹配
- 常用方法定义时，签名写错
- 错误的结构标签
- 没有指定字段名的结构字面量

### 3.5.2 - Go 代码格式化

使用 fmt 工具按特定的模式格式化代码。

### 3.5.3 - Go 语言的文档

要查看某个包的文档可以从命令行调用 `go doc <pkg>`。也有网页版本，通过 `godoc -http=:<port>` 在特定端口开放服务。如果自己的代码按照某种规则来写，则 godoc 也可以为它生成代码。

## 3.6 - 与其他 Go 开发者合作

有几个原则：

- 包文件夹应该直接放在仓库的根目录下，而不是放在一个 `code/` 或 `src/` 中
- 包可以非常小，可能只有几个函数
- 对代码调用 `go fmt`
- 给代码写文档

## 3.7 - 依赖管理

介绍了 gopkg.in 和 godep 实现依赖管理的方案，实际上 Go 在 1.11 引入了 Go Modules 来做依赖管理，几乎全面革新的 Go 的开发模式，这两个工具可能用处不大了。
