# 变量和基本类型

## 基本内置类型

### 算术类型
标准规定了算数类型的最小尺寸：
类型 | 含义 | 最小尺寸
---|---|---
bool | 布尔类型 | 未定义
char | 字符 | 8位
wchar_t | 宽字符 | 16位
char16_t | Unicode字符 | 16位
char32_t | Unicode字符 | 32位
short | 短整型 | 16位
int | 整型 | 16位
long | 长整型 | 32位
long long | 长整型 | 64位
float | 单精度浮点数 | 6位有效数字
double | 双精度浮点数 | 10位有效数字
long double | 扩展精度浮点数 | 10位有效数字

还有一些其他的规定，如：
$$
sizeof(short) \leq sizeof(int) \leq sizeof(long) \leq sizeof(long\ long)
$$

标准对于浮点类型的精度限制较为宽松，一般来说， `float` 支持7位有效数字， `double` 则支持16位有效数字。

#### 带符号类型和无符号类型
除了布尔型和字符型，其他的整型都分为带符号类型和无符号类型。默认情况下是带符号的，前面加 `unsigned` 则是无符号的。然而 `char` 就有三种，分别是 `char` 、 `signed char` 和 `unsigned char` ，单独的 `char` 并没有规定是带符号还是无符号。

### 类型转换
- 非 `bool` 赋值给 `bool` 时， `0` 转换为 `false` ，其他值转换为 `true`
- `bool` 赋值给非 `bool` 时， `false` 转换为 `0` ， `true` 转换为 `1`
- 浮点赋值给整型，只保留整数部分
- 整型赋值给浮点，保留整数部分，小数部分为 `0` ，如果超出浮点数的精度范围，那么会有精度损失
- 把过大的数赋值给无符号类型，得到的是取模后的结果
- 把超出范围的数赋值给带符号类型，结果是**未定义**的

#### 含有无符号类型的表达式
如果表达式中同时有带符号类型和无符号类型，那么带符号类型会转换为无符号类型。这可能导致负数转换成无符号类型，尽量避免混用带符号类型和无符号类型。

### 字面值常量
像 `42` 这样的，一看就知道其取值，称作字面值常量。

#### 整型和浮点型字面值
整型值可以是十进制、八进制、十六进制的，如20的三种表示形式：
```cpp
20      // 十进制
024     // 八进制
0x14    // 十六进制
```
十进制的字面值实际类型是带符号的，八进制和十六进制的字面值实际类型可能带符号也可能不带符号。十进制字面值的类型在 `int` 、 `long` 和 `long long` 中选取，八进制和十六进制的字面值的类型在 `int` 、 `unsigned int` 、 `long` 、 `unsigned long` 、 `long long` 和 `unsigned long long` 中选取。会采用能够容纳其值的最小的类型来存储。如果放不下，那么会报错。

浮点型字面值有如下形式：
```cpp
3.14159
3.14159E0
0.
0e0
.001
```

#### 字符和字符串字面值
像 `'a'` 这样的，称作字符字面值。像 `"Hello, World!"` 这样的，称作字符串字面值。当两个字符串字面值放在一起时，如：
```cpp
"Hello, " "World!"
```
它们实际上等价于 `"Hello, World!"` ，所以字符串过长时可以分行写。

#### 转义序列
表示 | 含义
--- | ---
`\n` | 换行
`\t` | 横向制表符
`\v` | 纵向制表符
`\a` | 响铃
`\b` | 退格
`\r` | 回车
`\"` | 双引号
`\'` | 单引号
`\\` | 反斜杠
`\?` | 问号
`\f` | 进纸符

可以使用泛化的转义序列，即用字符的ASCII码来表示字符，如：
- `'\7'` ：不加x则为八进制，不超过3个数字，否则截取前3个。响铃符
- `'\x4d` ：加x则为十六进制。字母M

#### 指定字面值的类型
加上特定的前缀和后缀，可以不使用字面值的默认类型，如字符和字符串字面量有：
| 前缀 | 含义 | 类型 |
--- | --- | ---
u | Unicode16字符 | char16_t
U | Unicode32字符 | char32_t
L | 宽字符 | wchar_t
u8 | UTF-8字符 | char

整型字面值有（其中也可以组合UL表示 `unsigned long` ）：
| 后缀 | 含义 | 类型 |
--- | --- | ---
u 或 U | 无符号 | unsigned
l 或 L | 长整型 | long
ll 或 LL | 长长整型 | long long

浮点型字面值有：
| 后缀 | 含义 | 类型 |
--- | --- | ---
f 或 F | 单精度浮点数 | float
l 或 L | 扩展精度浮点数 | long double

#### 布尔字面值
`true` 和 `false` 是布尔类型的字面值。

## 变量
具名的、可供程序操作的存储空间，在本书中与**对象**一词等价。

### 变量定义

#### 列表初始化
在C++11以后，对于一个 `int` 类型的变量，有以下四种初始化方式：
```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
```
其中使用花括号的初始化方式称为列表初始化，对于内置类型来说，如果存在丢失信息的风险，这种初始化方式将会出错。

#### 默认初始化
如果不指定初始值，称为进行了默认初始化。内置类型，对于全局变量，会被初始化为0；对于局部变量，不会被初始化，其值是未定义的。

### 变量声明和定义的关系
为了允许把程序拆分成多个逻辑部分进行开发，C++支持**分离式编译**，即程序可以被分割成多个文件，每个文件单独进行编译。为此，C++将声明和定义区分开来，声明使得名字为程序所知，定义负责创建与名字关联的实体，变量只能定义一次而可以声明多次。只声明而不定义一个变量的方法是使用 `extern` 关键字：
```cpp
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```
然而，任何声明只要赋予了初始值，就是定义，比如这里的 `extern` 就没有任何作用：
```cpp
extern int i = 0; // 定义
```
在函数体内部，试图初始化一个由 `extern` 关键字标记的变量是非法的。

### 标识符
C++的标识符是由字母、数字、下划线组成，必须以字母或下划线开头。标识符是大小写敏感的。C++保留了一些标识符用作关键字：
| 列1 | 列2 | 列3 | 列4 | 列5 |
| --- | --- | --- | --- | --- |
| alignas | continue | friend | register | true |
| alignof | decltype | goto | reinterpret_cast | try |
| asm | default | if | return | typedef |
| auto | delete | inline | short | typeid |
| bool | do | int | signed | typename |
| break | double | long | sizeof | union |
| case | dynamic_cast | mutable | static | unsigned |
| catch | else | namespace | static_assert | using |
| char | enum | new | static_cast | virtual |
| char16_t | explicit | noexcept | struct | void |
| char32_t | export | nullptr | switch | volatile |
| class | extern | operator | template | wchar_t |
| const | false | private | this | while |
| constexpr | float | protected | thread_local | |
| const_cast | for | public | throw | |

还有一些操作符替代名，似乎会被宏替换成操作符，有：
| 列1 | 列2 | 列3 | 列4 | 列5 | 列6 |
| --- | --- | --- | --- | --- | --- |
| and | bitand | compl | not_eq | or_eq | xor_eq |
| and_eq | bitor | not | or | xor | |

### 名字的作用域
定义在所有花括号外的名字具有**全局作用域**，否则具有**块作用域**。

### 嵌套作用域
作用域可以包含在其他的作用域之中，被包含的称为**内层作用域**，包含的称为**外层作用域**。内层作用域可以重新定义外层作用域的名字，再次使用这个名字时，实际上访问的是内层作用域中的名字。

## 复合类型
指基于其他类型定义的类型，包括引用和指针。

### 引用
是对象的别名，实际不是一个对象。它绑定到一个对象上，不可以更改绑定的对象。

### 指针

#### 空指针
有几种可以获取空指针的方法：
```cpp
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; // 需要包含cstdlib
```
`nullptr` 是C++11引入的，是一种特殊的指针类型，可以转换成任意指针类型。在新标准下，尽量使用 `nullptr` 代替 `0` 和 `NULL` 。

## const限定符

#### 默认状态下，const对象仅在文件内有效
对于一个const对象，编译器往往把它们的所有出现替换成它的初始值，为了做到这一点，编译器需要知道这个对象的定义，所以const对象默认情况下只在文件内有效。如果需要一个行为类似于常规对象的const对象，需要在声明和定义的时候都加上 `extern` 关键字。

### const的引用
引用可以绑定到const对象上：
```cpp
const int ci = 1024;
const int &r1 = ci;
```

#### 初始化和对const的引用
一般来说，引用的类型需要与赋值给它的对象类型一致。实际上有两个例外：
- 初始化常量引用时，还可以使用表达式的计算结果，编译器会创建一个临时量
    ```cpp
    const int &r = 42;```
- const引用可以绑定到一个普通的变量上，这时不可以通过引用 `r` 来修改 `i` 的值
    ```cpp
    int i = 42;
    const int &r = i;
    ```

### 指针和const
指向常量的指针，不能使用该指针来修改指向的对象。常量指针，不允许改变其指向的对象。

### 顶层const
顶层const表示指针本身是个常量，底层const表示指针所指的对象是个常量。它们的声明方式不同：
```cpp
const int *p; // 底层const
int *const p; // 顶层const
```

### constexpr和常量表达式
常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。

#### constexper变量
C++11引入了 `constexpr` 关键字，用于声明变量或函数是常量表达式，编译器会检查它的初始值是否是一个常量表达式。普通的函数返回值不是常量表达式，只有 `constexpr` 函数才能返回常量表达式。

#### 字面值类型
常量表达式的值需要在编译器计算，所以对于 `constexpr` 可以修饰类类型需要加以限制，因为它们的类型简单、值容易得到，这种类型称为**字面值类型**。算术类型、引用和指针都是字面值类型。类类型一般不是字面值类型，但存在一些特例。

虽然指针和引用都可以用 `constexpr` 修饰，然而 `constexpr` 指针的初始值只能是 `nullptr` 或者 `0` ，或者存储在某个固定地址中的对象（创建在函数体内的对象使用栈空间，不是固定地址的；全局变量和静态变量的地址是固定的）。 `constexpr` 只对当前语句声明的指针有效，并不意味着指向的对象是const的，如果要指向const对象，需要：
```cpp
const int i = 5;    // 全局变量（满足constexpr的要求）
constexpr const int *p = &i;
```

## 处理类型

### 类型别名
有两种方式创建类型别名：
```cpp
// 使用关键字typedef
typedef double wages;       // wages是double的同义词
typedef wages base, *p;     // base是double的同义词，p是double*的同义词

// C++11引入了别名生命
using SI = Sales_item;      // SI是Sales_item的同义词
```

#### 指针、常量和类型别名
使用类型别名时，并不总是等效于把类型别名换成它所表示的类型后的结果。比如：
```cpp
typedef char *pstring;
const pstring cstr = 0; // 这里是顶层const
const pstring *ps;      // 这里是底层const
```
也就是说，这里的 `const` 是修饰 `pstring` 的，然而替换回原类型的话：
```cpp
const char *cstr = 0;
```
这条语句和上面的声明是不等价的。

### auto类型说明符
C++11引入了 `auto` 关键字，可以自动推断对象的类型，如：
```cpp
auto item = val1 + val2;    // item的类型就是val1和val2相加的结果的类型
```
一条语句也可以声明多个变量，要求基本类型一致，如：
```cpp
auto i = 0, *p = &i;        // 正确：i是整数，p是整型指针
auto sz = 0, pi = 3.14;     // 错误：基本类型不一致
```

#### 复合类型、常量和auto
有两种情况 `auto` 获得的类型和原类型不一样：
- 引用会被忽略
    ```cpp
    int i = 0, &r = i;
    auto a = r;             // a是一个整数

    const auto a1 = r;      // 显式指出a1是一个引用
    ```
- 顶层const会被忽略
    ```cpp
    const int ci = i;
    auto b = ci;            // b是一个整数

    const auto b1 = ci;     // 显式指出b1是一个顶层const
    ```

### decltype类型指示符
C++11引入了 `decltype` 关键字，可以仅获取表达式的类型，而不使用它的值初始化变量，如：
```cpp
decltype(f()) sum = x;      // sum的类型就是函数f的返回类型
```
这里 `f()` 并不会实际被调用。与 `auto` 不同， `decltype` 会保留顶层const和引用，这要求谨慎使用该关键字：
```cpp
int i = 42, *p = &i;
decltype(*p) c = i;         // c是引用
decltype((i)) d = i;        // d是引用
```

## 自定义数据结构

### 定义Sales_data类型

#### 类数据成员
C++11引入了类内初始值，可以为类的数据成员提供一个初始值，可以使用 `=` 或者 `{}` ，但不能使用 `()` 。

### 编写自己的头文件

#### 预处理器概述
为了避免反复包含同一个头文件，可以借助预处理器指令和**预处理变量**来形成**头文件保护符**：
```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
// 头文件内容
#endif
```
预处理变量没有作用域规则，所以在整个程序中必须是唯一的。

<br><br>

# 字符串、向量和数组

## 命名空间的using声明
```cpp
using std::cin;
```

## 标准库类型string

### 定义和初始化string对象
有以下方式可以初始化一个string对象：
```cpp
string s1;              // 默认初始化，s1是一个空串
string s2(s1);          // s2是s1的副本
string s2 = s1;         // 等价于上一条
string s3("value");     // s3是字面值"value"的副本
string s3 = "value";    // 等价于上一条
string s4(10, 'c');     // s4的内容是cccccccccc
```
上面使用了等号的是**拷贝初始化**，其他的是**直接初始化**。

### string对象上的操作
```cpp
os << s;                // 将s写到输出流os中，返回os
is >> s;                // 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s);         // 从is中读取一行赋给s，返回is
s.empty();              // s为空则返回true，否则返回false
s.size();               // 返回s中字符的个数
s[n];                   // 返回s中第n个字符的引用
s1 + s2;                // 返回s1和s2连接后的结果
s1 = s2;                // 用s2的副本代替s1中原来的字符
s1 == s2;               // 如果两个字符串相等则返回true
s1 != s2;               // 如果两个字符串不相等则返回true
s1 < s2;
s1 > s2;
s1 <= s2;
s1 >= s2;               // 字典序比较两个字符串
```

#### 读写string对象
```cpp
string word;
cin >> word;            // 忽略开头空白，遇到空白停止
```

#### string::size_type类型
是一个无符号类型，可以存放下任何string对象的大小。

#### 比较string对象
规则是：
- 逐位比较，遇到不同的字符，两个字符比较的结果就是string比较的结果
- 如果前面都相同，但是一个string先结束，那么短string小于长string

### 处理string对象中的字符
在头文件 `cctype` 中定义了一些函数：
| 函数 | 描述 |
| --- | --- |
| isalnum(c) | c是字母或数字则返回true |
| isalpha(c) | c是字母则返回true |
| iscntrl(c) | c是控制字符则返回true |
| isdigit(c) | c是数字则返回true |
| isgraph(c) | c是除空格之外的可打印字符则返回true |
| islower(c) | c是小写字母则返回true |
| isprint(c) | c是可打印字符则返回true |
| ispunct(c) | c是标点符号则返回true |
| isspace(c) | c是空白字符则返回true（空格、制表符、回车、换行、进纸符） |
| isupper(c) | c是大写字母则返回true |
| isxdigit(c) | c是十六进制数字则返回true |
| tolower(c) | 如果c是大写字母则返回其小写形式，否则返回c |
| toupper(c) | 如果c是小写字母则返回其大写形式，否则返回c |

## 标准库类型vector
在C++11以前，如果vector的元素类型仍是vector，两个尖括号之间需要加一个空格；在C++11以后，不需要加空格。

### 定义和初始化vector对象
有以下方式可以初始化一个vector对象：
```cpp
vector<T> v1;               // v1是一个空的vector，其中的元素类型是T，执行默认初始化
vector<T> v2(v1);           // v2中包含v1所有元素的副本
vector<T> v2 = v1;          // 等价于上一条
vector<T> v3(n, val);       // v3包含了n个重复的元素，每个元素的值都是val
vector<T> v4(n);            // v4包含了n个重复的元素，执行值初始化
vector<T> v5{a, b, c};      // v5包含了三个元素，分别是a、b、c
vector<T> v6 = {a, b, c};   // 等价于上一条
```
这里最后两种初始化方式是C++11引入的列表初始化。

#### 值初始化
指具有某种默认值的初始化方式，对于内置类型，值初始化就是初始化为0；对于类类型，值初始化就是默认初始化。

#### 列表初始值还是元素数量？
当使用花括号的时候，程序会优先进行列表初始化，如果不行，会考虑通过给出的参数调用构造函数，即实现和圆括号一样的效果。

### 其他vector操作
```cpp
vector<int> v;

v.empty();                  // 如果v为空则返回true，否则返回false
v.size();                   // 返回v中元素的个数
v.push_back(t);             // 在v的末尾添加一个值为t的元素
v[n];                       // 返回v中第n个元素的引用
v1 = v2;                    // 用v2的副本代替v1中原来的元素
v1 = {a, b, c};             // 用列表中的元素代替v1中原来的元素
v1 == v2;                   // 如果两个vector相等则返回true
v1 != v2;                   // 如果两个vector不相等则返回true
v1 < v2;
v1 > v2;
v1 <= v2;
v1 >= v2;                   // 字典序比较两个vector
```
这里的 `v.size()` 返回的类型是 `vector<int>::size_type` 。

## 迭代器介绍

### 使用迭代器

#### 迭代器运算符
```cpp
*iter;                      // 返回iter所指元素的引用
iter->mem;                  // 返回iter所指元素的名为mem的成员的引用
++iter;                     // 令iter指向容器中的下一个元素
--iter;                     // 令iter指向容器中的上一个元素
iter1 == iter2;             // 如果两个迭代器指向的元素相等则返回true
iter1 != iter2;             // 如果两个迭代器指向的元素不相等则返回true
```

#### 迭代器类型
以一个 `vector<int>` 为例，它有两种迭代器类型：
- `vector<int>::iterator` ：可以读写元素
- `vector<int>::const_iterator` ：只能读元素

而 `begin()` 和 `end()` 返回的是 `vector<int>::iterator` 类型的迭代器。C++11引入了两个新的函数成员 `cbegin()` 和 `cend()` ，它们返回 `vector<int>::const_iterator` 类型的迭代器。

#### 结合解引用和成员访问操作
语句 `(*it).empty()` 中的圆括号是必须的，因为成员访问运算符 `.` 的优先级高于解引用运算符 `*` 。为了避开这个问题，可以使用箭头运算符 `->` ，即 `it->empty()` 。

### 迭代器运算
所有的迭代器都支持递增运算，而string和vector的迭代器则支持更多的运算（以下的前后似乎是从容器的头部指向容器的尾部来说的）：
| 运算 | 描述 |
| --- | --- |
| iter + n | 返回iter向前移动n个元素的迭代器，返回指向某元素的迭代器或者尾后迭代器 |
| iter - n | 返回iter向后移动n个元素的迭代器，返回指向某元素的迭代器或者尾后迭代器 |
| iter += n | iter = iter + n |
| iter -= n | iter = iter - n |
| iter1 - iter2 | 返回iter1和iter2之间的距离 |
| >、>=、<、<= | 两个迭代器位置的比较 |

其中的减法运算返回的是 `vector<int>::difference_type` 类型的值，它是一个带符号类型。

## 数组
数组比起vector或许性能好上一些。

### 指针和数组
数组名常常被转换成指针，以至于当使用 `auto` 关键字的时候，数组名会被推断为指针类型，而不是数组类型。然而 `decltype` 保留了数组类型以及数组的大小。

#### 标准库函数begin和end
在C++中，指针也被视作一种迭代器，并可以完成迭代器的基本操作。如果用指针遍历内置数组，需要获得首元素指针和尾后指针，可以通过计算获得，然而这样比较麻烦。C++11引入了两个新的标准库函数 `begin` 和 `end` ，可以返回指向数组首元素和尾后元素的指针：
```cpp
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
```

#### 指针运算
类似于vector的迭代器，指针也可以进行加减运算来一次性经过多个元素。指向同一个数组的两个指针可以相减，得到的结果是相距的元素个数，类型为定义在 `cstddef` 头文件中机器相关的带符号类型 `ptrdiff_t` 。

#### 下标和指针
相比于标准库容器的下标运算只能使用无符号索引，内置数组的下标甚至可以使用负数。

### C风格字符串

#### C标准库String函数
头文件 `cstring` 中定义了一些函数：
| 函数 | 描述 |
| --- | --- |
| strlen(s) | 返回s的长度，不包括空字符 |
| strcmp(s1, s2) | 比较s1和s2，如果s1小于s2则返回负数，如果s1大于s2则返回正数，如果s1等于s2则返回0 |
| strcat(s1, s2) | 将s2连接到s1的后面，返回s1 |
| strcpy(s1, s2) | 将s2复制给s1，返回s1 |

以上函数均不验证其参数的合法性，所以使用时要特别小心。

### 与旧代码的接口
如果要把string对象转换成C风格字符串，可以使用 `c_str` 函数，注意使用const指针：
```cpp
string s("Hello World!");
const char *str = s.c_str();
```
`c_str` 返回的指针不是一直有效的，所以最好得到指针后拷贝一个副本来使用。

#### 使用数组初始化vector对象
可以使用数组初始化vector对象，如：
```cpp
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```

### 多维数组

#### 多维数组的初始化
```cpp
// 显式初始化前三行所有元素
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};

// 这种情况下，可以不嵌套花括号
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};

// 每行只初始化首元素（内层的花括号是必须的）
int ia[3][4] = {
    {0},
    {4},
    {8}
};

// 不等价于上一条，只初始化第一行的前三个元素
int ia[3][4] = {0, 4, 8};
```

#### 使用范围for语句处理多维数组
C++11引入了范围for语句，可以用来遍历数组：
```cpp
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        ++cnt;
    }
}
```
外层的指针必须是引用类型，否则会导致其退化成指针，从而无法继续遍历。

#### 类型别名简化多维数组的指针
多维数组和指针交互时，类型会很复杂，可以使用类型别名来简化，不过在此 `using` 和 `typedef` 的使用有一些区别：
```cpp
// 两条语句等价
using int_array = int[4];
typedef int int_array[4];
```

<br><br>

# 表达式

## 基础

### 基本概念

#### 左值和右值
在C语言中，左值和右值的概念非常简单，可以放在赋值语句左侧的就是左值，否则就是右值。

然而来到C++之中，就没有那么简单了。左值表达式的求值结果是一个对象或者函数，常量对象也是左值，却不能作为赋值语句的左侧。虽然有的表达式求值结果是对象，却是右值。一般来说，一个对象被当做左值时，使用的是对象的身份；当做右值时，使用的是对象的值。

以下几种运算符是需要使用左值的：
- 赋值运算符的左侧需要一个非常量的左值，并且返回的也是一个左值
- 取地址符作用于左值，返回一个指向该左值的指针，这个指针是一个右值
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符，返回的是左值
- 内置类型和迭代器的递增和递减运算符作用于左值，前置版本返回的是左值

对于左值使用 `decltype` 得到的类型是引用类型。

### 优先级与结合律
**复合表达式**是指含有两个或多个运算符的表达式。

## 算术运算符
一元正号运算符作用于小于 `int` 的整数类型时，会将其提升为 `int` 类型，如 `bool` 类型。在 `%` 的运算中，可能遇到两个操作数一正一负的情况，早期的C++标准中，商怎么舍入没有规定。在C++11中，商一律向0舍入，即直接舍去小数部分。

## 赋值运算符
C++11允许使用花括号作为赋值语句的右侧，如：
```cpp
vector<int> v;                          // v是一个空的vector
v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

## 条件运算符
```cpp
expr1 ? expr2 : expr3;
```
程序只会对 `expr2` 或者 `expr3` 中的一个进行求值，取决于 `expr1` 的值。

## 位运算符
位运算符如何处理负数的符号位没有明确规定，是依赖于机器的。一般来说，如果运算对象是小整数类型，它会被[提升](#整型提升)为较大的整数类型，如 `char` 被提升成 `int` 。

#### 移位运算符
右侧的运算对象不能为负，且必须严格小于结果的位数，否则行为是未定义的。对于有符号数来说，右移时左侧补充什么是依赖于环境的；如果是无符号数，右移时左侧补充0。

## sizeof运算符
有两种形式：
```cpp
sizeof(type);
sizeof expr;
```
`sizeof` 并不对表达式进行求值，所以即使解引用一个无效指针也不会有问题。C++11允许通过类作用域运算符来获取类成员的大小，而不需要有一个类的对象：
```cpp
sizeof Sales_data::revenue;
```
对数组调用 `sizeof` 返回整个数组占用空间的大小，对 `vector` 这种类调用 `sizeof` 返回的是类固定部分的大小。 `sizeof` 返回的结果是常量表达式。

## 逗号运算符
首先对左侧表达式求值，然后丢弃结果，再对右侧表达式求值，返回右侧表达式的结果。

## 类型转换
C++中，如果两个类型之间可以相互转换，那么说这两个类型之间是关联的。

#### 何时发生隐式类型转换
- 在大多数表达式中，比 `int` 小的整数类型提升为较大的整数类型
- 在条件中，其他类型转换成 `bool` 类型
- 初始化时，初始值转换成变量的类型；赋值时，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算和关系运算中有多种类型，需要转换成一种类型
- 函数调用传参

### 算术转换
指把一种算术类型转换成另一种算术类型

#### 整型提升
指小整数类型转换成大整数类型。

对于 `bool` 、 `char` 、 `signed char` 、 `unsigned char` 、 `short` 和 `unsigned short` 来说，如果 `int` 能表示它们所有的可能取值，那么它们就会被提升为 `int` 类型；否则，它们会被提升为 `unsigned int` 类型。

较大的字符类型，如 `wchar_t` 、 `char16_t` 、 `char32_t` ，会被提升为 `int` 、 `unsigned int` 、 `long` 、 `unsigned long` 、 `long long` 、 `unsigned long long` 中最小可以容纳其所有取值的类型。

#### 无符号类型的运算对象
如果一个运算对象是无符号类型，另一个运算对象是带符号类型，转换会比较怪异。

如果无符号类型不小于带符号类型，如 `unsigned int` 相对于 `int` 来说，此时 `int` 会被转换成 `unsigned int` 。

如果无符号类型小于带符号类型，结果就依赖于机器。如果无符号类型的所有值都能被带符号类型容纳，那么无符号类型转换成带符号类型；否则，带符号类型转换成无符号类型。

### 其他隐式类型转换
- 数组转换成指针
- 指针的转换
    - 整数值0或者字面值nullptr可以转换成任意指针类型
    - 任意指向非常量的指针可以转换成 `void*` 类型
    - 任意指针可以转换成 `const void*` 类型
    - 类类型转换
    - 可以转换成布尔类型
    - 指向非常量的指针可以转换成指向常量的指针

### 显式转换

#### 命名的强制类型转换
- `static_cast` ：任何具有明确定义的、不含底层const的转换都可以使用
- `const_cast` ：只能改变底层const
- `reinterpret_cast` ：基本上用于指针的不保证安全的转换，如 `int*` 转换成 `char*` ，是对指针在底层上的重新解释，比较危险。
- `dynamic_cast` ：后面再说

#### 旧式的强制类型转换
```cpp
(type) expr;
type (expr);
```
同时具有上述前三种转换的功能，尽量不要使用。

## 运算符优先级表
优先级1：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `::` | 全局作用域 | `::name` | 左 |
| `::` | 类作用域 | `class::name` | 左 |
| `::` | 命名空间作用域 | `namespace::name` | 左 |

优先级2：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `.` | 成员选择 | `object.member` | 左 |
| `->` | 成员选择 | `pointer->member` | 左 |
| `[]` | 下标 | `expr[expr]` | 左 |
| `()` | 函数调用 | `name(expr-list)` | 左 |
| `()` | 类型构造 | `type(expr-list)` | 左 |

优先级3：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `++` | 后置递增运算 | `lvalue++` | 右 |
| `--` | 后置递减运算 | `lvalue--` | 右 |
| `typeid` | 类型ID | `typeid(type)` | 右 |
| `typeid` | 运行时类型ID | `typeid(expr)` | 右 |
| explicit cast | 类型转换 | `cast_name<type>(expr)` | 右 |

优先级4：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `++` | 前置递增运算 | `++lvalue` | 右 |
| `--` | 前置递减运算 | `--lvalue` | 右 |
| `~` | 位求反 | `~expr` | 右 |
| `!` | 逻辑非 | `!expr` | 右 |
| `-` | 一元负号 | `-expr` | 右 |
| `+` | 一元正号 | `+expr` | 右 |
| `*` | 解引用 | `*expr` | 右 |
| `&` | 取地址 | `&lvalue` | 右 |
| `()` | 类型转换 | `(type) expr` | 右 |
| `sizeof` | 对象的大小 | `sizeof expr` | 右 |
| `sizeof` | 类型的大小 | `sizeof(type)` | 右 |
| `sizeof...` | 参数包的大小 | `sizeof...(name)` | 右 |
| `new` | 创建对象 | `new type` | 右 |
| `new[]` | 创建数组 | `new type[size]` | 右 |
| `delete` | 释放对象 | `delete expr` | 右 |
| `delete[]` | 释放数组 | `delete[] expr` | 右 |
| `noexcept` | 能否抛出异常 | `noexcept(expr)` | 右 |

优先级5：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `->*` | 指向成员选择的指针 | `ptr->*member` | 左 |
| `.*` | 指向成员选择的指针 | `obj.*member` | 左 |

优先级6：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `*` | 乘法 | `expr * expr` | 左 |
| `/` | 除法 | `expr / expr` | 左 |
| `%` | 取模（取余） | `expr % expr` | 左 |

优先级7：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `+` | 加法 | `expr + expr` | 左 |
| `-` | 减法 | `expr - expr` | 左 |

优先级8：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `<<` | 向左移位 | `expr << expr` | 左 |
| `>>` | 向右移位 | `expr >> expr` | 左 |

优先级9：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `<` | 小于 | `expr < expr` | 左 |
| `<=` | 小于等于 | `expr <= expr` | 左 |
| `>` | 大于 | `expr > expr` | 左 |
| `>=` | 大于等于 | `expr >= expr` | 左 |

优先级10：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `==` | 等于 | `expr == expr` | 左 |
| `!=` | 不等于 | `expr != expr` | 左 |

优先级11：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `&` | 位与 | `expr & expr` | 左 |

优先级12：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `^` | 位异或 | `expr ^ expr` | 左 |

优先级13：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `\|` | 位或 | `expr \| expr` | 左 |

优先级14：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `&&` | 逻辑与 | `expr && expr` | 左 |

优先级15：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `\|\|` | 逻辑或 | `expr \|\| expr` | 左 |

优先级16：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `?:` | 条件 | `expr ? expr : expr` | 右 |

优先级17：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `=` | 赋值 | `lvalue = expr` | 右 |
| `*=` | 复合赋值 | `lvalue *= expr` | 右 |

优先级18：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `throw` | 抛出异常 | `throw expr` | 右 |

优先级19：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `,` | 逗号 | `expr, expr` | 左 |

<br><br>

# 语句

## 简单语句
一个表达式后面加分号就形成**表达式语句**，它求值并丢弃结果。

#### 空语句
仅有一个分号，它什么也不做。

#### 复合语句
即用花括号括起来的语句和声明的序列，又称**块**。

## 语句作用域
可以在 `if` 、 `switch` 、 `while` 、 `for` 语句的控制结构中定义变量，这些变量只在相应的语句内可见，如：
```cpp
while (int i = get_num())
    cout << i << endl;
i = 0;                      // 错误：i在这里不可见
```

## 条件语句

### switch语句

#### switch内部的变量定义
在不使用花括号的情况下，如果在一个 `case` 标签中定义了一个变量，那么它的作用域实际上是从定义开始到 `switch` 语句结束。这可能导致 `switch` 语句跳过这条定义语句。

C++标准规定，不允许跨过变量的初始化语句直接跳转到该变量的作用域内的另一个位置。这条规定实际上允许变量先声明，而在后面才初始化，只要初始化语句在最后的 `case` 标签中或者 `default` 标签中即可。

这对 `switch` 语句内的变量定义是比较苛刻的约束，比如需要在第二个标签定义一个变量而后续标签不需要使用它，这样的情况下，可以使用花括号来限制变量的作用域，如：
```cpp
case 1:
    {
        int i = 0;
        // ...
    }
    break;
```
这样 `i` 的作用域就不会覆盖到后续的标签。

## 迭代语句

### 范围for语句
C++11引入了范围for语句，可以用来遍历一个序列，如：
```cpp
vector<int> v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto &r : v)
    r *= 2;
```
`r` 在每次迭代都会重新定义，并初始化成序列中的下一个元素。这段代码等价于：
```cpp
for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) {
    auto &r = *beg;
    r *= 2;
}
```

## 跳转语句

### goto语句
跟[上述情况](#switch内部的变量定义)类似，向下跳转不允许跨过某个变量的初始化；回向的跳转越过变量的定义则相当于销毁变量再重新定义，这是允许的。

## try语句块和异常处理

### throw表达式
如：
```cpp
throw runtime_error("error message");
```
构造异常类可以使用string或者C风格字符串。

### try语句块
```cpp
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // ...
```
这里 `exception-declaration` 称作**异常声明**，一般形式如：
```cpp
catch (runtime_error err)
```
如果某个 `catch` 子句被选中，那么执行对应的 `handler-statements` ，然后继续执行整个 `try` 语句块之后的语句。

#### 编写处理代码
所有的异常类都提供了名为 `what()` 成员函数，它返回一个 `const char*` 指针。对于携带额外信息的异常类，如 `runtime_error` 可以用它来获取用来构造异常对象的string包含的信息。对于不携带额外信息的异常类，如 `exception` ， `what()` 返回的内容由编译器决定。

#### 函数在寻找处理代码的过程中退出
在一个函数中，如果一个异常被抛出而没有被任何 `catch` 语句匹配，那么终止这个函数并在上级函数继续寻找 `catch` 语句。如果在 `main` 函数中也没有找到，那么程序转入标准库的 `terminate` 函数，它的行为和系统有关，一般来说这个函数会导致程序非正常退出。

### 标准异常
异常类定义在4个头文件中：
- `exception` ：定义了最通用的异常类 `exception` ，它只报告异常的发生，不包含任何额外信息
- `stdexcept` ：定义了几个常用的异常类，具体有：
    - `exception` ：最常见的问题
    - `runtime_error` ：只有在运行时才能检测到的问题
    - `range_error` ：运行时错误，生成的结果超出了有意义的值域范围
    - `overflow_error` ：运行时错误，计算上溢
    - `underflow_error` ：运行时错误，计算下溢
    - `logic_error` ：程序逻辑错误
    - `domain_error` ：逻辑错误，参数对应的结果值不存在
    - `invalid_argument` ：逻辑错误，无效参数
    - `length_error` ：逻辑错误，试图创建一个超出该类型最大长度的对象
    - `out_of_range` ：逻辑错误，使用一个超出有效范围的值
- `new` ：定义了 `bad_alloc` 异常
- `typeinfo` ：定义了 `bad_cast` 异常

`exception` 、 `bad_alloc` 、 `bad_cast` 只能默认初始化。其他的异常则必须提供异常信息。

<br><br>

# 函数

## 函数基础

#### 形参和实参
实参的求值顺序是任意的。

### 局部对象
名字具有作用域，指程序文本的某一部分，名字在其中可见。对象具有生命周期，指程序执行过程中对象存在的一段时间。定义在所有函数体之外的对象存在于程序的整个执行过程中，定义在函数体内的对象则依赖定义的方式。

#### 自动对象
当控制流经过定义语句时，对象被创建；当控制流到达语句块末尾时，对象被销毁。这种对象称为**自动对象**。

#### 局部静态对象
当控制流第一次经过定义语句时，对象被创建；当控制流到达程序的末尾时，对象被销毁。这种对象称为**局部静态对象**。

### 函数声明
包括函数的三要素：返回类型、函数名和形参列表。又称作**函数原型**。

### 含有可变形参的函数

#### initializer_list形参
C++11引入了 `initializer_list` 类型，定义在 `initializer_list` 头文件中，它支持如下操作：
```cpp
initializer_list<T> lst;                // 默认初始化，T类型元素的空列表
initializer_list<T> lst{a, b, c};       // lst包含三个元素，它们是const的
lst2 = lst;                             // lst2是lst的副本
lst2(lst);                              // 同上
lst.size();                             // 返回lst中元素的个数
lst.begin();                            // 返回指向lst中第一个元素的指针
lst.end();                              // 返回指向lst中尾元素之后位置的指针
```
为了初始化一个 `initializer_list` 形参，可以使用花括号括起来的元素列表，如：
```cpp
error_msg({"functionX", "expected", "actual"});
```

#### 省略符形参
为了兼容C语言，C++允许使用 `varargs` 。

## 返回类型和return语句

### 有返回值函数
一般编译器要求所有可能控制流都必须返回一个值，否则会报错。如果编译器没能检测出一条未返回值的路径，那这条路径引发的行为是未定义的。

#### 引用返回左值
由于C++中函数可以返回引用，此时返回的是左值，则函数调用表达式也可以放在赋值语句的左侧。

#### 列表初始化返回值
C++11规定，函数可以返回花括号包围的值的列表，如：
```cpp
vector<string> process()
{
    if (expected.empty())
        return {};
    else if (expected == actual)
        return {"functionX", "okay"};
    else
        return {"functionX", expected, actual};
}
```

#### 主函数main的返回值
main函数可以不带 `return` 语句，此时编译器隐式插入 `return 0;` 。实际上为了指示程序执行的成功和失败，在 `cstdlib` 头文件中定义了两个预处理变量 `EXIT_SUCCESS` 和 `EXIT_FAILURE` 。

### 返回数组指针

#### 声明一个返回数组指针的函数
当不使用类型别名时，这比较复杂，一般形式如：
```cpp
Type (*function(parameter_list))[dimension];
```

#### 尾置返回类型
C++11引入了尾置返回类型，对于上面返回数组指针的函数的声明，可以写成：
```cpp
auto func(parameter_list) -> Type(*)[dimension];
```

#### 使用decltype
对于上面返回数组指针的函数的声明，也可以写成：
```cpp
// arr是对应类型数组的数组名
decltype(arr) *func(parameter_list);
```

## 函数重载

#### 重载和const形参
顶层const不能区分两个函数声明，或者说，因为函数无法改变形参，顶层const参数根本没有意义。

对于底层const的指针来说，有无const可以区分两个函数声明。当传递一个指向非常量的指针时，编译器会选择非常量版本的函数；当传递一个指向常量的指针时，编译器会选择常量版本的函数。

#### 调用重载的函数
当调用到一个被重载的函数名时，需要把这个调用与一个具体的函数关联起来，这叫做**函数匹配**或者**重载确定**。目前需要掌握的是，当调用重载函数时有三种可能的结果：
- 编译器找到一个与实参最佳匹配的函数，生成调用这个函数的代码
- 找不到任何一个函数与实参匹配，编译器发出无匹配的错误信息
- 有多于一个函数匹配，但没有最佳匹配，编译器发出二义性调用的错误信息

### 重载与作用域
在内层作用域声明同名的函数，会隐藏外层作用域的所有同名函数。即使内层的函数无法匹配调用，也无法调用外层的函数。

## 特殊用途语言特性

### 默认实参
可以为函数参数提供默认实参，所有具有默认实参的参数都必须出现在参数列表的末尾。如果一个具有默认实参的函数已经具有一个声明，后续的声明不能修改已经提供的默认实参，但是可以补充提供新的默认实参，如：
```cpp
string screen(int, int, char = ' ');
string screen(int, int, char = '*');        // 错误：不能修改已经提供的默认实参
string screen(int = 24, int = 80, char);    // 正确：补充提供新的默认实参
```

#### 默认实参初始化
局部变量不能作为默认实参，其他只要类型符合都可以。当使用默认实参时，其名字的解析是在函数声明的作用域内进行的；默认实参的求值是在调用时进行的。也就是说，即使在调用处有名字隐藏了默认实参的名字，实际上指向的仍然是原来的默认实参；而如果更改了默认实参的值，那么调用处实际传参的值也会改变。

### 内联函数和constexpr函数

#### 内联函数可避免函数调用的开销
声明和定义函数时在前面加上 `inline` 关键字即可，但只是请求编译器展开函数体，编译器可以选择忽略此请求。（根据网上查到的资料，似乎声明中的 `inline` 不起任何作用，甚至可以删除）

#### constexpr函数
C++11引入的 `constexpr` 关键字同样可以用于修饰函数，表示函数返回值可以用于常量表达式。它要求函数：
- 返回值是字面值类型
- 形参是字面值类型
- 函数体只有一条 `return` 语句

编译的时候，编译器把函数的调用替换为它的结果。实际上它也可以包含其他语句，但是它们不能进行任何实际操作，如空语句、类型别名和 `using` 声明。当返回的内容包含非常量表达式时，该函数的调用就不是常量表达式，比如：
```cpp
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();           // 正确：foo是常量表达式

constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

scale(2);       // 是常量表达式

int i = 2;
scale(i)；      // 不是常量表达式           
```
如果该函数的调用不是常量表达式，那么编译器将会报错。

#### 把内联函数和constexpr函数放在头文件中
因为编译器要展开这两种函数需要看到函数的定义，为了保证定义的相同，一般把它们放在头文件中。

### 调试帮助

#### assert预处理宏
它定义在 `cassert` 头文件中，归预处理器管而不是编译器管，不需要指定 `std::` 的命名空间，用法是：
```cpp
assert(expr);
```
对 `expr` 求值。如果 `expr` 为假，那么程序终止执行，打印相关信息；否则什么也不做。

#### NDEBUG预处理变量
当定义了NDEBUG的时候，assert什么也不做，连求值也不进行。可以使用 `#define NDEBUG` 来定义，或者在编译时指定 `-D NDEBUG` 。除了使用 `assert` 也可以自己借助 `NDEBUG` 来调试：
```cpp
void print(const int ia[], size_t size)
{
    #ifndef NDEBUG
        cerr << __func__ << ": array size is " << size << endl;
    #endif
}
```
这里 `__func__` 是编译器定义的特殊变量，常用的有如下五个：
- `__func__` ：当前函数名的字符串字面值
- `__FILE__` ：当前文件名的字符串字面值
- `__TIME__` ：当前文件编译时间的字符串字面值
- `__DATE__` ：当前文件编译日期的字符串字面值

### 函数匹配

#### 确定候选函数和可行函数
首先选定本次调用对应的重载函数集，这些函数称为**候选函数**。要求：
- 与被调用的函数同名
- 声明在调用点可见

然后考察实参，选出能被这些实参调用的函数，这些函数称为**可行函数**。要求：
- 形参数量和实参数量相等（还有默认实参的情况）
- 实参类型与形参类型相同，或者能转换成形参类型

如果找不到可行函数，编译器报无匹配函数的错误。

#### 寻找最佳匹配（如果有的话）
两种类型越接近，它们匹配得越好，规则在[下方](实参类型转换)。

#### 含有多个形参的函数匹配
如果函数有多个参数，寻找最佳匹配会很困难。其中的最佳匹配要满足：
- 每个实参的匹配都不劣于其他可行函数
- 至少有一个实参的匹配优于其他可行函数

如果没有函数能符合这个条件，则为二义性调用，编译器报错。

### 实参类型转换
为了确定最佳匹配，编译器把匹配程度从高到低划分为以下等级：
1. 精确匹配，有以下情况：
    - 实参类型和形参类型相同
    - 实参从数组类型或函数类型转换成对应指针类型
    - 添加或移除顶层const
1. 通过const转换实现的匹配（底层const）
1. 通过[类型提升](#整型提升)实现的匹配
1. 通过算术类型转换或指针转换实现的匹配
1. 通过类类型转换实现的匹配

#### 需要类型提升和算术类型转换的匹配
如果传入的实参是 `char` ，候选的重载函数有 `int` 和 `short` 版本， `char` 也是直接提升为 `int` 。所有的算术类型转换都是同级的。

## 函数指针

#### 使用函数指针
如果有函数指针 `pf` ，那么有以下两种方式调用函数：
```cpp
pf(args);
(*pf)(args);
```
通过函数名赋值给函数指针时，如果函数名有多个重载版本，被选择的函数名必须是精确匹配的。

#### 函数指针形参
下面两个声明是等价的：
```cpp
void useBigger(const string &s1, const string &s2, 
                bool (*pf)(const string &, const string &));

void useBigger(const string &s1, const string &s2,
                bool pf(const string &, const string &));
```
这比较冗长，可以使用 `typedef` 和 `decltype` 来简化：
```cpp
// 这两个声明是等价的，Func和Func2是函数类型
typedef bool Func(const string &, const string &);
typedef decltype(lengthCompare) Func2;

// 下面两个声明是等价的，FuncP和FuncP2是函数指针类型
typedef bool (*FuncP)(const string &, const string &);
typedef decltype(lengthCompare) *FuncP2;
```

#### 返回指向函数的指针
类似之前返回指向数组的指针，直接的写法类似于：
```cpp
int (*f1(int))(int, int);
```

<br><br>

# 类

## 定义抽象数据类型

#### =default的含义
如果希望编译器合成一个默认的构造函数，可以使用C++11引入的 `=default` ，如：
```cpp
Sales_data() = default;
```

## 访问控制与封装

#### 使用class或struct关键字
两者唯一的区别是， `class` 的默认访问权限是 `private` ，而 `struct` 的默认访问权限是 `public` 。

### 友元
有时候希望把某些成员声明成 `private` ，但又希望把某些操作它们的函数声明在类外，可以把它们声明成友元。方法是在类内重复它们的声明，并在声明前加上 `friend` 关键字：
```cpp
class Sales_data {
    friend Sales_data add(const Sales_data &, const Sales_data &);
    friend istream &read(istream &, Sales_data &);
    friend ostream &print(ostream &, const Sales_data &);
};
```
它们可以出现在类内的任何位置，不受访问控制符的影响。

值得一提的是，很多编译器并不强制限定友元函数必须在使用之前在类外声明。

## 类的其他特性

### 类成员再探

#### 定义一个类型成员
类可以自定义类型成员，它也受到访问控制符的影响，如：
```cpp
class Screen {
public:
    typedef std::string::size_type pos;
    using pos1 = std::string::size_type;
    // ...
};
```

#### 令成员作为内联函数
类内定义的成员函数是默认内联的，也可以显式用 `inline` 关键字指定内联。无需在声明处加上 `inline` ，虽然可以，但是只在定义加上 `inline` 其实更好理解。

#### 可变数据成员
使用关键字 `mutable` 声明的数据成员永远不会是 `const` ，即使它是 `const` 对象的的成员，所以 `const` 成员函数也可以修改它。

### 友元再探
也可以把类声明成友元，或者把其他类的成员函数声明成友元。可以把友元函数定义在类内，它们也是隐式内联的。

#### 类之间的友元关系
如果把某个类声明成友元，那么这个类的成员函数可以访问当前类的所有成员。友元关系没有传递性。语法如下：
```cpp
class Screen {
    friend class Window_mgr;
    // ...
};
```

#### 令成员函数作为友元
可以只把别的类中某个成员函数声明成友元，语法如下：
```cpp
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
    // ...
};
```

#### 友元声明和作用域
友元声明实际上不是一个函数声明，如果在类内声明了一个友元函数，但此时并没有该函数的实际声明（这是允许的），直到看到真正的声明之前，都无法调用这个友元函数。（有的编译器并不强制执行这样的限制）

## 类的作用域
如果在类外定义一个成员函数，需要指明它属于哪个类，语法如下：
```cpp
return-type ClassName::function-name(parameter-list)
{
    // ...
}
```
而在编译器看到了 `ClassName::` 之后的所有名字解析都是在类的作用域内进行的，所有参数中的类型和函数体中的变量都不再需要指出它们属于哪个类。由于 `return-type` 在这之前，当它也是类中的成员时，需要显式指出它属于哪个类。

### 名字查找与类的作用域
名字查找指寻找与所用名字最匹配的实体，它的规则如下：
1. 在名字所在的块中查找声明语句，只考虑在使用之前出现的声明。
1. 查找外层作用域。
1. 找不到则报错。

对于定义在类内的成员函数中的名字查找则有些区别。类的定义分两步处理：
1. 编译成员的声明
1. 直到类全部可见后才编译函数体

这就使得成员函数可以使用类中所有的名字，即使它们的声明出现在函数体之后。

#### 类型名要特殊处理
因为类型名可能会用于成员函数的声明，这需要在编译器读到的时候就进行解析，所有并不能像其他名字一样等到类全部可见后再解析。当某个成员函数使用了外层作用域中的某个名字，在该函数后就不允许再重新声明这个名字。因此，尽量把类型别名的声明放在类的开始处。

#### 成员定义中的普通块作用域的名字查找
成员函数中名字解析方式：
1. 在函数中查找声明语句，只考虑在使用之前出现的声明
1. 在类内查找
1. 在**函数定义**之前的作用域中查找

#### 类作用域之后，在外围的作用域中查找
如果明确需要使用全局作用域中的同名对象，可以使用作用域运算符 `::` ，如 `::object` 。

## 构造函数再探

### 构造函数初始值列表
所有成员的初始化会在构造函数体发生之前就完成。出现在初始值列表中的成员按照声明顺序使用给定的值进行初始化，有类内初始值的成员用该值初始化，其他成员会被默认初始化。在构造函数体中进行的是赋值操作而不是初始化。

#### 构造函数的初始值有时必不可少
像 `const` 常量和引用类型的成员，它们必须在构造函数体执行前就被赋予初始值。

### 委托构造函数
C++11扩展了构造函数初始值的功能，使得可以定义委托构造函数。执行的顺序是：
1. 受委托的构造函数的初始值列表
1. 受委托的构造函数的函数体
1. 委托构造函数的函数体

### 默认构造函数的作用
当对象被默认初始化或值初始化时自动执行默认构造函数。

默认构造函数在以下情况发生：
- 在块作用域内不使用初始值定义一个非静态变量
- 当一个类含有类类型成员且使用合成的默认构造函数时
- 当类类型成员没有在构造函数初始值列表中显式初始化时

值初始化在以下情况发生：
- 数组初始化时提供初始值数量少于数组大小
- 不使用初始值定义一个局部静态变量
- 写出如 `string()` 这样显式请求值初始化的表达式

#### 使用默认构造函数
注意不要写出 `string s();` ，这是一个函数声明，而不是一个默认初始化的 `string` 对象的声明。如果需要默认初始化的对象，直接写成 `string s;` 即可。

### 隐式的类类型转换
只有一个参数的构造函数被称为**转换构造函数**。

#### 只允许一步类类型转换
隐式的转换只能是一步转换，即必须有参数刚好匹配的构造函数。然而显式构造则不同，可以从C风格字符串隐式构造出string对象再进一步传递给接受string的构造函数。

#### 抑制构造函数定义的隐式转换
在构造函数前加上 `explicit` 关键字即可。它只对单参数的构造函数起作用，并且只能在类内声明时使用。使用它之后，隐式的转换就不再允许了。但是显式的转换仍然可以使用：
```cpp
Sales_data(null_book);
static_cast<Sales_data>(cin);
```

### 聚合类
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法。它需要满足以下条件成为聚合类：
- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有虚函数

它可以用初始值列表来初始化，如：
```cpp
struct Data {
    int ival;
    string s;
};

Data val1 = {0, "Anna"};
```
提供的初始值顺序必须和成员的声明顺序一致，初始值数量少于成员数量时后面的成员被值初始化，初始值数量不允许多于成员数量。这样的初始化方式有三个缺点：
- 所有成员都需要是public的
- 把正确初始化的任务交给了用户
- 添加或删除一个成员后，所有的初始化语句都需要修改

### 字面值常量类
它们也是字面值，可以拥有 `constexpr` 的函数成员，这些成员是隐式 `const` 的。数据成员都是字面值类型的聚合类是字面值常量类。如果类不是一个聚合类，满足以下条件时同样是字面值常量类：
- 数据成员都是字面值类型
- 类至少含有一个 `constexpr` 构造函数
- 如果一个数据成员含有类内初始值，那么它必须是一个常量表达式；如果是类类型成员，则初始值必须使用成员自己的 `constexpr` 构造函数
- 类必须使用析构函数的默认定义

#### constexpr构造函数
`constexpr` 函数要求只能包含一条 `return` 语句，由于构造函数没有返回值，所以函数体只能为空。它必须借助初始化列表来初始化所有成员，初始值要么使用 `constexpr` 构造函数，要么是常量表达式。

`constexpr` 构造函数用于生成 `constexpr` 对象以及 `constexpr` 函数的参数或返回类型。

## 类的静态成员

#### 定义静态成员
`static` 只能用于类内声明，在类外定义时不能重复使用 `static` 关键字。一般来说，不能再类的内部初始化静态成员，必须在类的外部定义和初始化它。类似于全局变量，它定义在任何函数之外，定义方式如下：
```cpp
double Account::interestRate = initRate();
```
这里的 `initRate` 是 `Account` 类的私有函数，但也能直接使用，因为类名 `Account` 提供了作用域。

#### 静态成员的类内初始化
一般来说不应该在类内初始化静态成员。然而可以为静态成员提供 `const` 整型的类内初始值，这要求该成员是 `constexpr` 的字面值常量类型，初始值必须是常量表达式。这可以用于类内数组的大小，如：
```cpp
class Account {
public:
    static constexpr int period = 30;
    double daily_tbl[period];
};
```
当程序只会用到该静态成员（原书提到的是对于const或constexpr static的成员，不太能确切理解）的值时，编译器可以替换掉它的所有出现，此时不需要在类的外部定义它。如果不能替换，如传递给一个接收引用的函数，此时需要左值，就需要在类的外部定义它。由于类内已经提供了初始值，类外定义时不允许再次提供初始值：
```cpp
constexpr int Account::period;
```
通常，即使类内提供了初始值，也应该在类的外部定义它。

#### 静态成员能用于某些场景，而普通成员不能
静态成员可以是不完全类型，甚至可以是类本身的类型。静态成员可以作为默认实参，普通成员不能。

# IO库

## IO类
头文件 `iostream` ：
- `istream` 和 `wistream` ：从流中读取数据
- `ostream` 和 `wostream` ：向流中写入数据
- `iostream` 和 `wiostream` ：读写流

头文件 `fstream` ：
- `ifstream` 和 `wifstream` ：从文件中读取数据
- `ofstream` 和 `wofstream` ：向文件中写入数据
- `fstream` 和 `wfstream` ：读写文件

头文件 `sstream` ：
- `istringstream` 和 `wistringstream` ：从string中读取数据
- `ostringstream` 和 `wostringstream` ：向string中写入数据
- `stringstream` 和 `wstringstream` ：读写string

这里以 `w` 开头的类是对宽字符的支持，读写的是 `wchar_t` 类型。对于 `cin` 、 `cout` 和 `cerr` ，对应的宽字符版本是 `wcin` 、 `wcout` 和 `wcerr` 。

`ifstream` 和 `istringstream` 是继承自 `istream` 的，`ofstream` 和 `ostringstream` 是继承自 `ostream` 的。

### IO对象无拷贝或赋值
IO对象不能拷贝或赋值，所以也不能把它们作为参数或返回值，一般需要以引用的方式传递。读写IO对象会改变其状态，所以它们不能是 `const` 引用。

### 条件状态
IO类定义了一些函数和状态，帮助访问和操纵流的**条件状态**（以下strm表示IO类型）：
- `strm::iostate` ：一个机器相关的类型，用于表示完整的条件状态
- `strm::badbit` ：流已崩溃
- `strm::failbit` ：IO操作失败
- `strm::eofbit` ：流到达文件结束
- `strm::goodbit` ：流未处于错误状态则为0
- `s.eof()` ：`eofbit` 置位则返回 `true`
- `s.fail()` ：`failbit` 或 `badbit` 置位则返回 `true`
- `s.bad()` ：`badbit` 置位则返回 `true`
- `s.good()` ：流处于有效状态则返回 `true`
- `s.clear()` ：所有条件状态复位，流状态设置为有效，返回 `void`
- `s.clear(flags)` ： `flags` 是 `iostate` 类型，把 `s` 中对应的状态位复位，返回 `void`
- `s.setstate(flags)` ： `flags` 是 `iostate` 类型，把 `s` 中对应的状态位置位，返回 `void`
- `s.rdstate()` ：返回 `s` 的当前状态，为 `iostate` 类型

如果 `cin` 的读操作失败，或者读到了文件结尾，那么它就会进入错误状态，后续所有的IO操作都会失败。最简单的检测流状态的方法是：
```cpp
while (cin >> word)
{
    // 状态ok：读操作成功
}
```

#### 查询流的状态
上述的方式只能知道流失败却不知为何，需要检查流的条件状态。四个状态位是 `iostate` 类型的 `constexpr` 值，可以用位运算符的方式一次检测或设置多个状态位。对于四个状态位的解释是：
- `badbit` ：系统级错误，流无法再使用
- `failbit` ：可恢复错误，如读取的类型与预期不符等
- `eofbit` ：流到达文件结束，同时 `failbit` 
- `goodbit` ：为0则表示流处于有效状态

#### 管理输出缓冲
输出流都有缓冲区，一般导致缓冲刷新的原因有：
- 程序正常结束，作为main函数的返回操作的一部分
- 缓冲区满
- 使用 `endl` 操纵符显式执行
- 用操纵符 `unitbuf` 来设置流的内部状态，使得缓冲区在每个输出操作之后刷新。默认情况下， `cerr` 是设置 `unitbuf` 的，所以它的输出是立即刷新的。
- 一个输出流可能被关联到另一个流，当读写被关联的流时，输出流的缓冲区会被刷新。默认情况下， `cin` 和 `cerr` 都关联到 `cout` 上，它们的读写操作会刷新 `cout` 的缓冲区。

#### 刷新输出缓冲区
- `endl` ：完成换行并刷新缓冲区
- `flush` ：刷新缓冲区，但不输出任何额外字符
- `ends` ：向流插入一个空字符，然后刷新缓冲区

#### unitbuf操纵符
如果希望在每次输出操作后都刷新缓冲区，可以使用 `unitbuf` 操纵符，如：
```cpp
cout << unitbuf;       // 所有输出操作后都刷新缓冲区
cout << nounitbuf;     // 回到正常的缓冲方式
```

#### 关联输入和输出流
`tie` 成员函数有两个重载版本：
- 不带参数，返回当前关联的输出流，如果没有关联则返回 `nullptr`
- 接受一个指向 `ostream` 的指针，将自己关联到这个 `ostream` 上

## 文件输出输出
除了继承自 `iostream` 的行为，还增加了一些用来管理文件的成员，有：
```cpp
fstream fstrm;              // 创建一个未绑定的文件流
fstream fstrm(s);           // 创建一个fstream并打开名为s的文件，s可以是string或者C风格字符串，两个构造函数都是explicit的。默认文件模式依赖于fstream对象的类型
fstream fstrm(s, mode);     // 文件模式由mode指定
fstrm.open(s);              // 打开名为s的文件并绑定到fstrm，s可以是string或者C风格字符串，默认文件模式依赖于fstream对象的类型。返回void
fstrm.open(s, mode);        // 文件模式由mode指定
fstrm.close();              // 关闭与fstrm关联的文件，返回void
fstrm.is_open();            // 返回一个bool值，指出与fstrm关联的文件是否成功打开，并且仍未关闭
```
这里文件名支持string对象，这是C++11的新特性。

### 使用文件流对象

#### 成员函数open和close
如果文件打开失败，流的 `failbit` 会被置位，可以用 `if` 语句简单地检查流的状态。当文件已经打开，再次对该流调用 `open` 会失败并导致 `failbit` 置位，需要先调用 `close` 关闭文件。 `open` 成功的话会设置流的状态使得 `good()` 返回 `true` 。

#### 自动构造和析构
当一个流对象离开作用域时，它的析构函数会自动调用 `close` 关闭文件。

### 文件模式
每个流都有一个关联的**文件模式**，指出如何使用文件，它们定义在类中，具体有以下几种模式：
- `in` ：以读方式打开
- `out` ：以写方式打开
- `app` ：每次写操作前均定位到文件末尾
- `ate` ：打开文件后立即定位到文件末尾
- `trunc` ：截断文件
- `binary` ：以二进制方式进行IO

指定文件模式有一些限制：
- 只有 `ofstream` 或 `fstream` 可以设定 `out`
- 只有 `ifstream` 或 `fstream` 可以设定 `in`
- 设定 `trunc` 必须也设定 `out`
- `trunc` 和 `app` 不能同时设定。 `app` 隐含 `out` 。
- `out` 默认会截断文件。同时设定 `app` 会追加至文件末尾，同时设置 `in` 进行读写操作。
- `ate` 和 `binary` 没什么限制

不同的文件流有不同的默认文件模式：
- `ifstream` 默认是 `in`
- `ofstream` 默认是 `out`
- `fstream` 默认是 `in | out`

## string流
除了继承自 `iostream` 的行为，还增加了一些用来管理string的成员，有：
```cpp
sstream sstrm;              // 创建一个未绑定的string流
sstream sstrm(s);           // 创建一个sstream，保存一个string s的副本
sstrm.str();                // 返回保存的string副本的拷贝
sstrm.str(s);               // 用s的副本替换保存的string副本。返回void
```

### 使用ostringstream
它把输出的数据存储在内置的string对象中，可以用 `str` 成员函数来获取这个string对象。

<br><br>

# 顺序容器
为程序员提供了控制元素存储和访问顺序的能力，这种顺序不依赖于元素的值，而是与元素加入容器时的位置有关。

## 顺序容器概述
顺序容器有以下几种：
- `vector` ：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
- `deque` ：双端队列。支持快速随机访问。在头尾位置插入或删除元素很快。
- `list` ：双向链表。只支持双向顺序访问。在任何位置插入或删除元素都很快。
- `forward_list` ：单向链表。只支持单向顺序访问。在链表任何位置插入或删除元素都很快。
- `array` ：固定大小数组。支持快速随机访问。不能添加或删除元素。
- `string` ：与 `vector` 类似的容器，但专门用于保存字符。随机访问快。在尾部插入或删除元素快。

这里的 `forward_list` 和 `array` 是C++11新增的。

#### 确定使用哪种顺序容器
以下是一些选择容器的基本原则：
- 除非有很好的理由选择其他容器，否则应该使用 `vector`
- 元素小并且在意空间开销，就不要使用 `list` 或 `forward_list`
- 需要随机访问，应使用 `vector` 或 `deque`
- 需要在中间插入或删除元素，应使用 `list` 或 `forward_list`
- 需要在头尾插入或删除元素，但不会在中间插入或删除元素，应使用 `deque`
- 只在读取输入时需要在中间插入元素，其后进行随机访问，则
    - 如果只是为了保持有序而在中间插入元素，应考虑使用 `vector` 在结尾插入，结合 `sort` 算法来排序
    - 如果必须在中间插入元素，考虑在插入时使用 `list` ，然后拷贝到 `vector` 中

## 容器库概览
一般来说，每个容器都定义在一个同名头文件中。

#### 对容器可以保存的元素类型的限制
因为允许容器的构造函数有一个只接受元素数目的版本，如果元素是类类型，则会使用它的默认构造函数。然而有的类没有默认构造函数，可以使用顺序容器来存储它，但是不能使用上述方式创建容器。

#### 所有容器类型的共同操作
- 类型别名：
    - `iterator` ：此容器类型的迭代器类型
    - `const_iterator` ：可以读取元素，但不能修改元素的迭代器类型
    - `size_type` ：无符号整型，足以保存该容器的最大可能大小
    - `difference_type` ：有符号整型，足以保存两个迭代器之间的距离
    - `value_type` ：元素类型
    - `reference` ：元素的左值类型；与 `value_type &` 等价
    - `const_reference` ：元素的 `const` 左值类型；与 `const value_type &` 等价
- 构造函数
    - `C c` ：默认构造函数，构造空容器
    - `C c1(c2)` ：拷贝构造函数，构造 `c2` 的副本 `c1`
    - `C c(b, e)` ：构造函数，构造 `c` 并用迭代器 `b` 和 `e` 之间的元素拷贝到 `c` 中
    - `C c{a, b, c}` ：列表初始化
- 赋值与swap
    - `c1 = c2` ：将 `c1` 中的元素替换为 `c2` 中的元素
    - `c1 = {a, b, c}` ：将 `c1` 中的元素替换为列表中的元素
    - `a.swap(b)` ：交换 `a` 和 `b` 中的元素
    - `swap(a, b)` ：同上
- 大小
    - `c.size()` ： `c` 中元素的数目
    - `c.max_size()` ： `c` 可保存的最大元素数目
    - `c.empty()` ： 如果 `c` 中存储了元素则返回 `false` ，否则返回 `true`
- 插入和删除（不适用于 `array` ，且在不同的容器中这些接口有所不同）
    - `c.insert(args)` ：将 `args` 插入到 `c` 中
    - `c.emplace(inits)` ：用 `inits` 在 `c` 中直接构造一个元素
    - `c.erase(args)` ：删除 `args` 指定的元素
    - `c.clear()` ：删除 `c` 中的所有元素，返回 `void`
- 关系运算符
    - `==` 、 `!=` ：相等性判断（所有容器都支持）
    - `<` 、 `<=` 、 `>` 、 `>=` ：关系判断（无序关联容器不支持）
- 获取迭代器
    - `c.begin()` ：返回指向 `c` 的首元素的迭代器
    - `c.end()` ：返回指向 `c` 末尾元素的下一个位置的迭代器
    - `c.cbegin()` ：返回指向 `c` 的首元素的 `const` 迭代器
    - `c.cend()` ：返回指向 `c` 末尾元素的下一个位置的 `const` 迭代器
- 反向容器的额外成员（不支持 `forward_list` ）
    - `reverse_iterator` ：按逆序寻址元素的迭代器
    - `const_reverse_iterator` ：不能修改元素的逆序迭代器
    - `c.rbegin()` ：返回指向 `c` 的尾元素的迭代器
    - `c.rend()` ：返回指向 `c` 首元素的前一个位置的迭代器
    - `c.crbegin()` ：返回指向 `c` 的尾元素的 `const` 迭代器
    - `c.crend()` ：返回指向 `c` 首元素的前一个位置的 `const` 迭代器

## 迭代器

### begin和end成员
它们有多个版本，如：
```
a.begin();
a.rbegin();
a.cbegin();
a.crbegin();
```
其中不以 `c` 开头的都是重载成员函数，它们根据 `this` 指针是否含有底层 `const` 来决定实际调用哪个函数。 `c` 开头的函数来自于C++11新标准。

### 容器定义和初始化
```cpp
C C;                // 默认构造函数。如果C是array，则C中的元素被默认初始化；否则C为空
C c1(c2);           // 拷贝构造函数。c1是c2的副本，它们需要是同一种类型
C c1 = c2;          // 同上
C c{a, b, c};       // c初始化为初始化列表中元素的拷贝，列表中元素的类型必须与C的元素类型相容。初始值的数量必须小于或等于array的大小，没有提供初始值的元素被值初始化。
C c = {a, b, c};    // 同上
C c(b, e);          // c初始化为迭代器b和e之间的元素，范围中元素的类型需要与C的元素类型相容（array不适用）
// 只有顺序容器（不含array）支持以下初始化方式
C c(n);             // c包含n个元素，每个元素都是C的默认初始化值，此构造函数是explicit的（string不适用）
C c(n, t);          // c包含n个元素初始化为值t的元素
```

#### 标准库array具有固定大小
array的定义方式：
```cpp
array<int, 42> a1;          // 默认初始化，a1中的元素被默认初始化
array<int, 10> a2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    // 列表初始化
array<int, 10> a3 = {42};    // a3[0] = 42，后续的元素为0
```
内置类型的数组不可以进行拷贝，而array可以，需要保证类型和大小都相同。

### 赋值和swap
所有的容器都支持赋值操作，总共有以下的操作方式：
```cpp
c1 = c2;          // c1中的元素替换为c2中的元素的拷贝。c1和c2必须是相同类型的容器
c = {a, b, c};    // c中的元素替换为列表中的元素的拷贝（array不适用）
swap(c1, c2);     // 交换c1和c2中的元素。c1和c2必须是相同类型的容器
c1.swap(c2);      // 同上
// assign操作不适用于关联容器和array
seq.assign(b, e);    // 用迭代器b和e之间的元素替换seq中的元素。迭代器不能指向seq中的元素
seq.assign(il);      // 用列表il中的元素替换seq中的元素
seq.assign(n, t);    // 用n个值为t的元素替换seq中的元素
```
为了保证给出初始值的数量是正确的，array不支持使用列表和 `assign` 赋值。

#### 使用swap
对 `array` 使用 `swap` 的时候，它会真正地交换元素，所以效率不高。对于其他容器， `swap` 只是交换了内部数据结构，所以效率很高。值得一提的是，对于 `string` 来说，调用 `swap` 会使得迭代器、引用和指针失效，而对于其他容器则不会。

### 容器大小操作
一般有三个操作， `size` 、 `max_size` 和 `empty` 。其中 `forward_list` 不支持 `size` 操作，其他容器都支持。

### 关系运算符
所有容器都支持 `==` 和 `!=` 运算符。除了无序关联容器都支持 `<` 、 `<=` 、 `>` 和 `>=` 运算符。

#### 容器的关系运算符使用元素的关系运算符完成比较
相等关系使用元素的 `==` 进行比较，其他关系使用元素的 `<` 进行比较。

## 顺序容器操作

### 向顺序容器添加元素
除了 `array` ，其他的容器都有动态内存管理功能，可以运行时添加删除元素。以下是添加元素的操作：
```cpp
// forward_list有自己专有版本的insert和emplace
c.push_back(t);             // 在c的尾部创建一个值为t的元素。返回void（forward_list不支持）
c.emplace_back(inits);      // 用inits在c的尾部直接构造一个元素。返回void（forward_list不支持）
c.push_front(t);            // 在c的头部创建一个值为t的元素。返回void（vector和string不支持）
c.emplace_front(inits);     // 用inits在c的头部直接构造一个元素。返回void（vector和string不支持）
c.insert(p, t);             // 在迭代器p指向的元素之前创建一个值为t的元素。返回指向新添加元素的迭代器
c.emplace(p, inits);        // 用inits在迭代器p指向的元素之前直接构造一个元素。返回指向新添加元素的迭代器
c.insert(p, n, t);          // 在迭代器p指向的元素之前创建n个值为t的元素。返回指向第一个新添加元素的迭代器。如果n为0，则返回p
c.insert(p, b, e);          // 在迭代器p指向的元素之前创建迭代器b和e之间的元素。返回指向第一个新添加元素的迭代器。如果b和e相等，则返回p
c.insert(p, il);            // 在迭代器p指向的元素之前创建列表il中的元素。返回指向第一个新添加元素的迭代器。如果il为空，则返回p
```
在 `string` 和 `vector` 除了尾部的任何位置，或是 `deque` 的首尾之外的任何位置，插入元素都会引起元素的移动，从而导致迭代器失效。

向 `string` 和 `vector` 添加元素还可能引起整个对象存储空间重新分配。

#### 插入范围内元素
C++11中，接受元素个数或范围的 `insert` 返回指向第一个新加入元素的迭代器。（以前返回 `void` ）

#### 使用emplace操作
`emplace` 、 `emplace_back` 和 `emplace_front` 都是C++11引入的，它们不拷贝元素，而是直接在对应的位置调用构造函数来构造新元素。

### 访问元素
所有顺序容器都有 `front` 成员函数，除了 `forward_list` 之外的顺序容器都有 `back` 成员函数。 使用它们之前务必确保容器不为空。顺序容器中访问元素的操作：
```cpp
c.back();       // 返回c中尾元素的引用。c不能为空
c.front();      // 返回c中首元素的引用。c不能为空
// 以下操作只适用于string、vector、deque和array
c[n];           // 返回c中下标为n的元素的引用。n是无符号整数且不能超过c.size()
c.at(n);        // 返回c中下标为n的元素的引用。数组越界则抛出out_of_range异常
```

### 删除元素
顺序容器的删除操作（除array）：
```cpp
// forward_list有特殊版本的erase
c.pop_back();       // 删除c中的尾元素。c不能为空。返回void（forward_list不支持）
c.pop_front();      // 删除c中的首元素。c不能为空。返回void（vector和string不支持）
c.erase(p);         // 删除迭代器p指向的元素。返回指向p之后位置的迭代器。p不能是尾后迭代器
c.erase(b, e);      // 删除迭代器b和e之间的元素。返回指向e之后位置的迭代器。如果e本身就是尾后迭代器，则返回尾后迭代器
c.clear();          // 删除c中的所有元素。返回void
```
删除 `deque` 中除首尾位置之外的任何位置的元素都会使所有迭代器、引用和指针失效。

删除 `string` 和 `vector` 中元素会使指向删除点之后的元素的迭代器、引用和指针失效。

### 特殊的forward_list操作
插入或删除的操作：
```cpp
lst.before_begin();             // 返回指向首元素之前的元素的迭代器，不能解引用
lst.cbefore_begin();            // 返回指向首元素之前的元素的const迭代器，不能解引用

// 以下插入操作，p不能为尾后迭代器，都返回指向插入的最后一个元素的迭代器
lst.insert_after(p, t);         // 在迭代器p指向的元素之后创建一个值为t的元素。
lst.insert_after(p, n, t);      // 在迭代器p指向的元素之后创建n个值为t的元素。
lst.insert_after(p, b, e);      // 在迭代器p指向的元素之后创建迭代器b和e之间的元素。如果b和e相等，则返回p。b和e不能指向lst中的元素
lst.emplace_after(p, inits);    // 用inits在迭代器p指向的元素之后直接构造一个元素。

// 以下删除操作，p不能指向最后一个元素或为尾后迭代器。返回指向被删除元素之后的元素的迭代器，如果没有这个元素则返回尾后迭代器
lst.erase_after(p);             // 删除迭代器p指向的元素之后的元素
lst.erase_after(b, e);          // 删除迭代器b和e之间的元素。b和e指向的元素都不被删除
```

### 改变容器大小
顺序容器大小操作（不适用于array）：
```cpp
c.resize(n);            // 调整c的大小为n个元素，如果n小于c.size()，多余的元素被丢弃；如果n大于c.size()，则在c的尾部插入值初始化的元素
c.resize(n, t);         // 如果新添加元素，那么初始化为t
```
如果 `resize` 缩小函数，则指向被删除元素的迭代器、引用和指针都会失效。

对 `vector` 、 `string` 或 `deque` 使用 `resize` 可能导致迭代器、引用和指针失效。

### 容器操作可能使迭代器失效
向容器添加元素后：
- `vector` 和 `string` ，如果引起了内存重新分配，所有指向容器的迭代器、引用和指针都会失效；否则指向插入点之后的才会失效
- `deque` ，插入到除首尾位置之外的任何位置都会使所有迭代器、引用和指针失效。在首尾插入时，迭代器失效，但引用和指针不会失效
- `list` 和 `forward_list` ，不会失效

删除元素后：
- `list` 和 `forward_list` ，不会失效
- `deque` ，除了在首尾位置删除，所有的迭代器、引用和指针都会失效。如果在尾部删除，只有尾后迭代器会失效；如果在首部删除，则不会失效。
- `vector` 和 `string` ，指向被删除元素之前的迭代器、引用和指针仍有效。

标准库的 `end()` 操作很快。因此，如果需要向容器插入或删除元素，不要保存 `end()` 的返回值，而是每次都重新获取。

## vector对象是如何增长的
`string` 和 `vector` 类似，每次分配的内存不够时就重新分配更大的内存，一般会超出目前需要的内存做提前分配，具体分配多少视实现而定。

#### 管理容量的成员函数
`vector` 和 `string` 提供了一些成员让程序员可以与内存分配策略互动：
```cpp
c.capacity();       // 如果不重新分配内存，c可以保存多少元素
c.reserve(n);       // 保证c至少能保存n个元素，如果不够则重新分配内存
c.shrink_to_fit();  // 请求c将capacity减少为size大小
```
`shrink_to_fit` 是C++11新增的，同时适用于 `deque` ，实现可以忽略这个请求。

## 额外的string操作

### 构造string的其他方法
除了前面介绍的构造函数，以及与其他顺序容器相同的构造函数， `string` 还有以下几种构造函数：
```cpp
string s(cp, n);            // s是字符数组cp的前n个字符的拷贝，n不能超过cp的长度
string s(s2, pos2);         // s是string s2从下标pos2开始的字符的拷贝。pos2不应该大于s2.size()，否则抛出out_of_range异常。
string s(s2, pos2, len2);   // s是string s2从下标pos2开始的len2个字符的拷贝。拷贝不会超过s2的末尾。pos2不应该大于s2.size()，否则抛出out_of_range异常。
```

#### substr操作
子字符串操作：
```cpp
s.substr(pos = 0, n = s.size() - pos);       // 返回一个string，包含s中从下标pos开始的n个字符的拷贝。
```

### 改变string的其他方法
```cpp
s.insert(pos, args);        // 在pos之前插入args。pos可以是下标或迭代器。下标版本返回指向s的引用，迭代器版本返回指向第一个插入字符的迭代器
s.erase(pos, len);          // 删除从pos开始的len个字符。pos同上。len可以省略，此时删除到结尾的所有字符。返回一个指向s的引用
s.assign(args);             // 用args替换s中的字符。返回一个指向s的引用
s.append(args);             // 在s的末尾添加args。返回一个指向s的引用
s.replace(range, args);     // 用args替换range中的字符。range可以是下标加一个长度，或者一对迭代器。返回一个指向s的引用
```
完整地说， `args` 的形式以及不同的成员可以使用的形式如下表：
| `args` | `append` 和 `assign` | `replace(pos, len, args)` | `replace(b, e, args)` | `insert(pos, args)` | `insert(iter, args)` |
| :-: | :-: | :-: | :-: | :-: | :-: |
| `str` | o | o | o | o | |
| `str, pos, len` | o | o | | o | |
| `cp, len` | o | o | o | o | |
| `cp` | o | o | o | | |
| `n, c` | o | o | o | o | o |
| `b2, e2` | o | | o | | o |
| 初始化列表 | o | | o | | o |

### string搜索操作
搜索函数返回的待搜索对象出现的下标位置，它是 `string::size_type` 类型，如果没有找到则返回名为 `string::npos` 的 `static` 成员。标准库将 `string::npos` 定义为 `const string::size_type` 类型并初始化为 `-1` ，转换为无符号类型实际上就是最大可能的值。

支持的搜索函数如下：
```cpp
s.find(args);                   // 查找s中args第一次出现的位置
s.rfind(args);                  // 查找s中args最后一次出现的位置
s.find_first_of(args);          // 查找s中args中任何一个字符第一次出现的位置
s.find_last_of(args);           // 查找s中args中任何一个字符最后一次出现的位置
s.find_first_not_of(args);      // 查找s中第一个不在args中的字符的位置
s.find_last_not_of(args);       // 查找s中最后一个不在args中的字符的位置
```
以上的 `args` 必须是如下形式之一：
- `c, pos` ：从 `s` 中位置 `pos` 开始查找字符 `c` 。 `pos` 默认为0
- `s2, pos` ：从 `s` 中位置 `pos` 开始查找 `string s2` 。 `pos` 默认为0
- `cp, pos` ：从 `s` 中位置 `pos` 开始查找C风格字符串 `cp` 。 `pos` 默认为0
- `cp, pos, n` ：从 `s` 中位置 `pos` 开始查找C风格字符串 `cp` 的前 `n` 个字符。 `pos` 和 `n` 没有默认值

### compare函数
类似于 `strcmp` ， `string` 也提供了 `compare` 接口，相等返回0，大于返回正数，小于返回负数。它可以接受以下的参数：
- `s2` ： `s` 与 `s2` 比较
- `pos1, n1, s2` ： `s` 从 `pos1` 开始的 `n1` 个字符与 `s2` 比较
- `pos1, n1, s2, pos2, n2` ： `s` 从 `pos1` 开始的 `n1` 个字符与 `s2` 从 `pos2` 开始的 `n2` 个字符比较
- `cp` ： `s` 与C风格字符串 `cp` 比较
- `pos1, n1, cp` ： `s` 从 `pos1` 开始的 `n1` 个字符与C风格字符串 `cp` 比较
- `pos1, n1, cp, n2` ： `s` 从 `pos1` 开始的 `n1` 个字符与C风格字符串 `cp` 的前 `n2` 个字符比较

### 数值转换
C++11引入了多个函数来支持数值数据和 `string` 之间的转换，如果 `string` 转换为一个数值，则会抛出 `invalid_argument` 异常；如果转换后的数值无法用任何类型表示，则会抛出 `out_of_range` 异常。以下是这些函数：
```cpp
to_string(val);             // 浮点类型、int和更大的整型都有对应的重载版本。小整型会被提升。

// 将s从开头到p的子串按b进制解释为整数，p默认为0，b默认为10
stoi(s, p, b);              // 返回int类型
stol(s, p, b);              // 返回long类型
stoul(s, p, b);             // 返回unsigned long类型
stoll(s, p, b);             // 返回long long类型
stoull(s, p, b);            // 返回unsigned long long类型

// 将s从开头到p的子串解释为浮点数
stof(s, p);                 // 返回float类型
stod(s, p);                 // 返回double类型
stold(s, p);                // 返回long double类型
```

## 容器适配器
**适配器**指的是让某种事物的行为看起来像另一种事物一样，比如可以在 `vector` 上模拟一个栈的行为。标准库有三种适配器，分别是 `stack` 、 `queue` 和 `priority_queue` 。它们有一些通用的操作和类型
- `size_type` ：一种类型，足以保存当前类型的最大对象的大小
- `value_type` ：元素类型
- `container_type` ：实现适配器的底层容器类型
- `A a` ：创建一个名为 `a` 的空适配器
- `A a(c)` ：创建一个名为 `a` 的适配器，带有容器 `c` 的一个拷贝
- 关系运算符：所有适配器都支持所有关系运算符
- `a.empty()` ：如果 `a` 中没有元素则返回 `true` ，否则返回 `false`
- `a.size()` ：返回 `a` 中元素的数目
- `a.swap(b)` 或 `swap(a, b)` ：交换 `a` 和 `b` 中的元素。 `a` 和 `b` 必须是相同类型的适配器，且底层容器类型必须相同

#### 定义一个适配器
不同的适配器可以使用的底层容器类型：
- `stack` ：需要支持 `back` 、 `push_back` 、 `pop_back` 操作，则可以使用除了 `array` 和 `forward_list` 之外的任何顺序容器
- `queue` ：需要支持 `back` 、 `push_back` 、 `front` 、 `pop_front` 操作，则可以使用 `list` 和 `deque`
- `priority_queue` ：除了 `stack` 的需求，还需要随机访问，所以只能使用 `vector` 和 `deque`

#### 栈适配器
`stack` 定义在 `stack` 头文件中，默认基于 `deque` 实现。它独有的操作有：
- `s.pop()` ：删除 `s` 的顶部元素。返回 `void`
- `s.push(item)` ：通过拷贝或移动 `item` ，在栈顶创建一个新的元素
- `s.emplace(args)` ：通过 `args` 直接构造一个新的元素在栈顶
- `s.top()` ：返回栈顶元素但不出栈。

#### 队列适配器
`queue` 和 `priority_queue` 定义在 `queue` 头文件中， `deque` 默认基于 `deque` 实现， `priority_queue` 默认基于 `vector` 实现。它们独有的操作有：
- `q.pop()` ：弹出 `queue` 的首元素或 `priority_queue` 的最高优先级元素，不返回该元素。
- `q.front()` ：返回 `queue` 的首元素或 `priority_queue` 的最高优先级元素，但不删除它。
- `q.back()` ：只适用于 `queue` ，返回 `queue` 的尾元素，但不删除它。
- `q.top()` ：只适用于 `priority_queue` ，返回 `priority_queue` 的最高优先级元素，但不删除它。
- `q.push(item)` ：在 `queue` 的尾部或 `priority_queue` 的合适位置插入一个新元素，值为 `item` 。
- `q.emplace(args)` ：在 `queue` 的尾部或 `priority_queue` 的合适位置用 `args` 直接构造一个新元素。

值得一提的是， `priority_queue` 默认是大顶堆。它使用元素上的运算符 `<` 来比较元素。

<br><br>

# 泛型算法

## 概述
大多数算法定义在头文件 `algorithm` 中，还有一组数值泛型算法定义在 `numeric` 头文件中。

以 `find` 为例，它接受一对迭代器加上一个需要查找的值，返回一个指向第一个等于给定值的元素的迭代器。如果没有找到，则返回第二个迭代器。

## 初识泛型算法

### 只读算法
一些算法只会读取元素，不会改变它们。比如上面提到的 `find` ，在一个区间上查找 ：
```cpp
auto it = find(v.cbegin(), v.cend(), val);
```
以及 `accumulate` ，对一个区间进行求和：
```cpp
int sum = accumulate(v.cbegin(), v.cend(), 0);
```
这里的 `0` 是初始值，它决定了使用哪个加法运算符，进而决定了返回值的类型。

#### 操作两个序列的算法
`equal` 可以用于判断两个序列是否相等：
```cpp
bool is_equal = equal(v1.cbegin(), v1.cend(), v2.cbegin());
```
两个序列的元素类型不用相同，只要支持 `==` 运算符即可。需要保证第二个序列至少有第一个序列那么长。

### 写容器元素的算法
一些算法会向给定的范围内写入元素，比如 `fill` ：
```cpp
fill(v.begin(), v.end(), 0);                        // 将区间内填充为0
fill(v.begin(), v.begin() + v.size() / 2, 10);      // 将前一半填充为10
```
或者 `fill_n` ：
```cpp
fill_n(v.begin(), v.size(), 0);                     // 将v中所有元素填充为0
```
然而 `fill_n` 的使用比较容易用出问题，比如错误地向空容器中填充元素：
```cpp
vector<int> v;
fill_n(v.begin(), 10, 0);      // 错误：v是空的，没有元素可以填充
```

#### 介绍back_inserter
因为迭代器失效的问题，不太可能用泛型算法结合普通迭代器来向容器中添加元素，这时可以用到**插入迭代器**。以 `back_inserter` 为例，它定义在头文件 `iterator` 中：
```cpp
vector<int> v;
auto it = back_inserter(v);     // 获得一个在末尾插入元素的迭代器
*it = 42;                       // 在v的末尾插入了一个元素，值为42
```
实际上该迭代器自动调用了 `push_back` 函数，利用这样的特性就可以结合 `fill_n` 来向空容器中填充元素：
```cpp
fill_n(back_inserter(v), 10, 0);    // 向v中插入10个0
```

#### 拷贝算法
`copy` 把一个区间的元素拷贝到给定的位置，同样要保证第二个序列不短于第一个序列：
```cpp
auto it = copy(v1.cbegin(), v1.cend(), p);
```
在拷贝的过程中， `p` 不断递增，最后算法返回 `p` 。即 `it` 指向拷贝的最后一个元素的下一个位置。

同样可以结合插入迭代器来使用。

### 重排容器元素的算法
`sort` 借助元素的 `<` 运算符来对区间升序排序：
```cpp
sort(v.begin(), v.end());
```

#### 使用unique
对于有序序列，可以使用 `unique` 把重复的元素移到末尾：
```cpp
auto it = unique(v.begin(), v.end());
```
它返回重排后不重复序列的下一个位置。

#### 使用容器操作删除元素
因为迭代器失效的问题， `unique` 并不真正删除元素，需要自行通过 `erase` 来删除。

### 向算法传递函数
有时需要改变算法默认的行为，可以给算法传递一个**谓词**。

#### 谓词
它是一个可调用的表达式，返回值是一个能用作条件的值。标准库使用**一元谓词**和**二元谓词**。以 `sort` 为例，它默认使用 `<` 运算符来比较元素，但可以传入二元谓词谓词来改变比较方式：
```cpp
sort(v.begin(), v.end(), isShorter);
```

#### 排序算法
有时自己给出的排序规则表示两个元素相等，但实际上仍有不同。希望排序时保持相等元素的相对位置可以使用 `stable_sort` ：
```cpp
stable_sort(v.begin(), v.end(), isShorter);
```

### lambda表达式
考虑在一个 `string` 组成的序列中，找到长度大于给定值的第一个元素，如果使用 `find_if` 它接受一个谓词，但谓词本身只能接受一个参数 `string` ，没法动态调整条件的长度。这时可以使用C++11引入的**lambda表达式**。

#### 介绍lambda
谓词可以是任何**可调用对象**，即能够对齐使用 `()` 运算符的对象，有函数、函数指针、重载了 `()` 运算符的类对象以及lambda表达式。lambda表达式的一般形式如下：
```cpp
[capture list](parameter list) -> return type { function body }
```
其中参数列表和返回类型可以省略。当省略返回类型时，如果函数体只有一条 `return` 语句，编译器会根据 `return` 语句的返回类型推断返回类型；如果包含任何其他语句，返回类型则是 `void` 。

#### 向lambda传递参数
lambda表达式不能有默认实参。

#### 使用捕获列表
通过捕获列表，lambda表达式可以捕获局部变量，从而在函数体内使用它们。

#### 调用find_if
`find_if` 从指定区间中查找第一个使谓词返回 `true` 的元素：
```cpp
auto it = find_if(words.begin(), words.end(), 
    [sz](const string &a) 
        { return a.size() >= sz; });
```
`find_if` 返回指向该元素的迭代器，或者第二个参数的拷贝。

#### for_each算法
`for_each` 接受一个可调用对象，对区间中的每个元素调用它：
```cpp
for_each(words.begin(), words.end(), 
    [](const string &s) { cout << s << " "; });
```
这里没有捕获 `cout` ，因为lambda表达式可以获取当前函数外的变量。实际上lambda还可以直接使用局部 `static` 变量。

### lambda捕获和返回
实际上编译器为lambda表达式生成一个匿名类类型，实际上向泛型算法传递的是这个类型的一个匿名对象，捕获的变量称为该类的数据成员，它们在对象创建时被初始化。

#### 值捕获
值捕获要求变量的类型是可以拷贝的，它在lambda类型被创建时拷贝，所以后续修改被捕获的变量不会影响lambda内部的值。

#### 引用捕获
lambda生成一个引用成员，它绑定到被捕获的变量。因此，被捕获的变量必须在lambda执行时仍有效。

#### 隐式捕获
在捕获列表中只写一个 `&` 或者 `=` ，编译器会自动捕获需要的变量， `&` 表示引用捕获， `=` 表示值捕获。

也可以包含一些特例采用别的捕获方式，此时 `&` 和 `=` 必须出现在第一个位置：
- 当第一个使用 `&` 时，后面所有变量不允许前加 `&`
- 当第一个使用 `=` 时，后面所有变量必须前加 `&`

#### 可变lambda
默认情况下值捕获的变量在函数体内是只读的，尝试修改它将无法通过编译。如果需要修改，可以在参数列表后加上 `mutable` ：
```cpp
int v = 42;
auto f = [v]() mutable { return ++v; };
```
这样lambda表达式内部的 `v` 就是一个可修改的局部变量。而引用捕获的变量是否可以修改则取决于该变量本身是否是 `const` 。

#### 指定lambda返回类型
如果lambda被推断为返回 `void` ，它不能返回值。

### 参数绑定
如果要在多个地方使用同样的lambda，并且它包含有捕获列表，C++11引入了名为 `bind` 的标准库函数。

#### 标准库bind函数
`bind` 函数定义在头文件 `functional` 中，一般调用形式为：
```cpp
auto newCallable = bind(callable, arg_list);
```
`newCallable` 是一个新的可调用对象，调用它时，它会调用 `callable` ，并把 `arg_list` 中的参数传递给 `callable` 。 `arg_list` 中的参数可以是形如 `_n` 的占位符，表示调用时实际传递给 `newCallable` 的第 `n` 个参数。

#### 使用placeholders名字
名字 `_n` 都定义在名为 `placeholders` 的命名空间中，它是 `std` 的子命名空间，调用时需要写成 `std::placeholders::_n` 。如果使用 `using` 声明，那么每个占位符都要声明一条，可以使用另一种形式的 `using` 语句：
```cpp
using namespace std::placeholders;
```
这个命名空间也定义在 `functional` 头文件中。

#### 绑定引用参数
`bind` 没有什么机制来获取引用参数，需要借助 `functional` 头文件中的 `ref` 和 `cref` 函数，如 `ref(obj)` 返回 `obj` 的引用； `cref` 返回 `const` 引用。

#### 向后兼容：参数绑定
老标准中还有 `bind1st` 和 `bind2nd` ，用来绑定第一个参数和第二个参数，显然 `bind` 要更强大，故这两个函数在C++11中已经被弃用。

## 再探迭代器
除了常见的迭代器，头文件 `iterator` 中还定义了一些迭代器类型：
- 插入迭代器：绑定到容器上，用来插入元素
- 流迭代器：绑定到输入或输出流上，用来遍历关联的IO流
- 反向迭代器：它们逆向移动，除了 `forward_list` 之外的所有容器都有反向迭代器
- 移动迭代器：它们可以移动而不是拷贝元素

### 插入迭代器
具有如下操作：
- `it = t` ：在指定的位置插入值为 `t` 的元素。
- `*it` 、 `++it` 、 `it++` ：它们都不做任何事情，只是返回 `it` 本身。

有三种插入迭代器：
- `back_inserter` ：创建一个使用 `push_back` 的迭代器
- `front_inserter` ：创建一个使用 `push_front` 的迭代器
- `inserter` ：创建一个使用 `insert` 的迭代器，它接受第二个参数，为一个指向插入位置的迭代器，元素插入到这个迭代器指向的元素之前

### iostream迭代器

#### istream_iterator操作
`istream_iterator` 使用 `>>` 运算符从输入流中读取数据，它支持如下的操作：
```cpp
istream_iterator<T> in(is);         // in将从is中读取T类型的值
istream_iterator<T> end;            // 默认初始化将获得尾后迭代器
in1 == in2;                         // in1和in2必须读取相同的类型。如果in1和in2都是尾后迭代器或者它们指向相同的流，则返回true
in1 != in2;                         // 相反的结果
*in;                                // 返回从流中读取的值
in->mem;                            // 相当于(*in).mem
++in;                               // 使用>>从流中读取下一个值，返回指向递增后的迭代器的引用
in++;                               // 使用>>从流中读取下一个值，返回旧值
```

#### istream_iterator允许使用懒惰求值
当把一个 `istream_iterator` 绑定到一个流时，标准库不需要立即读取流，它只保证直到第一次解引用迭代器时数据已经可用。

#### ostream_iterator操作
对于任何支持输出运算符 `<<` 的类型都可以定义 `ostream_iterator` ，它支持如下操作：
```cpp
ostream_iterator<T> out(os);        // out将类型为T的值写入输出流os中
ostream_iterator<T> out(os, d);     // 每次输出值以后都会输出d，d是一个C风格字符串
out = val;                          // 将val写入out。val需要与out的<<运算符支持的类型兼容
// 下面的运算符什么也不做，只是返回out
*out;
++out;
out++;
```
虽然以下的两种形式实际上是等价的：
```cpp
*out_iter++ = e;
out_iter = e;
```
但更推荐上面的形式，因为直观清晰，并且几乎适用于所有的迭代器类型。

### 反向迭代器

#### 反向迭代器需要递减运算符
因为需要逆向遍历，所以它们实际上用到递减运算符 `--` 。 `forward_list` 的迭代器并不支持递减操作，流迭代器也一样。

#### 反向迭代器和其他迭代器间的关系
`reverse_iterator` 具有成员函数 `base()` ，它返回指向当前反向迭代器指向元素下一个位置（顺向）的普通迭代器。

## 泛型算法结构
不同的泛型算法需要用到能力不同的迭代器，可以按照这些能力把它们分成五个**迭代器类别**：
| 类别 | 读 | 写 | 多遍扫描 | 递减 | 支持全部运算 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 输入迭代器 | o | | | | |
| 输出迭代器 | | o | | | |
| 前向迭代器 | o | o | o | | |
| 双向迭代器 | o | o | o | o | |
| 随机访问迭代器 | o | o | o | o | o |

### 5类迭代器
如果给算法传递了一个能力不足的迭代器，很多编译器并不会报错或警告。

#### 输入迭代器
它需要支持：
- 比较两个迭代器是否相等（`==` 和 `!=` ）
- 前置后置递增运算符（ `++` ）
- 解引用运算符（ `*` ）
- 读取元素的运算符（ `->` ）

它的递增可能导致其他迭代器失效，所以它不支持多遍扫描。

#### 输出迭代器
它需要支持：
- 前置后置递增运算符（ `++` ）
- 解引用运算符（ `*` ）

类似输入迭代器，也不支持多遍扫描。

#### 前向迭代器
支持多遍扫描，并且需要同时支持读写，它只要求前向移动。 `forward_list` 的迭代器就是前向迭代器。

#### 双向迭代器
需要支持递减运算符（ `--` ）进行反向移动。所有容器除了 `forward_list` 的迭代器都满足双向迭代器的标准。

#### 随机访问迭代器
提供在常量时间内访问任意元素的能力，除了双向迭代器的功能，它需要支持：
- 用于比较两个迭代器位置的关系运算符（ `<` 、 `<=` 、 `>` 、 `>=` ）
- 迭代器和整数的加减运算符（ `+` 、 `-` 、`+=` 、 `-=` ），用于移动迭代器
- 两个迭代器相减的运算符（ `-` ），用于计算两个迭代器之间的距离
- 下标运算符（ `[]` ），如 `iter[n]` 等价于 `*(iter + n)`

### 算法形参模式
大多数算法的参数都符合以下4种模式：
```cpp
alg(beg, end, other_args);
alg(beg, end, dest, other_args);
alg(beg, end, beg2, other_args);
alg(beg, end, beg2, end2, other_args);
```
这里的 `beg2` 表示第二个输入范围。

### 算法命名规范

#### 一些算法使用重载形式传递一个谓词
如 `sort` 可以接受第三个参数

#### _if版本的算法
像 `find` 这种接受一个元素值作为参数的算法，通常具有一个 `_if` 后缀版本，像 `find_if` 接受一个谓词作为参数。因为两个版本接受的参数数量相同，为了避免出现奇怪的歧义而没有使用重载。

#### 区分拷贝元素的版本和不拷贝的版本
默认情况下重排算法进行原地操作，这些算法有 `_copy` 后缀版本，它们把重排后的结果写入目的位置而不改变原序列：
```cpp
reverse(v.begin(), v.end());
reverse_copy(v.begin(), v.end(), v2.begin());
```
有的算法同时有 `_if` 版本和 `_copy` 版本，如：
```cpp
remove_copy_if(v.begin(), v.end(), v2.begin(), pred);
```

## 特定容器算法
`list` 的迭代器是双向迭代器， `forward_list`的迭代器是前向迭代器。算法 `sort` 要求随机访问迭代器，故无法作用于它们。还有一些算法的通用版本对于它们来说性能不佳。为此，它们以成员函数的形式定义了一些算法的独有版本。这些算法都返回void，它们分别是：
```cpp
lst.merge(lst2);            // 将lst2合并到lst中。lst和lst2必须是有序的。lst2将变为空。使用<运算符比较元素
lst.merge(lst2, comp);      // 使用comp代替<运算符
lst.remove(val);            // 调用erase删除与val相等的元素
lst.remove_if(pred);        // 调用erase删除使pred返回true的元素
lst.reverse();              // 反转lst中的元素顺序
lst.sort();                 // 对lst中的元素进行排序，使用<运算符比较元素
lst.sort(comp);             // 使用comp代替<运算符
lst.unique();               // 调用erase删除重复的元素，使用==运算符比较元素
lst.unique(pred);           // 使用pred代替==运算符
```

#### splice成员
`splice` 算法是链表特有的，对于 `lst.splice()` ，它可以接受如下参数：
- `(p, lst2)` ：如果 `lst` 是 `list` ，则 `p` 需要指向 `lst` 中的一个元素（感觉尾后迭代器也可以），它会把 `lst2` 中的元素插入到 `lst` 中 `p` 所指向的元素之前；如果 `lst` 是 `forward_list` ，则 `p` 需要指向 `lst` 中的一个元素或首前迭代器，它会把 `lst2` 中的元素插入到 `p` 指向的位置之后。 `lst2`的类型必须和 `lst` 的类型相同，并且两者不能是同一个链表。
- `(p, lst2, p2)` ：类似，但 `p2` 指向 `lst2` 中的一个元素，仅把该元素移动到 `lst` 。 `lst2` 和 `lst` 可以是同一个链表。
- `(p, lst2, b, e)` ：类似，但 `b` 和 `e` 指定了 `lst2` 中的一个范围，把这个范围内的元素移动到 `lst` 。 `lst2` 和 `lst` 可以是同一个链表，但 `p` 不能指向给定区间中元素。

<br><br>

# 关联容器
关联容器支持高效的关键字查找和访问，有以下的类型：
- 按关键字有序保存元素：
    - `map` ：关联数组；保存关键字-值对
    - `set` ：关键字即值，即只保存关键字的容器
    - `multimap` ：关键字可以重复出现的 `map`
    - `multiset` ：关键字可以重复出现的 `set`
- 无序集合：
    - `unordered_map` ：使用哈希函数组织的 `map`
    - `unordered_set` ：使用哈希函数组织的 `set`
    - `unordered_multimap` ：使用哈希函数组织的 `multimap`
    - `unordered_multiset` ：使用哈希函数组织的 `multiset`

## 使用关联容器
`map` 常被称为**关联数组**。

## 关联容器概述
关联容器都支持[普通容器操作](#所有容器类型的共同操作)。关联容器的迭代器都是双向的。

### 定义关联容器
可以默认初始化 `map` 和 `set` 。在C++11中，还可以使用列表初始化：
```cpp
set<string> exclude = {"The", "But", "And", "Or", "An", "A",
                       "the", "but", "and", "or", "an", "a"};
map<string, string> authors = {{"Joyce", "James"}, {"Austen", "Jane"},
                               {"Dickens", "Charles"}};
```

### 初始化multimap和multiset
`map` 和 `set` 都要求关键字是唯一的，而 `multimap` 和 `multiset` 则允许关键字重复。

### 关键字类型的要求
对于有序容器 `map` 、 `set` 、 `multimap` 和 `multiset` ，标准库使用运算符 `<` 来比较两个关键字，所以它必须支持这个运算符。或者也可以提供一个自定义比较操作。

#### 有序容器的关键字类型
比较操作必须定义一个**严格弱序**，即该函数必须具备如下性质：
- 不能出现 `a < b && b < a` 为真
- 如果 `a < b && b < c` 为真，则 `a < c` 也为真
- 如果 `a < b` 为假且 `b < a` 为假，则 `a` 和 `b` 相等

#### 使用关键字类型的比较函数
如果需要给关联容器提供自定义的比较操作，可以在尖括号中传入该比较操作的类型，然后把对应的比较操作传递给构造函数，如：
```cpp
multiSet<string, decltype(compare)*> authors(compare);
```

### pair类型
标准库类型 `pair` 定义在头文件 `utility` 中，其上有如下操作：
```cpp
pair<T1, T2> p;             // p是一个pair，它的两个成员分别是T1和T2类型，都进行值初始化
pair<T1, T2> p(v1, v2);     // p的两个成员分别是v1和v2的拷贝
pair<T1, T2> p = {v1, v2};  // 同上
make_pair(v1, v2);          // 返回一个用v1和v2初始化的pair，具体类型通过v1和v2的类型推断
p.first;                    // 返回p的第一个成员
p.second;                   // 返回p的第二个成员
p1 relop p2;                // 字典序比较，利用元素的 < 运算符
p1 == p2;                   // 相等性比较，利用元素的 == 运算符
p1 != p2;                   // 不等性比较，利用元素的 == 运算符
```

#### 创建pair对象的函数
C++11以后，返回一个 `pair` 可以通过列表初始化来实现：
```cpp
pair<string, int> process(vector<string> &v)
{
    if (!v.empty())
        return {v.back(), v.back().size()};
    else
        return pair<string, int>();
}
```
在更早的C++中则必须显式构造一个 `pair` 。

## 关联容器操作
除了[共有的类型别名](#所有容器类型的共同操作)外，关联容器还有几个额外的类型别名：
- `key_type` ：关键字类型
- `mapped_type` ：每个关键字关联的类型，只适用于 `map`
- `value_type` ：对于 `set` ，它和 `key_type` 相同；对于 `map` ，它是 `pair<const key_type, mapped_type>` 。

### 关联容器迭代器
解引用迭代器获得的是一个 `value_type` 类型的值。通过 `map` 的迭代器可以修改 `second` 成员，但不能修改 `first` 成员，因为 `first` 是 `const` 的。

#### set的迭代器是const的
`set` 只有 `const` 迭代器，不允许通过迭代器修改元素的值。

#### 关联容器和算法
通常不会对关联容器使用泛型算法。实际编程中，如果真的对关联容器使用泛型算法，常常把它当做一个源序列，或者绑定到一个插入迭代器上作为目的位置。

### 添加元素

#### 向map添加元素
关联容器的 `insert` 相关操作有：
```cpp
// v是value_type类型的对象；args用来构造一个元素
// 对于multimap和multiset，总会执行插入操作。返回指向新元素的迭代器
// 对于map和set，只有关键字不存在时才会插入。返回pair，包含指向具有对应关键字的元素的迭代器和表示是否插入成功的bool值
c.insert(v);
c.emplace(args);

// 类似，但迭代器p指出从哪里开始搜索新元素应该存储的位置（不懂）
// 返回指向具有对应关键字的元素的迭代器
c.insert(p, v);
c.emplace(p, args);

// b和e是一对迭代器，表示一个value_type类型的范围；il是一个初始化列表
// 函数返回void
// 对于map和set，只会插入范围中关键字仍不存在的元素；对于multimap和multiset，总是插入范围中所有元素
c.insert(b, e);
c.insert(il);
```

### 删除元素
从关联容器删除元素的操作有：
```cpp
// 从c中删除所有关键字为k的元素，返回表示删除元素数量的size_type值
c.erase(k);

// 从c中删除迭代器p指向的元素，迭代器p必须实际指向某个元素。返回指向p之后位置的迭代器
c.erase(p);

// 删除迭代器对b和e指定范围内的元素，返回e
c.erase(b, e);
```

### map的下标操作
- `c[k]` ：返回关键字为 `k` 的元素的引用。如果 `k` 不在 `c` 中，会插入一个具有关键字 `k` 的元素，其值进行值初始化。
- `c.at(k)` ：返回关键字为 `k` 的元素的引用。如果 `k` 不在 `c` 中，会抛出一个 `out_of_range` 异常。

这两种操作仅适用于非 `const` 的 `map` 或 `unordered_map` 。

### 访问元素
在一个关联容器中查找元素的操作：
```cpp
// lower_bound和upper_bound不适用于无序容器

// 返回指向首个关键字为k的元素的迭代器，如果该元素不存在则返回尾后迭代器
c.find(k);

// 返回关键字等于k的元素的数量
c.count(k);

// 返回指向首个关键字不小于k的元素的迭代器
c.lower_bound(k);

// 返回指向首个关键字大于k的元素的迭代器
c.upper_bound(k);

// 返回表示关键字等于k的元素范围的迭代器对形成的pair，如果范围为空则两个迭代器都是尾后迭代器
c.equal_range(k);
```
在 `multimap` 和 `multiset` 中，找到关键字为 `k` 的全部元素比较麻烦，可以考虑使用 `equal_range` 。

## 无序容器
C++11定义了4个无序关联容器，它们不使用比较运算符来组织元素，而是使用哈希函数和 `==` 运算符。

#### 管理桶
无序容器提供了一组管理桶的函数，允许我们查询容器的状态以及在必要时强制容器进行重组。

桶接口：
```cpp
// 正在使用桶的数目
c.bucket_count();

// 容器能容纳的最多桶的数目
c.max_bucket_count();

// 第n个桶中元素的数目
c.bucket_size(n);

// 关键字为k的元素在哪个桶中
c.bucket(k);
```
桶迭代：
```cpp
// 桶中元素的迭代器类型
local_iterator;

// 桶迭代器的const版本
const_local_iterator;

// 桶n的首元素迭代器和尾后迭代器
c.begin(n), c.end(n);

// const版本
c.cbegin(n), c.cend(n);
```
哈希策略：
```cpp
// 每个桶的平均元素数目，返回float值
c.load_factor();

// c保持的桶平均数目的上限，返回float值。需要时c会并添加桶
c.max_load_factor();

// 重组存储，使得c的桶数目满足，1)不小于n，2)桶平均元素数目不超过上限
c.rehash(n);

// 重组存储，使得c至少能容纳n个元素而不需要经过重组
c.reserve(n);
```

#### 无序容器对关键字类型的要求
无序容器需要使用 `==` 和 `hash<key_type>` 。标准库为内置类型（包括指针）以及一些标准库类型（包括 `string` 和智能指针）提供了 `hash` 模板。因此它们可以直接用于无序容器。

对于自定义类类型，需要自行提供 `hash` 对象：
```cpp
size_t hasher(const Sales_data &sd)
{
    return hash<string>()(sd.isbn());
}
```
然后如下定义无序容器：
```cpp
unordered_set<Sales_data, decltype(hasher)*> sdset(42, hasher);
```

如果类本身没有定义 `==` 运算符，也可以提供一个自定义的比较操作：
```cpp
bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}
```
然后如下定义无序容器：
```cpp
unordered_set<Sales_data, decltype(hasher)*, decltype(eqOp)*> sdset(42, hasher, eqOp);
```

<br><br>

# 动态内存

## 动态内存与智能指针
动态内存的管理是通过一对运算符 `new` 和 `delete` 来实现的，但它们的使用很容易出现问题。C++11引入了两种智能指针，分别是 `shared_ptr` 和 `unique_ptr` ，标准库还定义了一个名为 `weak_ptr` 的伴随类。它们都定义在头文件 `memory` 中。

### shared_ptr
`shared_ptr` 和 `unique_ptr` 都支持的操作有：
```cpp
// 定义空智能指针，可以指向类型为T的对象
shared_ptr<T> sp;
unique_ptr<T> up;

// 将p用作一个条件判断，若p指向一个对象，则为true
p;

// 解引用p，获取它指向的对象
*p;

// 等价于(*p).mem
p->mem;

// 返回p中保存的指针
p.get();

// 交换p和q中的指针
swap(p, q);
p.swap(q);
```
`shared_ptr` 还有一些独有的操作：
```cpp
// 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化该对象
make_shared<T>(args);

// p是shared_ptr q的拷贝，会递增q中的引用计数，q中的指针必须能转换为类型T*
shared_ptr<T> p(q);

// p和q都是shared_ptr，保存的指针能相互转换，递减p原先的引用计数，递增q的引用计数
p = q;

// 返回与p共享对象的智能指针数量；可能很慢，主要用于调试
p.use_count();

// 若p.use_count()为1，则返回true；否则返回false
p.unique();
```

#### make_shared函数
最安全的分配和使用动态内存的方法是调用一个名为 `make_shared` 的标准库函数，它也定义在头文件 `memory` 中。它接受参数并把它们传递给对应的构造函数，如果不传参则进行值初始化。

### 直接管理内存

#### 使用new动态分配和初始化对象
```cpp
int *pi = new int;
int *pi = new int();
int *pi = new int(1024);
string *ps = new string(10, '9');
```
在C++11中，可以让编译器自行推断类型：
```cpp
auto p1 = new auto(obj);
```
如果 `obj` 是 `int` ，则 `p1` 的类型是 `int*` 。也可以使用列表初始化，然而列表中只能有一个值：
```cpp
// 正确
auto p2 = new auto{a};

// 错误
auto p2 = new auto{a, b, c};
```

#### 动态分配const对象
可以用 `new` 分配 `const` 对象：
```cpp
const int *pci = new const int(1024);
```
显然这样的分配必须进行初始化。

#### 内存耗尽
当 `new` 由于内存不足无法完成分配，它会抛出 `bad_alloc` 异常。也可以阻止它抛出异常，令其在分配失败时返回空指针：
```cpp
int *p = new (nothrow) int;
```
这种形式的 `new` 被称作**定位new表达式**。实际上相当于把标准库定义的名为 `nothrow` 对象传递给了 `new` ，告诉它不能抛出异常。

`bad_alloc` 和 `nothrow` 都定义在头文件 `new` 中。

#### 释放动态内存
```cpp
delete p;
```

#### 指针值和delete
释放一块不是通过 `new` 分配的内存或者多次释放同一块内存都是未定义的行为。 `const` 对象也可以通过 `delete` 释放。

#### delete之后重置指针值
`delete` 一个指针以后，很多机器上指针的值仍被保留，它成为**空悬指针**，即指向一块曾经保存数据对象但现在已经无效的内存的指针。为了避免这种情况，可以在 `delete` 之后把指针置为 `nullptr` 。

### shared_ptr和new结合使用
`shared_ptr` 有一个接受指针参数的 `explicit` 构造函数，可以用 `new` 返回的指针来初始化 `shared_ptr` ：
```cpp
shared_ptr<int> p1(new int(42));
```
智能指针默认使用 `delete` 来释放内存，所以上面传给构造函数的指针必须是通过动态分配的内存。如果不是，那么需要自行定义 `delete` 行为。

实际上，有一些其他的定义和改变 `shared_ptr` 的方法：
```cpp
// p管理内置指针q所指向的对象；q必须指向动态分配的内存，且能够转换为T*
shared_ptr<T> p(q);

// p从unique_ptr u那里接管了对象的所有权；将u置为空
shared_ptr<T> p(u);

// p接管了内置指针q所指向的对象的所有权；q必须能转换为T*，使用可调用对象d代替delete
shared_ptr<T> p(q, d);

// p是shared_ptr p2的拷贝，将使用可调用对象d代替delete
shared_ptr<T> p(p2, d);

// 如果p是唯一指向其对象的shared_ptr，则释放该对象。把p置为空
p.reset();

// 同上，并令p指向内置指针q所指向的对象
p.reset(q);

// 同上，并使用可调用对象d代替delete
p.reset(q, d);
```

#### 不要混合使用普通指针和智能指针
由于智能指针没有办法知道是否有普通指针在与它共享对象，可能会把一块仍需要使用的内存释放掉，如：
```cpp
// 函数接受一个shared_ptr
void process(shared_ptr<int> ptr)
{
    // 使用ptr
} // ptr离开作用域，内存被释放

int *x(new int(1024));
process(shared_ptr<int>(x));
int j = *x;     // 此时x是一个空悬指针
```

#### 不要使用get初始化另一个智能指针或为智能指针赋值
如果通过 `get` 获取了一个智能指针的内置指针，并用它初始化另一个智能指针，程序实际上没办法正确跟踪引用计数，当其中一个智能指针被销毁时可能会释放内存。

#### 其他shared_ptr操作
有时候多个 `shared_ptr` 会指向同一个对象，需要改变底层对象可能需要同步，可以现在副本上进行操作：
```cpp
if (!p.unique())
    p.reset(new string(*p));
// ...
```

### 智能指针和异常
如果某个操作抛出异常，那么 `try` 立即停止执行，此时需要释放前面的动态分配内存，可以在 `catch` 块中完成，但比较繁琐。更好的方法是使用智能指针，它们会在析构时自动释放内存。

#### 智能指针和哑类
有的类，特别是同时为C和C++设计的类，可能并不具有析构函数，而是需要调用某些特定函数来完成资源释放。则默认情况下调用 `delete` 就会造成资源泄漏。可以使用 `shared_ptr` 结合自定义的删除器来解决这个问题。

#### 使用我们自己的释放操作
注意 `shared_ptr` 传递删除器时不需要在尖括号中指定删除器的类型。

### unique_ptr
某个时刻只能有一个 `unique_ptr` 指向一个对象，当 `unique_ptr` 被销毁时，它所指向的对象也会被销毁。除了和 `shared_ptr` [公共的操作](#shared_ptr)以外，`unique_ptr` 还有一些独有的操作：
```cpp
// 空unique_ptr，可以指向类型为T的对象
// u1将使用delete来释放它的指针，u2将使用类型为D的可调用对象来释放它的指针
unique_ptr<T> u1;
unique_ptr<T, D> u2;

// 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete
unique_ptr<T, D> u(d);

// 释放u所指向的对象，将u置为空
u = nullptr;

// u放弃对其指针的控制权，返回指针，并将u置为空
u.release();

// 释放u指向的对象，将u置为空
u.reset();

// 释放u指向的对象，令u指向内置指针p指向的对象
u.reset(p);

// 显式将u置为空
u.reset(nullptr);
```
定义一个 `unique_ptr` 如：
```cpp
unique_ptr<int> up(new int(42));
```
不能拷贝或赋值 `unique_ptr` ，因为它是独占的。但是可以通过 `release()` 解绑指针后绑定到别的 `unique_ptr` 上。也可以通过 `release()` 拿到指针以后自行管理这块内存，但是后续需要 `delete` 它。

#### 向后兼容：auto_ptr
早期的标准库有一个名为 `auto_ptr` 的类，它就有 `unique_ptr` 的一部分功能。不能在容器中保存 `auto_ptr` 也不能在函数中返回 `auto_ptr` 。在C++11中它仍旧是标准库的偶一部分，但应该考虑使用 `unique_ptr` 。

#### 向unique_ptr传递删除器
`unique_ptr` 的删除器类型需要在尖括号中指定，即创建 `unique_ptr` 对象时需要指定删除器的类型，如：
```cpp
unique_ptr<objT, delT> p (new objT, fcn);
```

### weak_ptr
它是一种不控制所指向对象生存期的智能指针，指向一个 `shared_ptr` 管理的对象。把它绑定到一个 `shared_ptr` 上不会改变 `shared_ptr` 的引用计数。当没有 `shared_ptr` 指向所管理的对象时，不管有没有 `weak_ptr` 指向它，对象都会被释放。它支持以下操作：
```cpp
// 空weak_ptr可以指向类型为T的对象
weak_ptr<T> w;

// 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型
weak_ptr<T> w(sp);

// p可以是一个shared_ptr或另一个weak_ptr。赋值后，w指向p所指向的对象
w = p;

// 将w置为空
w.reset();

// 返回指向w所指向对象的shared_ptr数目
w.use_count();

// 若w.use_count()为0，则返回true；否则返回false
w.expired();

// 如果expired为true，返回一个空shared_ptr；否则返回一个指向w所指向对象的shared_ptr
w.lock();
```
因为 `weak_ptr` 指向的对象可以已经被销毁，所以每次使用该对象时应该调用 `lock` 并检查是否是空的 `shared_ptr` ：
```cpp
// 这里把shared_ptr隐式转换为bool
if (shared_ptr<int> np = wp.lock())
{
    // ...
}
```

## 动态数组

### new和数组
可以用 `new` 来分配一个数组：
```cpp
// 分配10个int的数组，数组大小需要是整型，不必是常量
int *pia = new int[10];
```
`new` 实际上得到一个对应大小的内存块，然后返回相应元素类型的指针（如 `int*`），而不是一个数组对象。这导致不能对上述方式分配的数组使用 `begin()` 和 `end()` ，也不能用范围 `for` 来遍历它。

#### 初始化动态分配对象的数组
可以在分配内存的时候进行初始化：
```cpp
// 默认初始化
int *pia = new int[10];

// 值初始化
int *pia = new int[10]();

// 默认初始化
string *psa = new string[10];

// 值初始化
string *psa = new string[10]();

// 列表初始化
int *pia = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```
最后的列表初始化中，如果给出的初始值数目超过了数组的大小， `new` 会抛出 `bad_array_new_length` 异常，它也定义在头文件 `new` 中。

#### 动态分配一个空数组是合法的
```cpp
int *p = new int[0];
```
此时 `new` 一个合法的非空指针，它保证不同于 `new` 返回的任何其他指针。不能解引用这个指针，因为它实际上没有指向任何对象。

#### 释放动态数组
需要使用特殊形式的 `delete` ：
```cpp
delete [] p;
```
如果对一个动态数组使用了普通的 `delete` 或者对一个非动态数组使用了 `delete []` ，则行为是未定义的。即使使用了类型别名来获取动态数组，也需要使用 `delete []` ：
```cpp
typedef int arrT[42];
int *p = new arrT;
delete [] p;
```

#### 智能数组和动态数组
标准库提供了一个可以管理 `new` 分配的动态数组的 `unique_ptr` 版本：
```cpp
unique_ptr<int[]> up(new int[10]);
up.release();
```
这样，当 `up` 需要销毁这一块内存的时候，它会使用 `delete[]` 而不是 `delete` 。当使用这样的 `unique_ptr` 时，由于它实际上绑定到一个数组类型上，不能使用点运算符和箭头运算符。可以使用下标运算符来访问元素。

而 `shared_ptr` 则不能直接支持动态数组，需要自行定义删除器：
```cpp
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
```

### allocator类
`new` 把内存分配和对象的构造组合在了一起，而 `delete` 把对象析构和内存释放组合在了一起，这使得灵活性受限。如果我们需要动态数组，那么就会一次性分配并初始化所有元素，很多时候对象初始化后又被赋予新的值，这样就产生了不必要的开销。并且，没有默认构造函数的类就不能分配动态数组。

#### allocator类
它定义在头文件 `memory` 中，提供分配原始内存而推迟构造对象的功能。它支持如下操作：
```cpp
// 定义一个名为a的allocator对象，它可以为类型为T的对象分配内存
allocator<T> a;

// 分配一段原始的、未构造的内存，能容纳n个类型为T的对象
a.allocate(n);

// p是一个类型T*的指针，指向一块原始内存
// args被传递给T的构造函数，用来在p指向的内存中构造对象
a.construct(p, args);

// p是一个类型T*的指针，函数对其指向的对象进行析构
a.destroy(p);

// 释放从T*指针p中地址开始的内存，这块内存保存了n个T类型的对象
// p必须是一个先前由allocate()返回的指针，且n必须是创建p时要求的大小
// 在调用它之前，必须对这块内存中的每个元素调用destroy()
a.deallocate(p, n);
```

#### 拷贝和填充未初始化内存的算法
`allocator` 类定义了两个伴随算法，它们也定义在头文件 `memory` 中：
```cpp
// b和e是一对迭代器，指出源数据范围
// b2是一个指针，指向未构造的原始内存，内存需要足够大
// 函数依次使用源数据范围的元素在b2处构造对象
uninitialized_copy(b, e, b2);

// b是一个迭代器，指出源数据位置；n是要拷贝的元素数目
// b2是一个指针，指向未构造的原始内存，内存需要足够大
// 函数依次使用源数据在b2处构造n个对象
uninitialized_copy_n(b, n, b2);

// b和e是一对指针，指定原始内存范围
// 函数在该范围内使用值t构造对象
uninitialized_fill(b, e, t);

// b是一个指针，指定原始内存位置；n是要填充的元素数目
// 函数在该范围内使用值t构造对象
uninitialized_fill_n(b, n, t);
```

<br><br>

# 拷贝控制

## 拷贝、赋值和销毁

### 拷贝构造函数
第一个参数是自身类类型的引用，如果有其他参数则它们都有默认值。第一个参数允许不是 `const` 的引用，但通常是 `const` 的。它不应该是 `explicit` 的。

#### 合成拷贝构造函数
如果一个类没有定义自己的拷贝构造函数，那么编译器会为它定义一个。默认构造函数在有其他构造函数时不会被合成出来，但拷贝构造函数则仍会被合成出来。

#### 拷贝初始化
拷贝初始化在以下的情况下会发生：
- 使用 `=` 定义变量
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

对于标准库的容器来说，调用 `insert` 或 `push_back` 时也会发生拷贝初始化，而调用 `emplace` 则发生直接初始化。

#### 参数和返回值
由于初始化非引用类型参数时会调用拷贝构造函数进行拷贝初始化，所以拷贝构造函数的参数需要是引用类型，不然就会出现无限递归的情况。

#### 编译器可以绕过拷贝构造函数
像这样的代码：
```cpp
string null_book = "9-999-99999-9";
```
编译器可以改写成：
```cpp
string null_book("9-999-99999-9");
```
个人理解：如果有一个接受C风格字符串的构造函数和一个接受 `const string&` 的构造函数，那么编译器有权选择前者而绕过拷贝构造函数的调用。

### 拷贝赋值运算符
与拷贝构造函数一样，如果类没有定义自己的拷贝赋值运算符，编译器会为它合成一个。

#### 重载赋值运算符
标准库通常要求，保存在容器中的类型要有赋值运算符。

#### 合成拷贝赋值运算符
合成拷贝赋值运算符会逐个成员进行赋值。

### 析构函数
析构函数并不直接销毁成员，成员的销毁是在析构函数体后隐含的析构阶段销毁的。

#### 什么时候会调用析构函数
- 变量离开作用域时
- 当对象被销毁时，成员被销毁
- 容器被销毁时，其元素被销毁
- 使用 `delete` 释放动态分配的对象时
- 临时对象在创建它的完整表达式结束时被销毁

#### 合成析构函数
如果一个类没有定义自己的析构函数，编译器会为它定义一个。如果合成析构函数不是用来阻止该类型对象被销毁，那么函数体就为空。

### 三/五法则
- 需要析构函数的类也需要拷贝和赋值操作
- 需要拷贝操作的类也需要赋值操作，反之亦然

### 使用=default
C++11允许如下语法：
```cpp
Sales_data() = default;
```
这通知编译器为 `Sales_data` 合成默认构造函数。这样的构造函数是隐式 `inline` 的，如果不希望它是内联的，把定义放在类外部即可。只有具有合成版本的构造函数可以使用 `=default` 。

### 阻止拷贝

#### 定义删除的函数
C++11新增如下语法：
```cpp
Sales_data(const Sales_data&) = delete;
```
这告诉编译器定义一个删除的拷贝构造函数，从而防止编译器自行合成一个可以使用的版本，这样就无法进行拷贝。由于该语法旨在禁止此构造函数的调用， `delete` 必须在第一次声明时就指出。（相对的， `=default` 只关乎构造函数的具体实现，只有在编译器需要函数定义时才需要，则可以不在声明时指出。）

与 `default` 不同，可以把任何函数定义为 `delete` 。

#### 析构函数不能是删除的成员
如果析构函数是删除的，这个对象将无法被销毁。如果某个类把定义为删除的，编译器将不允许定义该类型的变量或创建该类型的临时对象。如果某个类有这样的成员也是一样的。

然而，可以动态分配这样的对象，并且不能释放它们。

#### 合成的拷贝控制成员可能是删除的
编译器为某些类合成的函数成员可能是删除的：
- 析构函数：
    - 某成员的析构函数是删除的或不可访问的
- 拷贝构造函数：
    - 某成员的拷贝构造函数是删除的或不可访问的
    - 某成员的析构函数是删除的或不可访问的
    - 类定义了移动构造函数
    - 类定义了移动赋值运算符
- 拷贝赋值运算符：
    - 某成员的拷贝赋值运算符是删除的或不可访问的
    - 有 `const` 成员
    - 有引用成员
    - 类定义了移动构造函数
    - 类定义了移动赋值运算符
- 默认构造函数：
    - 某成员的析构函数是删除的或不可访问的
    - 有 `const` 成员，没有类内初始化器，它也没有显式定义的默认构造函数
    - 有引用成员，没有类内初始化器

本质上它们意味着：如果类有数据成员不能默认构造、拷贝、赋值或销毁，那么编译器就不会合成这些操作。而成员析构函数的缺失会导致合成构造函数的删除，这是为了防止无意中创建出不可销毁的对象。

#### private拷贝控制
在C++11之前，类通过把拷贝构造函数和拷贝赋值运算符声明为 `private` 来阻止拷贝。这使得无法从外部进行拷贝，这会导致编译错误。

然而友元可以访问 `private` 成员。为此，可以仅声明不定义这些函数，当友元访问这些函数时会导致链接错误。

## 拷贝控制和资源管理

### 行为像值的类

#### 类值拷贝赋值运算符
通常这样的类有动态分配的成员，进行拷贝时需要销毁左侧的对象，为了防止自赋值带来的错误，通常把右侧对象先拷贝到一个局部临时对象，然后再销毁左侧对象，最后再把临时对象赋值给左侧对象。

## 交换操作

#### swap函数应该调用swap，而不是std::swap
标准库定义了一个 `swap` ，通常它只是创建一个临时对象完成整个类对象的交换，比较低效。类可以定义自己的 `swap` ，这样就不会调用标准库的版本。在这样的函数里面，通常可以简单地对需要交换的成员调用 `swap` 。如：
```cpp
class HasPtr
{
    friend void swap(HasPtr&, HasPtr&);
    // ...
};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```
注意这里的定义法，使用了 `using std::swap` ，这样的语法不会隐藏类自己的 `swap` ，如果类有自己的 `swap` ，那么它会被调用；如果没有，那么就会调用 `std::swap` 。而如果显式使用 `std::swap(lhs.ps, rhs.ps)` ，那么就调用的是 `std::swap` 。

#### 在赋值运算符中使用swap
定义了 `swap` 和拷贝构造函数的类可以如下定义赋值运算符：
```cpp
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```
注意这里参数不是引用形式，在传参时就进行了临时对象的构建。它的行为和之前提到的原则一样，自动处理了自赋值并且天然是异常安全的。

## 对象移动
C++11引入了对象的移动特性，从而可以避免拷贝操作来优化性能。在C++11之前，没有直接的方法来移动对象，基本总是需要执行拷贝操作。由于移动特性的引入，新标准中容器保存的类可以是不可拷贝的类型，只要支持移动操作也可以。

标准库容器、 `string` 和 `shared_ptr` 都支持拷贝和移动操作，而IO类和 `unique_ptr` 只支持移动操作。

### 右值引用
C++11引入了右值引用来支持移动操作，它指的是必须绑定到右值的引用，通过 `&&` 而不是 `&` 来表示右值引用。实际上，它只能绑定到一个将要销毁的对象上，此时该对象没有其他的用户，则可以随意地使用。

#### 变量是左值
以下代码会遇到问题：
```cpp
int &&rr1 = 42;                 // 正确：字面常量是右值
int &&rr2 = rr1;                // 错误：rr1是左值
```
由于变量表达式是左值，所以不能把 `rr2` 绑定到 `rr1` 上，即使 `rr1` 本身就是一个右值引用。

#### 标准库move函数
C++11中，标准库在头文件 `utility` 中定义了一个 `move` 函数，用来把左值转换为右值引用。如：
```cpp
int &&rr3 = std::move(rr1);     // 正确
```
需要注意的是，使用 `move` 就意味着告诉编译器，除了对 `rr1` 赋值或销毁它外，不会再使用它。另外，应该指明 `std::move` 而不是使用 `using` 声明，这可以避免意外的名字冲突。

### 移动构造函数和移动赋值运算符
移动构造函数的形式大致如下：
```cpp
StrVec::StrVec(StrVec &&s) noexcept
    : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    s.elements = s.first_free = s.cap = nullptr;
}
```

#### 移动操作、标准库容器和异常
通常移动构造函数只是“窃取”资源而不需要分配新的，所以不会抛出异常，应该声明为 `noexcept` 来防止标准库在进行移动操作时处理一些额外的工作。它也是C++11引入的关键字，必须在声明和定义时都使用。（不抛出异常的移动构造函数和移动赋值运算符**必须**标记为 `noexcept` ）

实际上，像 `vector` 这样的容器，为了保证异常安全，必须考虑是否使用移动构造函数。因为在重新分配内存时，如果对部分元素进行了移动而抛出了异常，此时容器内处于一个不正确的状态，则不是异常安全的。所以除非能保证移动操作不会抛出异常，否则它会采用拷贝操作。

#### 移动赋值运算符
移动赋值运算符的形式大致如下：
```cpp
StrVec& StrVec::operator=(StrVec &&rhs) noexcept
{
    if (this != &rhs)
    {
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```
这里同样处理了自赋值的问题，通过检查 `this` 和 `rhs` 是否相等来实现。

#### 合成的移动操作
只有当类没有定义任何自己版本的拷贝控制成员，并且类的每个非 `static` 数据成员都可以移动时，编译器才会为它合成移动构造函数和移动赋值运算符。（内置类型成员可以移动，类类型成员如果有自己的移动操作则也可以移动）

移动操作永远不会隐式定义为删除的函数。只有当使用 `= default` 显式要求编译器生成移动操作时且编译器无法移动所有成员时，才会合成一个删除的移动操作。在这些情况下会使得移动操作成为删除的函数：
- 移动构造函数与移动赋值运算符：
    - 类成员定义了拷贝构造函数，未定义移动构造函数
    - 类成员未定义拷贝构造函数和移动构造函数，但无法合成移动构造函数
    - 类成员的移动构造函数是删除的或不可访问的
- 移动构造函数：
    - 类自身的析构函数是删除的或不可访问的
- 移动赋值运算符：
    - 类成员是 `const` 或是引用类型

定义移动操作会导致合成拷贝操作定义为删除的函数。

#### 移动右值，拷贝左值
当传递左值时，会调用拷贝构造函数；当传递右值时，会调用移动构造函数。

#### 拷贝并交换赋值运算符和移动操作
参考如下的类：
```cpp
class HasPtr
{
public:
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = 0; }
    HasPtr& operator=(HasPtr rhs) { swap(*this, rhs); return *this; }
    // ...
};
```
这里的 `operator=` 实际上同时充当了拷贝赋值运算符和移动赋值运算符的角色。当传递一个左值的时候，调用拷贝构造函数来构造形参；当传递一个右值的时候，调用移动构造函数来构造形参。进入函数体以后都使用 `swap` 来交换资源。

#### 建议：更新三/五法则
实际上应该把拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数这五个成员看做一个整体，一旦定义其中一个成员，就应该定义所有五个操作。

#### 移动迭代器
C++11定义了一种**移动迭代器**适配器，它通过改变给定迭代器的解引用操作来适配该迭代器。不同于其他迭代器解引用返回一个左值，移动迭代器解引用返回一个右值引用。可以通过标准库的 `make_move_iterator` 来创建一个移动迭代器。可以如下使用：
```cpp
auto it = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), dest);
```
标准库不保证哪些算法适用移动迭代器。只有当确保对一个对象不再使用时才应该对它进行移动操作。

### 右值引用和成员函数
除了构造函数，其他函数也可以定义右值引用的重载版本，如标准库的 `push_back` ：
```cpp
void push_back(const X&);
void push_back(X&&);
```
通常定义以上两种版本，因为移动操作往往改变源对象，所以 `const X&&` 版本没有什么意义；因为这样的函数一般不应该修改传入的左值，所以 `X&` 版本也没有什么意义。

参考一个具体的例子：
```cpp
class StrVec
{
public:
    void push_back(const std::string &s) 
    { 
        chk_n_alloc(); 
        alloc.construct(first_free++, s); 
    }
    void push_back(std::string &&s) 
    { 
        chk_n_alloc(); 
        alloc.construct(first_free++, std::move(s)); 
    }
    // ...
};
```
注意这里的 `std::move` ，即使 `s` 已经是右值引用类型的形参它也是必须的，参考[上文](#变量是左值)。

#### 右值和左值引用成员函数
在旧标准中，右值的使用方式可以很奇怪：
```cpp
string s1 = "a value", s2 = "another";
s1 + s2 = "wow!";
```
这调用了临时对象的赋值运算符，在旧标准中无法阻止这样的操作。

然而C++11中引入了引用限定符 `&` 和 `&&` ，它们限定调用该函数传递的 `this` 指针指向的对象是左值还是右值。如：
```cpp
class Foo
{
public:
    Foo &operator=(const Foo&) &;               // 只能通过左值调用
}
```
它们只能用于非 `static` 成员函数，并且必须同时用于声明和定义。如果和 `const` 一起使用，需要注意它们的顺序：
```cpp
class Foo
{
public:
    Foo &operator=(const Foo&) & const;         // 错误
    Foo &operator=(const Foo&) const &;         // 正确
}
```

#### 重载和引用函数
和 `const` 一样，引用限定符实际上是在控制参数 `this` 指针的类型，所以同样可以区分重载版本。然而，如果有一组成员函数具有相同的名字和参数列表，只要其中有一个带了引用限定符，其他的函数也必须带引用限定符。
