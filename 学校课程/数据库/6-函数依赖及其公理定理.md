# 基本概念

## 数据依赖
关系的属性在语义上的依赖关系，比如姓名依赖于学号。

## 函数依赖
设有属性集 $U$ ， $R(U)$ 是 $U$ 上的一个关系模式， $X,Y \subseteq U$ 。<br>
对于 $R$ 中的所有元组都有 $X$ 的值唯一决定 $Y$ 的值，则称 $X$ 函数**决定** $Y$ 或 $Y$ **函数依赖**于 $X$ ，记作 $X \to Y$ 。

## 函数依赖的特性
1. **平凡**依赖：对于 $X \to Y$ ，如果 $Y \subset X$ 
2. $X \leftrightarrow Y$ ：如果 $X \to Y$ ，同时 $Y \to X$
3. $X \not \to Y$ ： $Y$ 不函数依赖于 $X$
4. 如果 $R$ 中找不到两个取值相同的 $X$ 的元组，那么 $X \to Y$ 一定成立

## 完全函数依赖
如果有 $X \to Y$ 。 $X$ 的任何真子集 $X'$ ，都有 $X' \not \to Y$ ，则称 $Y$ **完全函数依赖**于 $X$ ，记作 $X \overset{f} \to Y$ 。否则称 $Y$ **部分函数依赖**于 $X$ ，记作 $X \overset{p} \to Y$ 。

## 传递函数依赖
如果有 $X \to Y$ ， $Y \to Z$ ，且它们都是非平凡的，同时有 $Z \not \subset X$ ，则称 $Z$ **传递函数依赖**于 $X$ 。

## 候选键
全集 $U$ 的任何一个子集 $K$ ，如果满足：
$$
K \overset{f} \to U
$$
则称 $K$ 是 $U$ 的一个**候选键**。可以选择任一候选键作为关系模式的**主键**。

## 主属性
存在于所有候选键中的属性称为**主属性**。

## 超键
候选键的真超集

## 逻辑蕴涵
设 $F$ 是关系模式 $R(U)$ 上的一个函数依赖集合，如果能通过其中的函数依赖推导出 $X \to Y$ ，则称 $F$ **逻辑蕴涵** $X \to Y$ ，记作 $F \models X \to Y$ 。

## 闭包
被 $F$ 蕴涵的所有函数依赖的集合称为 $F$ 的**闭包**，记作 $F^+$ 。如果 $F^+ = F$ ，则称 $F$ 是全函数依赖族（函数依赖完备集）。

## Armstrong 公理
1. **自反律**：如果 $Y \subseteq X$ ，则 $X \to Y$
2. **增广律**：如果 $X \to Y$ ，则 $XZ \to YZ$
3. **传递律**：如果 $X \to Y$ ， $Y \to Z$ ，则 $X \to Z$

以及推论：
1. **合并律**：如果 $X \to Y$ ， $X \to Z$ ，则 $X \to YZ$
2. **伪传递律**：如果 $X \to Y$ ， $WY \to Z$ ，则 $WX \to Z$
3. **分解律**：如果 $X \to YZ$ ，则 $X \to Y$ ， $X \to Z$

## 属性集闭包
给定一个属性集 $X$ ， $F$ 是关系模式 $R(U)$ 上的一个函数依赖集合， $X^+_F$ 是 $X$ 关于 $F$ 的闭包，表示 $X$ 在 $F$ 下逻辑蕴涵的所有属性的集合。

### 计算方法
求 $X^+_F$ 的方法：
1. 把 $X$ 作为 $X_0$
1. 每一轮，对 $X_{n-1}$ 尝试用 $F$ 中的每个函数依赖进行逻辑蕴含，如果可以，把右侧的属性纳入 $X_n$
1. 重复上述过程直到某一轮没有新属性加入

## 覆盖
对于两个函数依赖集合 $F$ 和 $G$ ，如果 $F^+ = G^+$ ，则称 $F$ 覆盖 $G$ ，或者反过来。

### 最小覆盖引理
函数依赖集 $F$ 可以被函数依赖集 $G$ 覆盖，并且 $G$ 的每个函数依赖右端只有一个属性。

### 最小覆盖
根据上述引理， $F$ 满足下面的条件时称为**最小覆盖**或**最小依赖集**：
1. $F$ 中函数依赖右端只有一个属性
1. 从 $F$ 中移出一个函数依赖后不能覆盖 $F$
1. 把 $F$ 中函数依赖的左端置换为其真子集后不能覆盖 $F$

<br><br>

# 关系模式设计之规范形式
$1NF \subset 2NF \subset 3NF \subset BCNF$ ，所以满足一个关系模式是2NF，首先需要关系模式是1NF，其他的类似，下面就不做赘述。

## 第一范式（1NF）
关系模式不存在复合属性和多值属性。

### 转换
把复合属性合并为单个属性，把多值属性和关键字一起作为另一组关系。

## 第二范式（2NF）
每个非主属性**完全函数依赖**于候选键，这确保候选键是足够精炼的。

## 第三范式（3NF）
不存在**非主属性** $A$ 对候选键 $X$ 的传递函数依赖：
$$
X \to Y, Y \to A \Rightarrow X \to A
$$
其中 $X \to Y$ 是非平凡的。这确保修改时不会出现没有传递到需要传递的属性的情况。

## 关系分解为3NF
激进地把所有函数依赖分解成关系，可以选择合并一些关系。

## Boyce-Codd范式（BCNF）
所有的**非平凡**函数依赖 $X \to Y$ ，都有 $X$ 是候选键或超键。

## 关系分解为BCNF
左侧含有候选键的函数依赖一起形成一个关系，其他的函数依赖独自形成关系。

<br><br>

# 模式分解
用于把一个关系模式分解成多个关系模式，这些关系模式的**并集**等于原来的关系模式。把函数依赖也拆分进这些关系模式中。

## 投影连接
设 $R$ 是关系模式， $r$ 表示对应的关系， $\rho = \{R_1, R_2, \cdots, R_n\}$ 是 $R$ 的一个模式分解， $r_i = \Pi_{R_i}(r)$ ，则有：
$$
m_\rho(r) = r_1 \bowtie r_2 \bowtie \cdots \bowtie r_n
$$

## 投影连接引理
设 $R$ 是关系模式， $r$ 表示对应的关系， $\rho = \{R_1, R_2, \cdots, R_n\}$ 是 $R$ 的一个模式分解， $r_i = \Pi_{R_i}(r)$ ，则有如下结论：
1. $r \subseteq m_\rho(r)$
1. $\Pi _{R_i} (m_\rho (r)) = R_i$
1. 幂等：$m_\rho(m_\rho(r)) = m_\rho(r)$

## 无损连接分解
如果 $m_\rho(r) = r$ ，则称 $\rho$ 是 $R$ 的一个**无损连接分解**。

### 检验方法
构造表格：
| | $A_1$ | $A_2$ | $\cdots$ | $A_n$ |
| - | - | - | - | - |
| $R_1$ | $b_{12}$ | $a_2$ | $\cdots$ | $b_{1n}$ |
| $R_2$ | $a_1$ | $b_{22}$ | $\cdots$ | $b_{2n}$ |
| $\vdots$ | $\vdots$ | $\vdots$ | $\ddots$ | $\vdots$ |
| $R_n$ | $b_{n1}$ | $b_{n2}$ | $\cdots$ | $a_n$ |

如果 $A_j \in R_i$ ，则 i 行 j 列的值为 $a_j$ ，否则为 $b_{ij}$ 。

- 使用 $A_i \to A_j$ 的函数依赖，如果两行的 $A_i$ 相同，可以用其中一行的 $A_j$ 值替换另一行的 $A_j$ 值。
- 一直替换，如果最后有一行全都是 $a$ ，则是无损连接分解。

### 分解成两关系的无损连接检验
当且仅当 $R_1 \cap R_2 \to R_1 - R_2$ 或 $R_1 \cap R_2 \to R_2 - R_1$ 时，是无损连接分解。

## 保持依赖分解
如果分解以后所有子依赖集的并集，可以覆盖原来的依赖集，则称分解是**保持依赖分解**。

### 检验方法
对于 $F$ 中的每个函数依赖 $X \to Y$ ，取 $Z_0 = X$ ，然后检查从每个子关系中纳入 $Z_0$ 通过子依赖集能蕴涵出的属性，如果构造出的集合 $Z$ 中有 $Y$ ，那么说明分解后的子依赖集的并集逻辑蕴涵 $X \to Y$ 。<br>
如此，检查 $F$ 中所有的函数依赖，如果全部都能被蕴涵，那么就是保持依赖分解。

## 无损连接分解为BCNF
不断检查函数依赖，如果有非平凡函数依赖 $X \to Y$ ，且 $X$ 不是超键，那么就把 $X$ 和 $Y$ 单独形成一个关系，并从原关系中删除 $Y$ 。

## 保持依赖分解为3NF
- 取出所有不参与形成依赖的属性，形成一个关系
- 对于所有形式为 $X \to Y_i$ 的函数依赖，把 $X$ 和所有的 $Y_i$ 形成一个关系

## 既保持依赖又无损连接
对于上面分解出的3NF，把它并上候选键，就是既保持依赖又无损连接的分解。