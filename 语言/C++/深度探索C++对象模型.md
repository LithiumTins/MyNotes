# 关于对象
在C语言中，数据和操作其的函数往往是分离的，这被称为**程序性**的。在C++中，可以通过类把数据和操作绑定在一起进行数据封装。这样的封装实际上没有带来什么成本，主要的额外负担实际上来自于虚函数和虚基类的使用。

## C++对象模型
在C++中，有两种数据成员：静态和非静态，有三种成员函数：静态、非静态和虚函数。考虑这个类，看看它是怎么在机器中表现的：
```cpp
class Point {
public:
    Point( float xval );
    virtual ~Point();

    float x() const;
    static int PointCount();

protected:
    virtual ostream& 
        print( ostream &os ) const;

    float _x;
    static int _point_count;
};
```

### 简单对象模型
最简单的实现就是每个成员和函数都用一个指针指向，这样类实例的大小也就是指针的个数乘以指针的大小。然而这样的实现性能开销很大。

### 表格驱动对象模型
这种模型区分数据成员和成员函数，一个类实例内含两个指针，一个指向数据成员表，表中实际存放数据成员；另一个指向成员函数表，表中存放一个个指针，指向实际的成员函数。

### C++对象模型
C++的对象模型实际上由简单对象模型派生而来，并且对内存空间和存取时间做了优化。非静态数据成员放在类实例中，静态数据成员则单独放在外面。静态和非静态成员函数都放在类实例之外。对于虚函数，有两个步骤支持：
- 每一个类会形成一个虚函数表（virtual table，简称vtbl），里面存放了指向虚函数的指针。
- 类实例中实际有一个指针，指向虚函数表，它被称为vptr。它的设定和重置由类的构造、析构等运算符自动完成。每一个类关联的用来支持 `RTTI` 的 `type_info object` 也在虚函数表中，一般放在第一个槽中。

#### 加上继承
在C++中有单继承和多继承，乃至虚继承。<br><br>
对于基类在派生类中的表现形式，简单对象模型中可以用一个槽来指向基类，使得基类的大小变化并不会影响到派生类，然而时间空间上也带来额外的开销。<br><br>
考虑另一种基类表模型，可以在每个类中用一个特定的基类表指针指向基类表，里面的每个槽位都指向一个基类，它保证每个类中表现形式一致而且让基类表具有可伸缩性，然而也带来时空上的额外开销。<br><br>
以上的两种模型，随着继承级数的增加，需要更多次的解引用才能获取到一个深层的基类。<br><br>
C++最初使用的模型直接把基类实例放在派生类实例中，这样效率很高，但是基类发生任何改变都要求派生类重新编译。<br><br>
到了C++2.0引入了虚基类，最初的模型是在类实例中为所有的基类添加一个指针。还有一些烟花出来的模型，如拓展原已存在的virtual table之类的。

### 对象模型如何影响程序
一般来说，不同的对象模型带来“现有的程序代码必须修改”和“必须加入新的程序代码”两个结果。

## 关键词所带来的差异
讨论了 `struct` 和 `class` 的问题，但是没看懂想要表明什么。

## 对象的差异
C++支持三种程序设计范式：
- 程序模型，跟C语言一样
- 抽象数据类型模型，类似于std::string
- 面向对象模型，大量使用继承和多态

<br><br>

# 函数构造语义学

## 默认构造函数的构造操作
当一个类没有构造函数时，一个默认构造函数会被合成出来，一般情况下它被视为无用的（实际上也不会被合成出来）。有以下四种情况，它被编译器视为有用的，但也仅仅是面向编译器的。

### 带有默认构造函数的类成员对象
当一个类中有另一个类的对象时，默认构造函数需要完成调用该成员类的构造函数的工作。当程序员自己生成了构造函数时，编译器没法再合成构造函数，但是初始化成员类的工作还是需要的，此时编译器会扩展程序员的构造函数，在其之前插入一些必要的代码。如果有多个成员类对象，编译器按照它们的声明顺序依次调用它们的构造函数。

### 带有默认构造函数的基类
类似上一种情况，派生类需要调用基类的默认构造函数。

### 带有虚函数
有虚函数的类需要用到虚函数表，它需要在构造函数中被初始化。

### 带有虚基类
虚基类可能是通过指针来实现的，这个指针需要在构造的时候被初始化。

## 拷贝构造函数的构造操作
虽然根据往常的认知，拷贝构造函数不存在的时候会自动合成一个。然而实际上，当一个类表现出逐位拷贝的语义时，它的构造函数就不是必要的，也不会被真的合成出来。也就是说，像上面的默认构造函数一样，只有必须的情况下才实际存在拷贝构造函数。

### 逐位拷贝语义
当一个类中的数据成员全是基本数据类型或指针时，显然它可以简单地通过逐位拷贝来实现拷贝，这种情况下就不会合成一个拷贝构造函数。然而如果有成员是类对象，那么拷贝构造函数需要调用它的拷贝构造函数，这时拷贝构造函数的存在就是必要的，它会被合成出来。

### 不展现逐位拷贝语义的情况
前两种情况比较显然，后面两种情况则比较复杂：
- 有一个具有拷贝构造函数的类成员对象
- 有一个具有拷贝构造函数的基类
- 有虚函数
- 有虚基类

#### 重新设定虚函数表的指针
由于虚函数表的指针需要被正确设置，当类使用了虚函数时，它就不再具有逐位拷贝语义，拷贝构造函数需要被合成出来。这个构造函数往往是显式地设置虚函数表指针为对应类的虚函数表的地址，而不是直接拷贝源对象的虚函数表指针，否则当从派生类对象赋值到基类对象时，将发生严重的错误。

#### 处理虚基类子对象
当一个类有虚基类时，并且把它赋值为它的一个派生类对象时，需要正确地设置虚基类表的指针。

## 程序转化语意学
考虑以下的程序片段：
```cpp
# include "X.h"

X foo()
{
    X xx;
    // ...
    return xx;
}
```
程序员可能做出如下假设：
- 每次 `foo()` 被调用，就传回 `xx` 的值
- 如果 `class X` 定义了拷贝构造函数，那么 `foo()` 被调用时，保证这个函数会被调用

然而实际上在一个高质量的C++编译器中，这两点都有可能是错误的。

### 显式的初始化操作
以下的程序片段：
```cpp
void foo_bar() {
    X x1( x0 );
    X x2 = x0;
    X x3 = X( x0 );
}
```
实际上会被转换为这样的形式：
```cpp
void foo_bar() {
    X x1;
    X x2;
    X x3;

    x1.X::X( x0 );
    x2.X::X( x0 );
    x3.X::X( x0 );
}
```

### 参数的初始化
对于函数
```cpp
void foo( X x );
```
调用
```cpp
X xx;
foo( xx );
```
实际上 `foo()` 的原型会被转换为
```cpp
void foo( X &x );
```
实际调用的代码则变成了
```cpp
X __temp0;
__temp0.X::X( xx );
foo( __temp0 );
```
还有一种做法被称为**拷贝建构**，它直接把类实例建构在该函数的调用栈帧上。

### 返回值的初始化
如果函数要返回一个类对象，如
```cpp
X bar()
{
    X xx;
    // ...
    return xx;
}
```
实际上这个返回值是通过转换成参数来实现的，如
```cpp
void bar( X &__result )
{
    X xx;
    xx.X::X();

    // ...

    __result.X::X( xx );

    return;
}
```
因为改变了函数原型，对应的函数指针也需要改变。

### 在使用者层面做优化
似乎是一种比较丑陋的做法，比如这个函数：
```cpp
X bar( const T &y, const T &z )
{
    X xx;
    // 用y和z来处理xx
    return xx;
}
```
这会导致 `xx` 被计算后，又需要拷贝到 `__result` 中，性能较差。可以把这里的计算行为封装进一个构造函数里，然后把 `bar()` 改写成
```cpp
void bar( const T &y, const T &z)
{
    return X( y, z );
}
```
这似乎更多考虑的是性能，对面向对象的思想来说是一种破坏。

### 在编译器层面做优化
聪明的编译器可能会发现上面的函数总是返回同一个具名对象 `xx` ，它可以直接使用 `__result` 来代替 `xx` ，这样就不需要拷贝了。这样的优化被称为**NRV优化**，这几乎是所有编译器都会做的优化。然而这似乎并不总是理想的，有时候会导致跳过一些拷贝构造函数，这或许会让程序员感到困惑。

### 拷贝构造函数：要还是不要？
当一个类可以逐位拷贝时，为它创建一个拷贝构造函数是没有什么意义的。书上说提供一个拷贝构造函数有利于NRV优化，但是在现代编译器上，拷贝构造函数似乎与NRV优化没有太大的关系。

## 成员们的初始化队伍
有了构造函数，就可以对类数据成员进行初始化，或使用初始化列表，或在构造函数内手动初始化。然而有一下四种情况，应该使用初始化列表：
- 初始化引用成员
- 初始化常量成员
- 带参数调用基类构造函数
- 带参数调用成员类构造函数

在构造函数内初始化有时会有些问题，比如根据上述的内容，类成员会自动调用默认构造函数。然而如果在构造函数内给它赋值，那么这个默认构造的调用是完全没有必要的，所以性能会差。

另外值得一提的是，初始化列表的实际上会被扩展成正常的代码放进构造函数中。它的执行顺序是按照成员的声明顺序，并且所有代码被放在构造函数真正的代码之前。

可以在初始化列表中调用成员函数，但最好不要这么做，因为它可能依赖于一些未初始化的成员。

在初始化列表中，尽量不要把派生类函数成员的返回结果传递给基类的构造函数，因为基类的构造函数会最先被调用，无关它们在初始化列表中的顺序。

<br><br>

# Data语意学
考虑以下的四个类：
```cpp
class X { };
class Y { } : public virtual X { };
class Z { } : public virtual X { };
class A { } : public Y, public Z { };
```
在一个指针占用4个字节的机器上。`X` 占用的内存为1字节，这是编译器特地安插的，为了使每个实例有唯一的地址。而 `Y` 和 `Z` 的大小为8字节，这受到三个因素的影响：
- 语言支持虚基类带来的额外开销（指针）
- 编译器对于某些特殊情况的优化
- 对齐的限制

实际上由于它们也没有成员，同样被安插一个字节，放在了虚基类指针的后面，这时又由于对齐要求，它们成为了8字节。实际上因为有虚基类指针的存在，那一个字节会被一些编译器优化掉，这时 `Y` 和 `Z` 的大小就变成了4字节。 `A` 的大小为12个字节，这似乎有些难以理解。

## 数据成员的绑定
在早期的C++编译器中，如果有一个全局的变量 `x` ，和一个写在类末尾的成员 `x` ，如果在成员函数中使用到 `x` 时，实际上调用到的是全局的那个 `x` ，这是反直觉的。从而导致早期出现了一种防御性编程风格：
- 把数据成员在类的开头声明
- 所有内联函数都定义在类之外

这是因为见到数据成员的声明以后就不会有错误绑定问题，同时内联函数被解析时已经看到了整个类的声明。然而C++2.0引入了一个规则，指出：一个内联函数在整个类的声明被看见之前，并不会被解析。这样就不需要上述的防御性编程风格了。不过当使用到 `typedef` 的别名声明函数的形参时，由于编译器识别函数原型需要提前解析形参，所以还是需要一些防御性编程（把 `typedef` 放在类的开头）。

## 数据成员的分布
类对象中只存储非静态数据成员，在同一个访问区内，它们的分布顺序和声明的顺序一致。注意这里不要求连续分布，因为可能插入一些字节进行对齐。C++编译器还会插入一些成员，如vptr这种，传统上它被放在类的最后，也有些编译器把它放在类的最前面，C++标准对此没有确切规定。如果不在同一个访问区，标准允许编译器把不同访问区之间随意排列，但似乎没有编译器这样做。

## 数据成员的存取
接下来考虑对数据成员的存取有多大的开销。

### 静态数据成员
由于静态数据成员实际上是属于整个类而不是某个对象的，所以它被放在全局内存区。不管以怎么样的方式访问它，都会被转换成对全局变量的访问，所以跟访问其他的变量相比没有什么额外开销。因为放在全局内存区，如果两个不同类的静态数据成员同名，就会有冲突，编译器往往使用 `name-mangling` 对于名字做出一些修改来解决这个问题，这种算法有两个要点：
- 保证每个名字都是唯一的
- 可以推断出原始的名字

### 非静态数据成员
无论是类自己的成员还是直接基类的成员，它们的偏移量在编译器就已经被算出，在访问的时候，总是通过对象地址加上偏移量来计算，这跟C语言结构体访问的开销是一样的。然而如果这个成员是通过虚基类继承而来的，那么考虑以下两种访问方式：
```cpp
origin.x = 0.0;
pt->x = 0.0;
```
这种情况下，无法确定第二种中的指针具体指向的是哪个类的对象，就需要被推迟到执行期来判断，性能上就会有差别。而第一种，它的类型是确定下来的，可以在编译器解决。

## 继承与数据成员
一般而言，基类的数据成员放在派生类中，而且往往在派生类成员的前面。然而虚基类有一些区别。接下来考虑一种情形，现在需要一个2D点，有成员 `x` 和 `y` ，另外还需要一个3D点，有成员 `x` 、 `y` 和 `z` ，考察不同的实现方式之间有什么不同。

### 只要继承不要多态
也就是如下的实现：
```cpp
class Point2d {
public:
    Point2d( float x = 0.0, float y = 0.0 )
        : _x( x ), _y( y ) { };

    float x() { return _x; }
    float y() { return _y; }

    void x( float newX ) { _x = newX; }
    void y( float newY ) { _y = newY; }

    void operator+=( const Point2d &rhs )
    {
        _x += rhs.x();
        _y += rhs.y();
    }
    // ... more members

protected:
    float _x, _y;
};

// inheritance from concrete class
class Point3d : public Point2d {
public:
    Point3d( float x = 0.0, float y = 0.0, float z = 0.0 )
        : Point2d( x, y ), _z( z ) { };

    float z() { return _z; }
    void z( float newZ ) { _z = newZ; }

    void operator+=( const Point3d &rhs ) {
        Point2d::operator+=( rhs );
        _z += rhs.z();
    }
    // ... more members

protected:
    float _z;
};
```
这种做法的优点可以共享数据和它们的处理方法，减少重复的代码，并且增加局部性（没看懂）。缺点是由于C++编译器会保留基类的对齐字节，如果设计不当的话，可能就会出现很多的空洞，导致内存浪费激增。之所以保留对齐字节，考虑如下的情况：
```cpp
class Concrete1 {
public:
    // ...
private:
    int val;
    char bit1;
};

class Concrete2 : public Concrete1 {
public:
    // ...
private:
    char bit2;
};

class Concrete3 : public Concrete2 {
public:
    // ...
private:
    char bit3;
};
```
对于类 `Concrete2` 来说，可以把它的成员 `bit2` 合并到前面的对齐空洞处，这可以节约不少的内存，特别是到了 `Concrete3` 处。但实际上 `Concrete3` 的大小高达16个字节。这是由于考虑了以下的拷贝行为：
```cpp
Concrete1 *p1 = new Concrete1, *p2;
Concrete2 c2 = new Concrete2;
p2 = reinterpret_cast<Concrete1 *>( c2 );
*p1 = *p2;
```
如果把 `bit2` 合并到空洞处，编译器会把这个成员一并拷贝过去，这是错误的。

### 加上多态
当需要处理坐标点，并且无论是2D点还是3D点都可以顺利进行的时候，就需要用到虚函数：
```cpp
class Point2d {
public:
    Point2d( float x = 0.0, float y = 0.0 )
        : _x( x ), _y( y ) { };

    float x() { return _x; }
    float y() { return _y; }

    virtual float z() { return 0.0 };
    virtual void z( float ) { };

    virtual void operator+=( const Point2d &rhs )
    {
        _x += rhs.x();
        _y += rhs.y();
    }
    // ... more members

protected:
    float _x, _y;
};

class Point3d : public Point2d {
public:
    Point3d( float x = 0.0, float y = 0.0, float z = 0.0 )
        : Point2d( x, y ), _z( z ) { };

    float z() { return _z; }
    void z( float newZ ) { _z = newZ; }

    void operator+=( const Point2d &rhs ) {
        Point2d::operator+=( rhs );
        _z += rhs.z();
    }
    // ... more members
protected:
    float _z;
};
```
虚函数的使用为程序设计带来的前所未有的弹性，但这是以时空上的开销为代价的：
- 引入了一个虚函数表，一般占用的槽位数就是虚函数的个数，外加一两个用来支持运行时类型识别
- 为了索引虚函数表，带入vptr
- 为了设置vptr，需要加强构造函数
- 相反地，也需要加强析构函数来清理vptr

这里涉及到vptr应该放在一个类的什么位置的问题，如果放在最后，可以保证与C语言结构体成员访问的兼容性；如果放在前面的话，通过vptr调用虚函数会方便很多，因为不用维护偏移量了。

### 多重继承
考虑以下的继承关系：
```cpp
class Point2d {
public:
    // ...
protected:
    float _x, _y;
};

class Point3d : public Point2d {
public:
    // ...
protected:
    float _z;
};

class Vertex {
public:
    // ...
protected:
    Vertex *next;
}

class Point3dVertex : public Point3d, public Vertex {
public:
    // ...
protected:
    float mumble;
};
```
当出现这样的多重继承时，如果按照继承顺序来布局，并且把基类放在最前面，那么 `Point3d` 跟 `Point3dVertex` 指针地址的转换就是很自然的。但是 `Vertex` 和 `Point3dVertex` 的转换就需要加上偏移量。另外，加上偏移量还会带来一些问题，比如从 `Point3dVertex` 指针转换为 `Vertex` 指针但是前者是空指针，显然这里需要对空指针进行特判。

多重继承中的基类布局方式C++标准并没有明确规定。有的编译器会在第一个基类没有vptr而第二个基类有的时候调换它们的顺序，这样可以省下一个vptr，但这项技术没有普及。

### 虚拟继承
多重继承有时候会遇到一个基类有多个实例，但使用中只需要一个实例的情况，这就是虚拟继承的用武之地。一般支持虚继承会把类分成两个部分，一个是不变区域，这就是类自己的部分；一个是共享区域，这里就用来支持虚继承。

最简单的方案就是为每个虚基类都插入一个指针，但是这样的方案有两个缺点：
- 类为支持虚基类付出的负担不是固定的
- 随着虚继承层次的增加，访问的时间会变得更长

对于第二个问题，比较笨拙的解决方案是递归地取得所有虚基类的指针，把它们放进派生类最后面，每个类有一个指针指向它的虚基类部分。不过会带来大量的空间开销。在MetaWare编译器中，可以让程序员选择是否使用“二重指针”。

对于第一个问题，一般来说有两种解决方法：
- 微软使用的是虚基类表的方案，同时引入虚基类指针
- Bjarne支持的方案是把虚基类的位置放在类的最后面，并且在虚函数表中用一个槽位来记录虚基类的偏移量。有些编译器还开发了vptr指向虚基类偏移量和虚函数槽位分界处的方案，这样当使用正数下标就是访问虚函数表，使用负数下标就是访问虚基类。

显然，如果进行虚基类成员的非多态访问，可以由编译器在编译器完成解析，这是高效的。开销主要考虑的是执行期的解析。

书中指出，虚基类使用最有效的一种方式就是抽象虚基类，没有数据成员。

## 对象成员的效率
考虑聚合、封装和继承三种方式的引发的额外负荷大小。根据书中的测试结果，开启优化时，对于三个 `float` 类型的 `x` 、 `y` 、 `z` 三个变量来说，无论是直接放在数组中，还是放在结构体中直接访问，或者是放在类中用内联函数返回引用，甚至是使用getter和setter，性能上都完全相同。所以在编译器的优化下，封装不会带来任何额外的开销。

然后测试继承对于性能的影响，依然是使用 `Point1d` 、 `Point2d` 、 `Point3d` 这样的模型。分别考虑单继承、从 `Point1d` 到 `Point2d` 使用虚拟继承、从 `Point2d` 到 `Point3d` 也使用虚拟继承，这三种情况。测试结果表明，优化开启时，单继承对性能没有影响，因为访问在编译器就已经被解析（有趣的是，关闭优化的时候，使用内联函数的访问比直接访问要慢）；而虚继承的性能很差，即使对 `Point1d` 的成员访问是通过非多态对象进行的，这几乎没有被编译器处理。

## 指向数据成员的指针
对于类内的成员，对它们取偏移量得到的结果总是预期的值加上1，这是为了区别空指针和指向首个成员的指针：
```cpp
class Point3d {
public:
    float x, y, z;
};

float Point3d::*p1 = 0;
float Point3d::*p2 = &Point3d::x;
```
显然这两个指针不应该是相等的，所以把所有的成员指针都增加了1。在遇上多重继承的时候，使用成员指针会相当的复杂，特别是当需要一个多重继承的派生类成员指针却传入一个位于继承列表后方的基类成员指针时，这里的指针就必须经过某种转换。

### 指向成员的指针的效率问题
考虑以下的代码：
```cpp
// 1
pB.x = pA.x - pB.x;
pB.y = pA.y - pB.y;
pB.z = pA.z - pB.z;

// 2
float *ax = &pA.x, *ay = &pA.y, *az = &pA.z,
    *bx = &pB.x, *by = &pB.y, *bz = &pB.z;
*bx = *ax - *bx;
*by = *ay - *by;
*bz = *az - *bz;

// 3
float Point3d::*px = &Point3d::x;
float Point3d::*py = &Point3d::y;
float Point3d::*pz = &Point3d::z;
pB.*px = pA.*px - pB.*px;
pB.*py = pA.*py + pB.*py;
pB.*pz = pA.*pz + pB.*pz;
```
不开启优化的情况下，情况2比起情况1来说慢了一倍（原因不懂，可能是因为指针解引用需要先读入指针？），而情况3需要对offset进行修正，性能则又差了许多。不过开启优化的情况下，三种情况的性能都是一样的。

然后来看看继承对于成员指针性能的影响，仍然使用前面的 `Point1d` 、 `Point2d` 和 `Point3d` 的模型。测试结果显示，单继承在优化情况下对性能没有影响，而虚拟继承由于每次访问都需要先取虚基类指针，性能则差了许多。
