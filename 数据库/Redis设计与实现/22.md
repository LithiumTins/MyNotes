# 22 - 二进制位数组
Redis 提供了二进制位数组的功能，同时提供了 SETBIT、GETBIT、BITCOUNT、BITOP 四个命令用于操作它们。

这些指令用法如下：
- `SETBIT <arr> <offset> <value>` 用于设置某一位的值
- `GETBIT <arr> <offset>` 用于获取某一位的值
- `BITCOUNT <arr>` 用于统计数组中值为 1 的位数
- `BITOP (AND | OR | XOR) <res> <arr1> <arr2> [<arr3> ...]` 用于对多个数组进行位运算
- `BITOP NOT <res> <arr>` 用于对一个数组进行取反操作

## 22.1 - 位数组的表示
位数组是使用 SDS 字符串对象来存储的，buf 中的每个字节存储 8 个位，最后跟上一个空字符 `\0` 作为字符串结束符。

值得注意的是，整个位数组是逆序存储的，一方面低地址存储低位，这是为了插入新字节时不需要移动原有的数组；另一方面，字节内也是逆序存储，这是为了计算字节内偏移量时比较方便。

## 22.2 - GETBIT 命令的实现
对 offset 除以 8 得到字节偏移量，对 8 取余得到位偏移量。

## 22.3 - SETBIT 命令的实现
跟 GETBIT 类似，必要时扩展 SDS 长度。

对于扩展操作，如果 SDS 空间足够，直接修改 len，新值直接填到正确的位置即可，无需移动原有数据；如果 SDS 空间不够，可能需要重新分配内存。

## 22.4 - BITCOUNT 命令的实现
计算 1 的位数有几种算法来处理。

### 22.4.1 - 遍历
遍历每个字节的每一位，统计 1 的个数。很慢。

### 22.4.2 - 查表
可以预先建立 2 的 8 次方大小的数组，每个元素为索引值对应的 1 的个数，从而省去对字节内部的遍历。显然这提供了 8 倍的速度提升。

或许也可以建立 16 位或者 32 位的表，这样可以一次性处理更多位，不过代价是表会变得很大，浪费内存也不利于 CPU 缓存。从而这样的加速实际上效果有限。

### 22.4.3 - variable-precision SWAR
实际上这是在求解汉明重量问题，使用硬件来处理优势会很大，而如果纯软件的话已知最高效的通用算法是 variable-precision SWAR。

统计 32 位无符号整数中 1 的个数的算法如下：
```c
uint32_t swar(uint32_t i) {
    i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    i = (i & 0x0f0f0f0f) + ((i >> 4) & 0x0f0f0f0f);
    i = ((i * 0x01010101) >> 24);
}
```
思想上就是利用加法中按位分组隐含的并行性，从而实现对数级别的优化。

### 22.4.4 - Redis 的实现
Redis 结合了查表和 variable-precision SWAR 两种算法：
- 如果剩余位数达到 128，调用 4 次 SWAR 分别处理 4 个 32 位并相加，实现 128 位的统计
- 如果剩余位数不足 128，使用 8 位的表依次统计每个字节的 1 的个数并相加

## 22.5 - BITOP 命令的实现
对于 AND、OR、XOR 三种位运算，对操作数逐字节执行位运算。

对于 NOT 操作，逐字节取反。