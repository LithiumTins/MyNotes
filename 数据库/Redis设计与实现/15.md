# 15 - 复制
用户可以用 `SLAVEOF` 命令或设置 slaveof 选项来让 Redis 复制其他的服务器，此时它成为从服务器，被复制的服务器成为主服务器。它们将保存相同的数据，概念上称为数据库状态一致，简称一致。

在 Redis 2.8 版本之前的复制有性能缺陷，称为旧版复制功能；2.8 以后改善了这些问题，称为新版复制功能。

## 15.1 - 旧版复制功能的实现
分为两个阶段：
- 同步：把从服务器的状态同步到主服务器当前的状态
- 命令传播：主服务器接收到写命令后，将命令传播给所有从服务器，从而继续保持一致

### 15.1.1 - 同步
当客户端向从服务器发送 `SLAVEOF` 命令，从服务器首先需要同步主服务器的状态。这通过向主服务器发送 `SYNC` 命令来实现。

主服务器收到以后，执行 BGSAVE 生成一个 RDB 文件，同时使用一个缓冲区记录接下来执行的写命令。当 BGSAVE 完成后，主服务器将 RDB 文件发送给从服务器，从服务器接收到后载入 RDB 文件。主服务器也把缓冲区中的写命令发送给从服务器，从服务器执行这些写命令，使得从服务器的状态和主服务器一致。

### 15.1.2 - 命令传播
同步完成以后，两个服务器已经一致。而主服务器可能会被写命令改变，因此主服务器也把写命令发送给从服务器，它们也执行这些写命令。

## 15.2 - 旧版复制功能的缺陷
如果从服务器因为某些原因断开连接，并很快恢复过来，此时它也需要进行同步过程，从而又需要生成、传输、载入 RDB 文件。这是没有必要的，因为从服务器的状态大部分仍是和主服务器一致的。

## 15.3 - 新版复制功能的实现
Redis 2.8 引入了 PSYNC 命令来替代 SYNC 命令，它有两种工作模式：
- 完整重同步：初次复制的时候，仍然使用 RDB 文件来同步
- 部分重同步：断开连接后，重新连接时，如果条件允许，只需要传输期间执行的写命令

## 15.4 - 部分重同步的实现
有三个重要的组件。

### 15.4.1 - 复制偏移量
主从服务器都会维护一个复制偏移量：
- 主服务器传播 N 个字节的数据后，复制偏移量增加 N
- 从服务器接收到 N 个字节的数据后，复制偏移量增加 N

通过在 PSYNC 命令中传递复制偏移量，主服务器就可以判断是否可以进行部分重同步；如果可以，应该传输哪些数据。

### 15.4.2 - 复制积压缓冲区
什么情况下选择完整重同步，什么情况下选择部分重同步？主服务器通过复制积压缓冲区来判断，默认情况下这是一个 1MB 的队列，可以看做是一个环形缓冲区，新增的数据可能会覆盖旧的数据。

当主服务器传播命令的时候，它同时也把命令写入复制积压缓冲区。当主服务器接收到从服务器的 PSYNC 命令时，它检查复制积压缓冲区中的数据是否足以完成部分重同步，如果不够，就选择完整重同步。

缓冲区的大小可以通过配置文件的 `repl-backlog-size` 选项来设置，一般建议设置成服务器恢复时间内预估会产生的命令数据量。

### 15.4.3 - 服务器运行 ID
这也用于判断是否可以进行部分重同步。每个 Redis 服务器都在启动时生成自己的运行 ID，由 40 个十六进制字符组成。从服务器初次复制时，主服务器返回自己的运行 ID，从服务器保存这个 ID。

当从服务器断开连接后，再次连接时，它会把自己保存的运行 ID 传递给主服务器，主服务器判断：
- 如果该 ID 和自己的 ID 不同，说明之前复制的不是自己，只能进行完整重同步
- 如果相同，说明之前复制的是自己，可以尝试进行部分重同步

## 15.5 - PSYNC 命令的实现
PSYNC 命令的调用格式为 `PSYNC <run_id> <offset>`，具体有几种情况：
- 从服务器初次复制：执行 `PSYNC ? -1`，请求主服务器执行完整重同步
- 从服务器后续复制：执行 `PSYNC <run_id> <offset>`

而接收到的回复决定了接下来的行为：
- 如果主服务器返回 `+FULLRESYNC <runid> <offset>` 则表示完整重同步
- 如果主服务器返回 `+CONTINUE` 则表示部分重同步
- 如果主服务器返回 `-ERR` 则表示主服务器版本低于 2.8，不支持 PSYNC 命令

## 15.6 - 复制的实现
命令格式为 `SLAVEOF <host> <port>`

### 15.6.1 - 步骤 1：设置主服务器的地址和端口
当从服务器接收到这个一条命令的时候，它首先存储主服务器的地址和端口：
```c
struct redisServer {
    // ...

    // 主服务器的地址
    char *masterhost;

    // 主服务器的端口
    int masterport;

    // ...
};
```
完成以后它马上返回 OK，而实际的复制工作在这之后进行。

### 15.6.2 - 步骤 2：建立套接字连接
从服务器连接到主服务器，然后它把该套接字关联到处理复制的文件事件处理器上。而主服务器这时只把从服务器当作一个普通的客户端。

### 15.6.3 - 步骤 3：发送 PING 命令
该命令起到两个作用：
- 检查套接字读写功能是否正常
- 检查主服务器是否能够正常处理命令

正常情况下，主服务器会返回 PONG 回复。如果从服务器没有收到回复或收到错误回复，它会关闭连接，然后重新连接。

### 15.6.4 - 步骤 4：身份验证
如果从服务器设置了 masterauth 选项，它会进行身份验证：发送 `AUTH <password>` 命令，password 是 masterauth 选项的值。如果主服务器设置了 requirepass 选项，且该选项值和 masterauth 相同，那么后续工作可以继续。如果两个选项值不同，返回一个 invalid password 错误。

如果从服务器设置了 masterauth 而主服务器没有设置 requirepass 选项，返回一个 no password is set 错误；如果主服务器设置了 requirepass 而从服务器没有设置 masterauth 选项，返回一个 NOAUTH 错误。

无论发生何种错误，从服务器都会关闭连接，然后重新连接。

### 15.6.5 - 步骤 5：发送端口信息
完成身份验证以后，从服务器发送指令 `REPLCONF listening-port <port>`，这个端口号被主服务器记录下来：
```c
struct redisServer {
    // ...

    // 从服务器的监听端口号
    int slave_listening_port;

    // ...
};
```
它的唯一作用就是在 `INFO replication` 命令中显示出来。

### 15.6.6 - 步骤 6：同步
此时从服务器可以发送 `PSYNC` 命令了。值得一提的是，执行同步时以及后续的命令传播中，主服务器也成为从服务器的客户端，从而它可以通知从服务器执行写命令。

### 15.6.7 - 步骤 7：命令传播
主服务器在执行写命令时，会把命令发送给所有从服务器。

## 15.7 - 心跳检测
在命令传播阶段，默认情况下每隔一秒从服务器需要向主服务器发送心跳命令 `REPLCONF ACK <offset>`，offset 是从服务器的复制偏移量。这有三个作用：
- 检查主从连接是否正常
- 辅助实现 min-slaves 选项
- 检测命令丢失

### 15.7.1 - 检测主从服务器的网络连接状态
如果超过一秒没有收到从服务器的心跳命令，则连接很有可能出现问题。距离上次心跳命令的时间可以通过 `INFO replication` 命令查看。

### 15.7.2 - 辅助实现 min-slaves 配置选项
Redis 的 min-slaves-to-write 和 min-slaves-max-lag 用于防止主服务器在不安全的情况下执行写命令，比如从服务器过少或者复制延迟过大，如果主服务器崩溃，可能会导致数据丢失。如
```
min-slaves-to-write 3
min-slaves-max-lag 10
```
在从服务器数量少于 3 个 或者 3 个从服务器复制延迟都达到 10 秒时，主服务器拒绝执行写命令。

### 15.7.3 - 检测命令丢失
有时命令传播的时候一些写命令可能丢失，在心跳命令中附带复制偏移量，主服务器可以检查从服务器的复制偏移量是否和自己的一致，如果不一致，说明丢失了命令，主服务器可以重新传播。

在 Redis 2.8 以前，没有心跳命令，从而无法检测命令丢失，不利于数据一致性。