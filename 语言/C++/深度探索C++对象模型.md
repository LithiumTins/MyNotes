# 关于对象
在C语言中，数据和操作其的函数往往是分离的，这被称为**程序性**的。在C++中，可以通过类把数据和操作绑定在一起进行数据封装。这样的封装实际上没有带来什么成本，主要的额外负担实际上来自于虚函数和虚基类的使用。

## C++对象模型
在C++中，有两种数据成员：静态和非静态，有三种成员函数：静态、非静态和虚函数。考虑这个类，看看它是怎么在机器中表现的：
```cpp
class Point {
public:
    Point( float xval );
    virtual ~Point();

    float x() const;
    static int PointCount();

protected:
    virtual ostream& 
        print( ostream &os ) const;

    float _x;
    static int _point_count;
};
```

### 简单对象模型
最简单的实现就是每个成员和函数都用一个指针指向，这样类实例的大小也就是指针的个数乘以指针的大小。然而这样的实现性能开销很大。

### 表格驱动对象模型
这种模型区分数据成员和成员函数，一个类实例内含两个指针，一个指向数据成员表，表中实际存放数据成员；另一个指向成员函数表，表中存放一个个指针，指向实际的成员函数。

### C++对象模型
C++的对象模型实际上由简单对象模型派生而来，并且对内存空间和存取时间做了优化。非静态数据成员放在类实例中，静态数据成员则单独放在外面。静态和非静态成员函数都放在类实例之外。对于虚函数，有两个步骤支持：
- 每一个类会形成一个虚函数表（virtual table，简称vtbl），里面存放了指向虚函数的指针。
- 类实例中实际有一个指针，指向虚函数表，它被称为vptr。它的设定和重置由类的构造、析构等运算符自动完成。每一个类关联的用来支持 `RTTI` 的 `type_info object` 也在虚函数表中，一般放在第一个槽中。

#### 加上继承
在C++中有单继承和多继承，乃至虚继承。<br><br>
对于基类在派生类中的表现形式，简单对象模型中可以用一个槽来指向基类，使得基类的大小变化并不会影响到派生类，然而时间空间上也带来额外的开销。<br><br>
考虑另一种基类表模型，可以在每个类中用一个特定的基类表指针指向基类表，里面的每个槽位都指向一个基类，它保证每个类中表现形式一致而且让基类表具有可伸缩性，然而也带来时空上的额外开销。<br><br>
以上的两种模型，随着继承级数的增加，需要更多次的解引用才能获取到一个深层的基类。<br><br>
C++最初使用的模型直接把基类实例放在派生类实例中，这样效率很高，但是基类发生任何改变都要求派生类重新编译。<br><br>
到了C++2.0引入了虚基类，最初的模型是在类实例中为所有的基类添加一个指针。还有一些烟花出来的模型，如拓展原已存在的virtual table之类的。

### 对象模型如何影响程序
一般来说，不同的对象模型带来“现有的程序代码必须修改”和“必须加入新的程序代码”两个结果。

## 关键词所带来的差异
讨论了 `struct` 和 `class` 的问题，但是没看懂想要表明什么。

## 对象的差异
C++支持三种程序设计范式：
- 程序模型，跟C语言一样
- 抽象数据类型模型，类似于std::string
- 面向对象模型，大量使用继承和多态

<br><br>

# 函数构造语义学

## 默认构造函数的构造操作
当一个类没有构造函数时，一个默认构造函数会被合成出来，一般情况下它被视为无用的（实际上也不会被合成出来）。有以下四种情况，它被编译器视为有用的，但也仅仅是面向编译器的。

### 带有默认构造函数的类成员对象
当一个类中有另一个类的对象时，默认构造函数需要完成调用该成员类的构造函数的工作。当程序员自己生成了构造函数时，编译器没法再合成构造函数，但是初始化成员类的工作还是需要的，此时编译器会扩展程序员的构造函数，在其之前插入一些必要的代码。如果有多个成员类对象，编译器按照它们的声明顺序依次调用它们的构造函数。

### 带有默认构造函数的基类
类似上一种情况，派生类需要调用基类的默认构造函数。

### 带有虚函数
有虚函数的类需要用到虚函数表，它需要在构造函数中被初始化。

### 带有虚基类
虚基类可能是通过指针来实现的，这个指针需要在构造的时候被初始化。

## 拷贝构造函数的构造操作
虽然根据往常的认知，拷贝构造函数不存在的时候会自动合成一个。然而实际上，当一个类表现出逐位拷贝的语义时，它的构造函数就不是必要的，也不会被真的合成出来。也就是说，像上面的默认构造函数一样，只有必须的情况下才实际存在拷贝构造函数。

### 逐位拷贝语义
当一个类中的数据成员全是基本数据类型或指针时，显然它可以简单地通过逐位拷贝来实现拷贝，这种情况下就不会合成一个拷贝构造函数。然而如果有成员是类对象，那么拷贝构造函数需要调用它的拷贝构造函数，这时拷贝构造函数的存在就是必要的，它会被合成出来。

### 不展现逐位拷贝语义的情况
前两种情况比较显然，后面两种情况则比较复杂：
- 有一个具有拷贝构造函数的类成员对象
- 有一个具有拷贝构造函数的基类
- 有虚函数
- 有虚基类

#### 重新设定虚函数表的指针
由于虚函数表的指针需要被正确设置，当类使用了虚函数时，它就不再具有逐位拷贝语义，拷贝构造函数需要被合成出来。这个构造函数往往是显式地设置虚函数表指针为对应类的虚函数表的地址，而不是直接拷贝源对象的虚函数表指针，否则当从派生类对象赋值到基类对象时，将发生严重的错误。

#### 处理虚基类子对象
当一个类有虚基类时，并且把它赋值为它的一个派生类对象时，需要正确地设置虚基类表的指针。

## 程序转化语意学
考虑以下的程序片段：
```cpp
# include "X.h"

X foo()
{
    X xx;
    // ...
    return xx;
}
```
程序员可能做出如下假设：
- 每次 `foo()` 被调用，就传回 `xx` 的值
- 如果 `class X` 定义了拷贝构造函数，那么 `foo()` 被调用时，保证这个函数会被调用

然而实际上在一个高质量的C++编译器中，这两点都有可能是错误的。

### 显式的初始化操作
以下的程序片段：
```cpp
void foo_bar() {
    X x1( x0 );
    X x2 = x0;
    X x3 = X( x0 );
}
```
实际上会被转换为这样的形式：
```cpp
void foo_bar() {
    X x1;
    X x2;
    X x3;

    x1.X::X( x0 );
    x2.X::X( x0 );
    x3.X::X( x0 );
}
```

### 参数的初始化
对于函数
```cpp
void foo( X x );
```
调用
```cpp
X xx;
foo( xx );
```
实际上 `foo()` 的原型会被转换为
```cpp
void foo( X &x );
```
实际调用的代码则变成了
```cpp
X __temp0;
__temp0.X::X( xx );
foo( __temp0 );
```
还有一种做法被称为**拷贝建构**，它直接把类实例建构在该函数的调用栈帧上。

### 返回值的初始化
如果函数要返回一个类对象，如
```cpp
X bar()
{
    X xx;
    // ...
    return xx;
}
```
实际上这个返回值是通过转换成参数来实现的，如
```cpp
void bar( X &__result )
{
    X xx;
    xx.X::X();

    // ...

    __result.X::X( xx );

    return;
}
```
因为改变了函数原型，对应的函数指针也需要改变。

### 在使用者层面做优化
似乎是一种比较丑陋的做法，比如这个函数：
```cpp
X bar( const T &y, const T &z )
{
    X xx;
    // 用y和z来处理xx
    return xx;
}
```
这会导致 `xx` 被计算后，又需要拷贝到 `__result` 中，性能较差。可以把这里的计算行为封装进一个构造函数里，然后把 `bar()` 改写成
```cpp
void bar( const T &y, const T &z)
{
    return X( y, z );
}
```
这似乎更多考虑的是性能，对面向对象的思想来说是一种破坏。

### 在编译器层面做优化
聪明的编译器可能会发现上面的函数总是返回同一个具名对象 `xx` ，它可以直接使用 `__result` 来代替 `xx` ，这样就不需要拷贝了。这样的优化被称为**NRV优化**，这几乎是所有编译器都会做的优化。然而这似乎并不总是理想的，有时候会导致跳过一些拷贝构造函数，这或许会让程序员感到困惑。

### 拷贝构造函数：要还是不要？
当一个类可以逐位拷贝时，为它创建一个拷贝构造函数是没有什么意义的。书上说提供一个拷贝构造函数有利于NRV优化，但是在现代编译器上，拷贝构造函数似乎与NRV优化没有太大的关系。

## 成员们的初始化队伍
有了构造函数，就可以对类数据成员进行初始化，或使用初始化列表，或在构造函数内手动初始化。然而有一下四种情况，应该使用初始化列表：
- 初始化引用成员
- 初始化常量成员
- 带参数调用基类构造函数
- 带参数调用成员类构造函数

在构造函数内初始化有时会有些问题，比如根据上述的内容，类成员会自动调用默认构造函数。然而如果在构造函数内给它赋值，那么这个默认构造的调用是完全没有必要的，所以性能会差。

另外值得一提的是，初始化列表的实际上会被扩展成正常的代码放进构造函数中。它的执行顺序是按照成员的声明顺序，并且所有代码被放在构造函数真正的代码之前。

可以在初始化列表中调用成员函数，但最好不要这么做，因为它可能依赖于一些未初始化的成员。

在初始化列表中，尽量不要把派生类函数成员的返回结果传递给基类的构造函数，因为基类的构造函数会最先被调用，无关它们在初始化列表中的顺序。

<br><br>

# Data语意学
考虑以下的四个类：
```cpp
class X { };
class Y { } : public virtual X { };
class Z { } : public virtual X { };
class A { } : public Y, public Z { };
```
在一个指针占用4个字节的机器上。`X` 占用的内存为1字节，这是编译器特地安插的，为了使每个实例有唯一的地址。而 `Y` 和 `Z` 的大小为8字节，这受到三个因素的影响：
- 语言支持虚基类带来的额外开销（指针）
- 编译器对于某些特殊情况的优化
- 对齐的限制

实际上由于它们也没有成员，同样被安插一个字节，放在了虚基类指针的后面，这时又由于对齐要求，它们成为了8字节。实际上因为有虚基类指针的存在，那一个字节会被一些编译器优化掉，这时 `Y` 和 `Z` 的大小就变成了4字节。 `A` 的大小为12个字节，这似乎有些难以理解。

## 数据成员的绑定
在早期的C++编译器中，如果有一个全局的变量 `x` ，和一个写在类末尾的成员 `x` ，如果在成员函数中使用到 `x` 时，实际上调用到的是全局的那个 `x` ，这是反直觉的。从而导致早期出现了一种防御性编程风格：
- 把数据成员在类的开头声明
- 所有内联函数都定义在类之外

这是因为见到数据成员的声明以后就不会有错误绑定问题，同时内联函数被解析时已经看到了整个类的声明。然而C++2.0引入了一个规则，指出：一个内联函数在整个类的声明被看见之前，并不会被解析。这样就不需要上述的防御性编程风格了。不过当使用到 `typedef` 的别名声明函数的形参时，由于编译器识别函数原型需要提前解析形参，所以还是需要一些防御性编程（把 `typedef` 放在类的开头）。

## 数据成员的分布
类对象中只存储非静态数据成员，在同一个访问区内，它们的分布顺序和声明的顺序一致。注意这里不要求连续分布，因为可能插入一些字节进行对齐。C++编译器还会插入一些成员，如vptr这种，传统上它被放在类的最后，也有些编译器把它放在类的最前面，C++标准对此没有确切规定。如果不在同一个访问区，标准允许编译器把不同访问区之间随意排列，但似乎没有编译器这样做。

## 数据成员的存取
接下来考虑对数据成员的存取有多大的开销。

### 静态数据成员
由于静态数据成员实际上是属于整个类而不是某个对象的，所以它被放在全局内存区。不管以怎么样的方式访问它，都会被转换成对全局变量的访问，所以跟访问其他的变量相比没有什么额外开销。因为放在全局内存区，如果两个不同类的静态数据成员同名，就会有冲突，编译器往往使用 `name-mangling` 对于名字做出一些修改来解决这个问题，这种算法有两个要点：
- 保证每个名字都是唯一的
- 可以推断出原始的名字

### 非静态数据成员
无论是类自己的成员还是直接基类的成员，它们的偏移量在编译器就已经被算出，在访问的时候，总是通过对象地址加上偏移量来计算，这跟C语言结构体访问的开销是一样的。然而如果这个成员是通过虚基类继承而来的，那么考虑以下两种访问方式：
```cpp
origin.x = 0.0;
pt->x = 0.0;
```
这种情况下，无法确定第二种中的指针具体指向的是哪个类的对象，就需要被推迟到执行期来判断，性能上就会有差别。而第一种，它的类型是确定下来的，可以在编译器解决。

## 继承与数据成员
一般而言，基类的数据成员放在派生类中，而且往往在派生类成员的前面。然而虚基类有一些区别。接下来考虑一种情形，现在需要一个2D点，有成员 `x` 和 `y` ，另外还需要一个3D点，有成员 `x` 、 `y` 和 `z` ，考察不同的实现方式之间有什么不同。

### 只要继承不要多态
也就是如下的实现：
```cpp
class Point2d {
public:
    Point2d( float x = 0.0, float y = 0.0 )
        : _x( x ), _y( y ) { };

    float x() { return _x; }
    float y() { return _y; }

    void x( float newX ) { _x = newX; }
    void y( float newY ) { _y = newY; }

    void operator+=( const Point2d &rhs )
    {
        _x += rhs.x();
        _y += rhs.y();
    }
    // ... more members

protected:
    float _x, _y;
};

// inheritance from concrete class
class Point3d : public Point2d {
public:
    Point3d( float x = 0.0, float y = 0.0, float z = 0.0 )
        : Point2d( x, y ), _z( z ) { };

    float z() { return _z; }
    void z( float newZ ) { _z = newZ; }

    void operator+=( const Point3d &rhs ) {
        Point2d::operator+=( rhs );
        _z += rhs.z();
    }
    // ... more members

protected:
    float _z;
};
```
这种做法的优点可以共享数据和它们的处理方法，减少重复的代码，并且增加局部性（没看懂）。缺点是由于C++编译器会保留基类的对齐字节，如果设计不当的话，可能就会出现很多的空洞，导致内存浪费激增。之所以保留对齐字节，考虑如下的情况：
```cpp
class Concrete1 {
public:
    // ...
private:
    int val;
    char bit1;
};

class Concrete2 : public Concrete1 {
public:
    // ...
private:
    char bit2;
};

class Concrete3 : public Concrete2 {
public:
    // ...
private:
    char bit3;
};
```
对于类 `Concrete2` 来说，可以把它的成员 `bit2` 合并到前面的对齐空洞处，这可以节约不少的内存，特别是到了 `Concrete3` 处。但实际上 `Concrete3` 的大小高达16个字节。这是由于考虑了以下的拷贝行为：
```cpp
Concrete1 *p1 = new Concrete1, *p2;
Concrete2 c2 = new Concrete2;
p2 = reinterpret_cast<Concrete1 *>( c2 );
*p1 = *p2;
```
如果把 `bit2` 合并到空洞处，编译器会把这个成员一并拷贝过去，这是错误的。

### 加上多态
当需要处理坐标点，并且无论是2D点还是3D点都可以顺利进行的时候，就需要用到虚函数：
```cpp
class Point2d {
public:
    Point2d( float x = 0.0, float y = 0.0 )
        : _x( x ), _y( y ) { };

    float x() { return _x; }
    float y() { return _y; }

    virtual float z() { return 0.0 };
    virtual void z( float ) { };

    virtual void operator+=( const Point2d &rhs )
    {
        _x += rhs.x();
        _y += rhs.y();
    }
    // ... more members

protected:
    float _x, _y;
};

class Point3d : public Point2d {
public:
    Point3d( float x = 0.0, float y = 0.0, float z = 0.0 )
        : Point2d( x, y ), _z( z ) { };

    float z() { return _z; }
    void z( float newZ ) { _z = newZ; }

    void operator+=( const Point2d &rhs ) {
        Point2d::operator+=( rhs );
        _z += rhs.z();
    }
    // ... more members
protected:
    float _z;
};
```
虚函数的使用为程序设计带来的前所未有的弹性，但这是以时空上的开销为代价的：
- 引入了一个虚函数表，一般占用的槽位数就是虚函数的个数，外加一两个用来支持运行时类型识别
- 为了索引虚函数表，带入vptr
- 为了设置vptr，需要加强构造函数
- 相反地，也需要加强析构函数来清理vptr

这里涉及到vptr应该放在一个类的什么位置的问题，如果放在最后，可以保证与C语言结构体成员访问的兼容性；如果放在前面的话，通过vptr调用虚函数会方便很多，因为不用维护偏移量了。

### 多重继承
考虑以下的继承关系：
```cpp
class Point2d {
public:
    // ...
protected:
    float _x, _y;
};

class Point3d : public Point2d {
public:
    // ...
protected:
    float _z;
};

class Vertex {
public:
    // ...
protected:
    Vertex *next;
}

class Point3dVertex : public Point3d, public Vertex {
public:
    // ...
protected:
    float mumble;
};
```
当出现这样的多重继承时，如果按照继承顺序来布局，并且把基类放在最前面，那么 `Point3d` 跟 `Point3dVertex` 指针地址的转换就是很自然的。但是 `Vertex` 和 `Point3dVertex` 的转换就需要加上偏移量。另外，加上偏移量还会带来一些问题，比如从 `Point3dVertex` 指针转换为 `Vertex` 指针但是前者是空指针，显然这里需要对空指针进行特判。

多重继承中的基类布局方式C++标准并没有明确规定。有的编译器会在第一个基类没有vptr而第二个基类有的时候调换它们的顺序，这样可以省下一个vptr，但这项技术没有普及。

### 虚拟继承
多重继承有时候会遇到一个基类有多个实例，但使用中只需要一个实例的情况，这就是虚拟继承的用武之地。一般支持虚继承会把类分成两个部分，一个是不变区域，这就是类自己的部分；一个是共享区域，这里就用来支持虚继承。

最简单的方案就是为每个虚基类都插入一个指针，但是这样的方案有两个缺点：
- 类为支持虚基类付出的负担不是固定的
- 随着虚继承层次的增加，访问的时间会变得更长

对于第二个问题，比较笨拙的解决方案是递归地取得所有虚基类的指针，把它们放进派生类最后面，每个类有一个指针指向它的虚基类部分。不过会带来大量的空间开销。在MetaWare编译器中，可以让程序员选择是否使用“二重指针”。

对于第一个问题，一般来说有两种解决方法：
- 微软使用的是虚基类表的方案，同时引入虚基类指针
- Bjarne支持的方案是把虚基类的位置放在类的最后面，并且在虚函数表中用一个槽位来记录虚基类的偏移量。有些编译器还开发了vptr指向虚基类偏移量和虚函数槽位分界处的方案，这样当使用正数下标就是访问虚函数表，使用负数下标就是访问虚基类。

显然，如果进行虚基类成员的非多态访问，可以由编译器在编译器完成解析，这是高效的。开销主要考虑的是执行期的解析。

书中指出，虚基类使用最有效的一种方式就是抽象虚基类，没有数据成员。

## 对象成员的效率
考虑聚合、封装和继承三种方式的引发的额外负荷大小。根据书中的测试结果，开启优化时，对于三个 `float` 类型的 `x` 、 `y` 、 `z` 三个变量来说，无论是直接放在数组中，还是放在结构体中直接访问，或者是放在类中用内联函数返回引用，甚至是使用getter和setter，性能上都完全相同。所以在编译器的优化下，封装不会带来任何额外的开销。

然后测试继承对于性能的影响，依然是使用 `Point1d` 、 `Point2d` 、 `Point3d` 这样的模型。分别考虑单继承、从 `Point1d` 到 `Point2d` 使用虚拟继承、从 `Point2d` 到 `Point3d` 也使用虚拟继承，这三种情况。测试结果表明，优化开启时，单继承对性能没有影响，因为访问在编译器就已经被解析（有趣的是，关闭优化的时候，使用内联函数的访问比直接访问要慢）；而虚继承的性能很差，即使对 `Point1d` 的成员访问是通过非多态对象进行的，这几乎没有被编译器处理。

## 指向数据成员的指针
对于类内的成员，对它们取偏移量得到的结果总是预期的值加上1，这是为了区别空指针和指向首个成员的指针：
```cpp
class Point3d {
public:
    float x, y, z;
};

float Point3d::*p1 = 0;
float Point3d::*p2 = &Point3d::x;
```
显然这两个指针不应该是相等的，所以把所有的成员指针都增加了1。在遇上多重继承的时候，使用成员指针会相当的复杂，特别是当需要一个多重继承的派生类成员指针却传入一个位于继承列表后方的基类成员指针时，这里的指针就必须经过某种转换。

### 指向成员的指针的效率问题
考虑以下的代码：
```cpp
// 1
pB.x = pA.x - pB.x;
pB.y = pA.y - pB.y;
pB.z = pA.z - pB.z;

// 2
float *ax = &pA.x, *ay = &pA.y, *az = &pA.z,
    *bx = &pB.x, *by = &pB.y, *bz = &pB.z;
*bx = *ax - *bx;
*by = *ay - *by;
*bz = *az - *bz;

// 3
float Point3d::*px = &Point3d::x;
float Point3d::*py = &Point3d::y;
float Point3d::*pz = &Point3d::z;
pB.*px = pA.*px - pB.*px;
pB.*py = pA.*py + pB.*py;
pB.*pz = pA.*pz + pB.*pz;
```
不开启优化的情况下，情况2比起情况1来说慢了一倍（原因不懂，可能是因为指针解引用需要先读入指针？），而情况3需要对offset进行修正，性能则又差了许多。不过开启优化的情况下，三种情况的性能都是一样的。

然后来看看继承对于成员指针性能的影响，仍然使用前面的 `Point1d` 、 `Point2d` 和 `Point3d` 的模型。测试结果显示，单继承在优化情况下对性能没有影响，而虚拟继承由于每次访问都需要先取虚基类指针，性能则差了许多。

<br><br>

# 函数语意学
本章探究当一个对象的函数被调用时，会发生什么。

## 成员的各种调用方式
最早的时候只有非静态成员函数，后来引入了虚函数，最后被引入的是静态函数。

### 非静态成员函数
C++的设计准则中，希望调用非静态成员函数和调用类外的函数相比，不会带来什么额外开销。实际上编译器会把成员函数转换成非成员的模式，一般通过如下转换步骤：
- 改写函数原型，安插一个 `this` 指针的参数（如果是 `const` 成员函数，则这个参数是底层 `const` 的）
- 对类内成员的访问改写为通过 `this` 指针访问
- 把该函数写到类外，通过 `name-mangling` 来保证名字的唯一性
- 将所有该函数的调用改为调用转换后的函数

#### 名称的特殊处理（name-mangling）
类内的成员名称会被编译器进行特殊处理来唯一化，一般来说会加上类的名称，然而仅这种程度，在函数重载的时候还是会冲突，可以同时把函数参数编码进去，这样就可以保证唯一性了。

### 虚函数
如果通过一个指针来调用虚函数，会被转换成通过vptr的一次调用，因为编译器并不知道实际指向的对象是哪个类的对象。vptr在类中也会被 `name-mangling` ，因为有时候类中并不只有一个vptr。通过一个类对象或者是类作用域运算符来调用虚函数，则不需要经过vptr，跟调用非静态成员函数是一样的。

### 静态成员函数
早期的C++还没有静态成员函数，但是却有静态数据成员，如果这个成员不希望暴露出来，就得声明为 `private` 的，但此时就必须通过某个接口来存取这个成员。然而普通的成员函数都需要绑定到某个对象上，这本身是非常怪异的行为，甚至出现了这样的代码：
```cpp
// 这里的0是提供一个虚假的this指针，因为object_count()不会操作非静态成员，这不会有问题
((Point3d *) 0 )->object_count();
```
所以引入了静态成员函数，因为它没有 `this` 指针的参数，就具有如下特性：
- 不能直接存取非静态成员
- 不能声明为 `const` 、 `volatile` 或 `virtual`
- 不用通过对象来调用，虽然也可以

有时候可能通过函数返回的对象来调用静态成员函数，如：
```cpp
foo().object_count();
```
这时候， `foo()` 的返回和 `object_count()` 的调用实际上没有什么关系，但是C++仍然会对 `foo()` 进行求值运算，保证它的副作用实现。

不同于普通的函数成员，如果对它调用 `&` 运算符，得到的是一个普通函数指针，即其在内存中的地址，而不是一个表示偏移量的成员指针。

## 虚函数
为了支持虚函数的机制，需要有某种方式可以在执行期判断对象的具体类型。最简单的实现方法是把这些信息施加于指针之上，这样指针将同时有如下两种信息：
- 指向对象的地址
- 对象类型的某种编码

然而这样的方案带来了两个问题：
- 明显增加了指针的空间负担，哪怕没有用到多态
- 破坏了与C语言的兼容性

或许可以把这些信息放在对象的内部，然而不是所有类都用得到多态信息，放在这些类中不仅增加开销，也破坏和C的兼容性。实际上，仅对于多态的类对象来说，可以增加两个成员：
- 一个字符串或数字，表示类的类型
- vptr

单继承中，一个类只会有一个虚函数表，表中放置的是活跃虚函数，它们包括：
- 当前类定义的函数实例，可能重写了基类的虚函数
- 继承的虚函数
- 纯虚函数（被调用时会导致程序终止）

如果一个类派生了一个具有虚函数的基类，可能会发生：
- 它直接继承对应的虚函数，即直接从基类的虚函数表拷贝到派生类对应的槽位中
- 它重写虚函数，同样放进对应的槽位中
- 它新增一个虚函数，这要求扩展虚函数表增添新的槽位

在单继承的模式下，这个机制运行得相当良好。

### 多继承下的虚函数
除了继承列表中第一个被继承的基类以外，对于剩下的基类的支持有颇大的难度。首先多态的指针绑定就需要特殊处理，如以下代码：
```cpp
Base2 *pbase2 = new Derived;
```
由于 `Base2` 并没有被放在 `Derived` 类的开头，这里的地址就需要一些转换：
```cpp
Derived *temp = new Derived;
Base2 *pbase2 = temp ? temp + sizeof( Base1 ) : 0;
```
而如果需要通过基类的指针来析构这个对象的话：
```cpp
delete pbase2;
```
这就需要回向的转换，使其能够指向完整的对象，这也只能在执行期进行。然而这样的转换所需的代码应该被插入到哪里呢？Bjarne一开始使用的方案是，在虚函数表的每一个槽位中增加一个偏移量，它们被设置成正确的值，当该虚函数被调用时，把 `this` 指针加上这个偏移量传入。但是这样会给那些不需要修改 `this` 指针的虚函数带来不必要的开销。

还有一种名为 `thunk` 的技术，它用一小段汇编代码完成两个工作，先调整 `this` 指针，然后跳转到虚函数中，伪代码如下：
```cpp
phase2_dtor_thunk:
    this += sizeof( Base1 );
    Derived::Derived( this );
```
这项技术仅在需要的时候被使用，但是需要是汇编形式才有足够的效率。

同一个函数可能会被通过不同的指针来调用，这意味着可能需要不同的槽位调用到同一个函数，比如：
```cpp
Base1 *pbase1 = new Derived;
Base2 *pbase2 = new Derived;

delete pbase1;
delete pbase2;
```
多继承中，一个派生了n个基类的派生类，它将会有n个虚函数表，其中第一个基类的虚函数就是整个派生类的虚函数表，后面基类的虚函数表是额外的。所以通过第一个基类的指针来调用是自然的，通过后面基类的指针来调用可能就需要在虚函数表槽中放置 `thunk` 代码。这些虚函数表往往被提出类本身并且按一定方式修改名称确保唯一性，然而名称解析可能很慢很慢，Sun的编译器尝试把所有的虚函数表连锁成一个，并且通过偏移量来索引后方的虚函数表。

当通过派生类指针来调用第二个及以后的基类继承过来的虚函数时，这个虚函数并不在默认的虚函数表中，需要调整 `this` 指针指向该基类的起始位置：
```cpp
Derived *pder = new Derived;
pder->mumble();
```
另外，在C++的语言扩充性质下，允许虚函数的返回值发生变化，或者返回基类的指针，或者返回派生类的指针。比如：
```cpp
class Base1 {
public:
    virtual Base1 *clone() const;
};

class Base2 {
public:
    virtual Base2 *clone() const;
};

class Derived : public Base1, public Base2 {
public:
    virtual Derived *clone() const;
};
```
这样的情况下，考虑以下的代码：
```cpp
Base2 *pb1 = new Derived;
Base2 *pb2 = pb1->clone();
```
则 `clone()` 的调用实际上返回的是 `Derived` 类型的指针，在赋值之前必须经过恰当的转换。在函数被认为“足够小”的时候，编译器产生函数的两个版本，当需要赋值给 `Base2` 指针的时候，调用的是另一个版本，它在实际返回前做一些转换处理。如果函数并不小，那么可能会在函数中制造多个进入点来处理这种情况。

### 虚继承下的虚函数
书中提到，使用虚继承的情况下，由于类的布局发生了改变，即使是单一虚继承也需要相关的指针转换。在虚继承中要消除 `thunk` 的使用是很困难的。建议不要在虚基类中声明非静态数据成员，否则将会有非常复杂的情况出现。

## 指向成员函数的指针
跟指向数据成员的指针有所不同的是，指向非静态成员函数的指针，实际上存储的就是函数在内存中的位置，而不是偏移量。然而由于需要 `this` 指针，它还是得绑定到某个对象上来调用：
```cpp
double (Point::*coord)() = &Point::x;

// 1
Point pt;
( pt.*coord )();

// 2
Point *p = new Point;
( p->*coord )();
```
对于一个成员函数指针，如果不用于虚函数、多继承、虚基类等情况的话，在编译器的优化下并不带来什么额外的开销。

### 支持指向虚函数的指针
当声明了一个指向虚函数的指针，通过一个类指针来调用时，仍然可以调用到正确的函数。虚函数的地址在编译期是未知的，所以 `&` 实际上返回的是虚函数槽位的索引值。然而这样子就需要区分指针内的值到底是一个函数的地址，还是虚函数槽的索引值。比较简单的方法就是限制虚函数的数量，比如128个之类的。

### 多继承中指向成员函数的指针
为了让指向成员函数的指针也能够支持多继承和虚继承，BS设计了以下结构体：
```cpp
// 用于支持多继承下的成员函数指针
struct __mptr {
    int delta;
    int index;
    union {
        ptrtofunc faddr;
        int v_offset;
    };
};
```
在这样的模型中，如果这个指针指向的一个虚函数，那么 `index` 放置其在虚函数表中的索引值；如果这个指针指向的是一个非虚函数，那么 `faddr` 存储函数的地址，而 `index` 则被设置为-1。然而问题时这样在每次使用指针时，都需要检查该指针的具体类型，开销比较大。微软使用的是 `vcall thunk` 的方案，当指向一个虚函数的时候， `faddr` 存储的是 `thunk` 代码的地址，由这段代码来处理跳转。

另外， `delta` 存储的是 `this` 指针的 `offset` 值。 `v_offset` 存储的是虚基类的 `vptr` 位置，当不使用虚基类的时候这个字段就没有什么用。所有有的编译器在内部甚至同时使用多种不同的结构体，以便节约开销。