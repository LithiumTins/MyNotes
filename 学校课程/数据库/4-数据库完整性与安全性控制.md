# 数据库完整性的概念
指DBMS在任何情况下应该保持数据库的**正确性**、**有效性**和**一致性**
- **广义完整性**：语义完整性、并发控制、安全控制、DB故障恢复等
- **狭义完整性**：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题

以下主要强调狭义完整性，主要通过用户定义的完整性约束来实现，DBMS在数据库更新时，自动检查完整性约束。

## 完整性约束一般形式
用四元组表示： $(O, P, A, R)$
- $O$ ：数据集合——受约束的对象
- $P$ ：谓词条件——具体的约束
- $A$ ：触发条件——检查的时机
- $R$ ：响应动作——不满足约束的处理方式

## 按约束对象分类
- **域完整性约束条件**：对于某一属性的值的约束
- **关系完整性约束条件**：对关系的约束，检查关系中的元组是否满足某种约束条件

## 按约束来源分类
- **结构约束**：由表的数据模型定义的约束，如非空约束、主键约束、外键约束等
- **内容约束**：由用户定义的约束，如检查某一属性的值是否在某一范围内、是否满足某一逻辑表达式等

## 按约束状态分类
- **静态约束**：任何时刻都必须满足的约束。通过域完整性约束和关系完整性约束实现。
- **动态约束**：只有更新时才需要检查的约束，如年龄只能增长，不能减少。通过触发器实现。

<br><br>

# SQL实现静态完整性约束
四元组的 $O$ 为列或者表， $P$ 需要给出， $A$ 默认为每次更新时， $R$ 默认为拒绝更新。

## 域完整性约束
创建表时跟在属性后面的约束条件，如：
```sql
CREATE TABLE Student(
    Sno CHAR(9) CONSTRAINT PK_Student PRIMARY KEY,
    Sname CHAR(20) NOT NULL,
    Sage INT CHECK(Sage > 10 AND Sage < 20) DEFAULT 20
);
```
以下为会用到的关键字：
- **CONSTRAINT**：约束名，便于后续更改或删除
- **PRIMARY KEY**：主键约束
- **NOT NULL**：非空约束
- **UNIQUE**：唯一约束
- **CHECK**：检查约束，如上
- **DEFAULT**：默认值约束
- **REFERENCES**：引用约束
- **ON DELETE CASCADE**：级联删除
- **ON DELETE SET NULL**：当主表该行被删除时，当前属性设置为NULL

## 关系完整性约束
创建表时写在表的最后，如：
```sql
CREATE TABLE SC(
    Sno CHAR(9) CONSTRAINT FK_SC_Sno REFERENCES Student(Sno) ON DELETE CASCADE,
    Cno CHAR(4) CONSTRAINT FK_SC_Cno REFERENCES Course(Cno) ON DELETE CASCADE,
    Grade INT,
    CONSTRAINT PK_SC PRIMARY KEY(Sno, Cno)
);
```
以下为会用到的关键字：
- **CONSTRAINT**：约束名，便于后续更改或删除
- **PRIMARY KEY**：主键约束
- **UNIQUE**：唯一约束
- **CHECK**：检查约束
- **FOREIGN KEY**：外键约束
- **REFERENCES**：引用约束

## 修改约束
```sql
ALTER TABLE Student
ADD CONSTRAINT PK_Student PRIMARY KEY(Sno);
```
除了`ADD`，还可以使用`DROP`、`MODIFY`

## 断言
表示希望数据库总会满足的条件，刚创建时和每次发生更新都会检查该断言，形式为：
```sql
CREATE ASSERTION <断言名> CHECK <条件>;
```

<br><br>

# SQL实现动态完整性约束
四元组的四个元素全部需要给出。

## 触发器
创建的语法为：
```sql
CREATE TRIGGER <触发器名>
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON <表名>
[REFERENCING ...]
[FOR EACH ROW | FOR EACH STATEMENT]
[WHEN <条件>]
BEGIN
    <触发器体>
END;
```
其中`REFERENCING`用于指定别名，如以下四种情况：
- `REFERENCING OLD AS <别名>`
- `REFERENCING NEW AS <别名>`
- `REFERENCING OLD TABLE AS <别名>`
- `REFERENCING NEW TABLE AS <别名>`

<br><br>

# 数据库安全性的概念
指DBMS保证数据库免受非法、非授权用户的使用、泄露、更改或破坏的机制和手段。

## 安全机制
- **自主安全性机制**：存取控制——通过权限在用户间的传递，让用户自主管理数据库安全性
- **强制安全性机制**：通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据
- **推断控制机制**（不做要求）：
    - 防止通过历史信息推断出不应该知道的信息
    - 防止通过公开信息推断出私密信息
- **数据加密存储机制**（不做要求）：通过加密、解密保护数据

## 自主安全性机制
用户从DBA处获得一个账号，DBA赋予账号一定的权限，用户可以自行使用，也可以将权限传递给其他用户。

### 实现方式
用户可以使用DCL定义安全规则，当对数据库进行访问的时候，DBMS会自动检查安全规则，如果不满足则拒绝访问。

### 安全规则
使用四元组表示规则条目： $(S, O, t, P)$
- $S$ ：请求主体——用户
- $O$ ：访问对象
- $t$ ：访问权利
- $P$ ：拥有权利的谓词条件

具体来说有以下几种实现方式：
- **存储矩阵**：用一个矩阵来记录对于某个主体、某个访问对象，具有怎么样的访问权利
- **视图**：通过视图可以限制用户的访问范围，并且可以添加谓词条件

### 权限级别
分为3个级别：
1. 读取
1. 修改
1. 创建和删除表
以上级别1和2统称**关系级别**，级别3称为**账户级别**。更高的还有超级用户。高级别的用户也拥有低级别的权限。

### DCL
- **GRANT**：授予权限
    ```sql
    GRANT <权限列表> 
    ON <对象列表> 
    TO <用户列表> 
    [WITH GRANT OPTION];
    ```
    其中`WITH GRANT OPTION`表示授予的权限可以再授予给其他用户
- **REVOKE**：收回权限
    ```sql
    REVOKE <权限列表>
    ON <对象列表>
    FROM <用户列表>;
    ```
    如果一个用户获得了某个权限并且向下传递了该权限，那么该权限失去时，该用户向下传递的权限也会失去。

## 强制安全性机制
把数据和用户都划分为四个等级，分别为：
- **机密**：Top Secret
- **秘密**：Secret
- **机密**：Confidential
- **公开**：Public

### 访问规则
- 读取：不能访问高等级的数据
- 写入：不能写入低等级的数据（防止泄密）

### 实现方式
对关系模式进行修改：
$$
R(A_1:D_1,C_1,A_2:D_2,C_2,...,A_n:D_n,C_n,TC)
$$
为每个属性增加一个等级属性，并且为整个元组增加一个等级属性。

<br><br>

# 存储过程
预先写好的完成特定功能的代码集，预编译以后存储在数据库中，用户可以传递参数并进行调用。一般有三类：
- **系统存储过程**：由DBMS提供
- **用户存储过程**：由用户定义
- **外部存储过程**：对动态链接库的调用

## 创建存储过程
可以用AS声明为单条语句，也可以用BEGIN END声明为多条语句。语法为：
```sql
CREATE PROCEDURE <存储过程名> 
<参数列表>
BEGIN
    <存储过程体>
END;
```
其中`<参数列表>`的形式为：
```sql
@<参数名> <数据类型> [ = default ] [ OUTPUT ]
```

## 执行存储过程
```sql
DECLARE @<变量名> <数据类型> [ = default ];
EXEC <存储过程名> <参数列表>;
```

## 更改存储过程
```sql
ALTER PROCEDURE <存储过程名>
<参数列表>
BEGIN
    <存储过程体>
END;
```