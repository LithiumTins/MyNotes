# 7 - 压缩列表
压缩列表是列表和哈希的底层实现之一，当列表只包含少量元素，且元素要么是小整数要么是短字符串时，Redis 就会使用压缩列表来实现列表键。例如：
```shell
# 创建一个小列表
redis> RPUSH lst 1 3 5 10086 "hello" "world"
(integer) 6

# 查看列表的底层实现
redis> OBJECT ENCODING lst
"ziplist"
```
另外，当哈希只包含少量元素，且每个元素的键和值都是小整数或短字符串时，Redis 也会使用压缩列表来实现哈希键。如：
```shell
# 创建一个小哈希
redis> HMSET profile "name" "Jack" "age" 28 "job" "Programmer"
OK

# 查看哈希的底层实现
redis> OBJECT ENCODING profile
"ziplist"
```

## 压缩列表的构成
压缩列表的主要目的是为了节约内存，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以保存任意多个节点，每个节点可以保存一个字节数组或整数值。

压缩列表的结构如图：

![压缩列表结构](image/压缩列表结构.png)

其中的字段含义如下：
- zlbytes：`uint32_t` 类型，整个压缩列表占用的字节数
- zltail：`uint32_t` 类型，表尾节点（图中 entryN）距离压缩列表开头的偏移量
- zllen：`uint16_t` 类型，压缩列表节点数量，当实际节点数量达到 65535 以后，这个值保持为 65535，因此需要实际遍历压缩列表才能获得真实的节点数量
- entryX：压缩列表第 X 个节点，长度需要考虑实际保存的内容
- zlend：`uint8_t` 类型，常量值 0xFF，标志着压缩列表的末尾

## 压缩列表节点的构成
每个节点可以保存一个字节数组或一个整数值。字节数组的长度可以是三种情况：
- 小于 64 字节，即 $2^6$ 
- 小于 16384 字节，即 $2^{14}$
- 小于 4294967296 字节，即 $2^{32}$

整数值可以是 6 种情况：
- 4 位长，表示 0-12 的整数（不含 0 和 12）
- 1 字节长的有符号整数
- 3 字节长的有符号整数
- int16_t
- int32_t
- int64_t

每个节点的结构如下：

![压缩列表节点结构](image/压缩列表节点结构.png)

### previous_entry_length
上一个节点有多少个字节，这个字段本身可以有两种长度：
- 1 字节：前一个节点的长度小于 254 字节，长度就放在这个字节里
- 5 字节：前一个节点的长度大于等于 254 字节，第一个字节置为 0xFE(254)，用来指示该字段是 5 字节的，后面 4 个字节保存前一个节点的长度

通过这个字段可以快速定位到前一个节点，从而压缩列表可以支持反向的遍历。

### encoding
指示 content 保存的数据类型和长度，它可以有不同的格式：
- 保存字节数组：可以是 1、2、5 字节长，值的最高两位分别为 00、01、10，content 长度由除去最高两位的其他位保存
- 保存整数：1 字节长，最高两位为 11，整型值的类型和长度由除去最高两位的其他位表示

其中，保存整数时，除去最高两位后的不同值含义如下：
- 000000：`int16_t`
- 010000：`int32_t`
- 100000：`int64_t`
- 110000：24 位有符号整数
- 111110：8 位有符号整数
- 11xxxx：当整数是 0-12 之间的数，它直接存放在 xxxx 中，content 为空

### content
实际存储数据，类型和长度由 encoding 决定。

## 连锁更新
考虑压缩列表中有多个连续的、长度介于 250 到 253 字节之间的节点，此时它们只需要 1 字节的 previous_entry_length。

如果在压缩链表的头部插入一个长度达到 254 字节的节点，则需要增加原来第一个节点的 previous_entry_length 字段的长度。但是这使得原来第一个节点的长度也达到了 254，则原来第二个节点的 previous_entry_length 字段的长度也需要增加，以此类推。这种现象称为连锁更新。

类似的，删除一个节点也可能引起连锁更新。

连锁更新在最坏情况下，需要对压缩列表进行 N 次空间重分配操作，而每次重分配的时间复杂度是 O(N)，所以连锁更新的时间复杂度是 O(N^2)。（这里有点奇怪，理论上只需要计算好每个节点新的长度，而不需要总是实际执行重分配操作）

虽然连锁更新看起来是严重的问题，然而实际应用中却很少因为它产生严重的性能问题：
- 如上所述，压缩列表需要恰好形成特定的结构
- 如果连锁更新涉及的节点数量不多，那么对性能的影响不大，毕竟大量节点连锁更新的条件比较苛刻

综上，实际上 `ziplistPush` 的平均复杂度只有 `O(N)`，不用过多担心性能问题。

## 压缩列表 API
| 函数 | 作用 | 算法复杂度 |
| --- | --- | --- |
| ziplistNew | 创建一个新的压缩列表 | O(1) |
| ziplistPush | 传入一个值，创建新节点并添加到表头或者表尾 | 平均 O(N)，最坏 O(N^2) |
| ziplistIndex | 获取压缩列表中给定索引位置的节点 | O(N) |
| ziplistFind | 查找包含给定值的节点 | O(N)，但如果节点的值是字节数组，在字节数组中还需要做匹配 |
| ziplistNext | 返回给定节点的后一个节点 | O(1) |
| ziplistPrev | 返回给定节点的前一个节点 | O(1) |
| ziplistGet | 获取给定节点保存的值 | O(1) |
| ziplistDelete | 删除给定节点 | 平均 O(N)，最坏 O(N^2) |
| ziplistDeleteRange | 删除给定索引处的多个节点 | 平均 O(N)，最坏 O(N^2) |
| ziplistBlobLen | 获取压缩列表占用的内存字节数 | O(1) |
| ziplistLen | 获取压缩列表目前的节点数量 | 节点数量小于 65535 时 O(1)，否则 O(N) |