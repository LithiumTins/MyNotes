# 11 - AOF 持久化
相对于 RDB 把数据库的键值对存储在文件中，AOF 持久化是把 Redis 服务器执行的写命令追加到文件中。

如执行命令：
```shell
redis> SET msg "hello"
OK
```
将会向 AOF 文件追加：
```
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
```
可以看到，每条操作以 * 开头，然后是指令长度，然后是指令的每个单词的长度和内容，每个部分由 \r\n 分隔。

AOF 文件也可用用于服务器启动时恢复数据。

## 11.1 - AOF 持久化的实现
分为命令追加、文件写入、文件同步三个步骤。

### 11.1.1 - 命令追加
Redis 服务器维护一个缓冲区，每次执行写命令后，它把命令追加到缓冲区：
```
struct redisServer {
    // ...
    // AOF 缓冲区
    sds aof_buf;
    // ...
};
```

### 11.1.2 - AOF 文件的写入与同步
Redis 服务器进程始终在执行事件循环，伪代码如下：
```python
def eventLoop():
    while True:
        # 如果有写入，追加到 AOF 缓冲区
        processFileEvents()
        
        processTimeEvents()

        # 考虑是否把 AOF 缓冲区的内容写入到 AOF 文件
        flushAppendOnlyFile()
```
`flushAppendOnlyFile()` 的行为通过服务器配置的 appendfsync 选项决定：
- always：写入并同步文件
- everysec（默认）：写入文件，如果距离上次同步超过 1 秒，同步文件
- no：写入文件，不显式同步文件，具体写回磁盘时间由操作系统决定

## 11.2 - AOF 文件的载入与数据还原
Redis 通过 AOF 还原数据库的过程：
1. 创建一个不带网络连接的伪客户端
1. 从 AOF 文件读取命令
1. 请求服务器执行命令
1. 重复上面两个步骤直到文件末尾

## 11.3 - AOF 重写
如果把所有的写命令都追加到 AOF 文件，文件会越来越大。为了解决这个问题，Redis 提供了 AOF 重写机制。通过这个机制，Redis 重新生成一个 AOF 文件，只考虑数据库的当前状态，从而缩减 AOF 文件的大小。

### 11.3.1 - AOF 文件重写的实现
比如经过一系列写操作以后，一个 list 键中的元素为 C、D、E、F、G，则可以使用一条命令替换这些写操作：
```shell
redis> RPUSH list C D E F G
```
不过，单条指令的指令单元数量是有限制的，由 redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD 定义，当前是 64。因此，如果需要的指令过长，可能会拆成多条指令。

### 11.3.2 - AOF 后台重写
AOF 重写需要向新文件中执行大量的写入操作，为了避免阻塞 Redis 主进程，这个过程被放进一个子进程中执行。问题在于父进程可能还在执行写操作，从而重写后的文件可能相对落后。

为了解决这个问题，Redis 设置了一个 AOF 重写缓冲区，当执行重写时父进程同时把写命令追加到 AOF 缓冲区和 AOF 重写缓冲区。当子进程完成重写后向父进程发送信号，然后父进程把 AOF 重写缓冲区的内容写入到新文件，重命名新文件来覆盖旧文件。