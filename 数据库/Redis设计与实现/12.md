# 12 - 事件
Redis 服务器是一个事件驱动程序，需要处理两类事件：
- 文件事件：和客户端连接使用的套接字相关的事件
- 时间事件：某些需要在给定时间点执行的任务

## 12.1 - 文件事件
Redis 使用 Reactor 模式，借助 I/O 多路复用来监视多个套接字上的连接应答、读取、写入、关闭等事件。

### 12.1.1 - 文件事件处理器的构成
当 I/O 多路复用程序检测到文件事件以后，通过一个队列向文件事件分派器传送产生事件的套接字。文件事件处理器从其中取出套接字，根据其类型调用相应的事件处理器。

### 12.1.2 - I/O 多路复用程序的实现
Redis 通过包装 select、epoll、kqueue、evport 等多路复用函数库来实现 I/O 多路复用程序，它们分别对应一个单独的文件，如 ae_select.c、ae_epoll.c 等。

实际上 Redis 在这些文件中使用了相同的 API，所以这些底层实现可以互换，编译时会自动选择最适合的实现，导入对应的头文件。

### 12.1.3 - 事件的类型
套接字有 ae.h/AE_READABLE 和 AE_WRITABLE 两种事件类型，分别表示套接字可读和可写。如果同时产生两种事件，Redis 会先处理可读事件。

### 12.1.4 - API
以下接口都在 ae.c 中：
- `aeCreateFileEvent()`：接受一个套接字描述符、一个事件类型、一个事件处理器，把套接字的特定事件加入监听，指定事件发生时调用指定的处理器
- `aeDeleteFileEvent()`：删除套接字的特定事件监听
- `aeGetFileEvents()`：对于给定套接字，返回当前监听的事件类型，返回
    - AE_NONE：没有监听任何事件
    - AE_READABLE：监听可读事件
    - AE_WRITABLE：监听可写事件
    - AE_READABLE | AE_WRITABLE：同时监听可读和可写事件
- `aeWait()`：对于给定套接字，等待给定类型事件，直到事件发生或超时函数返回
- `aeApiPoll()`：接受一个 sys/time.h/struct timeval 指定的超时时间，监听注册的所有事件，当有事件发生或超时返回
- `aeProcessEvents()`：文件事件分派器，调用 `aeApiPoll()` 等待事件，然后调用事件处理器处理事件
- `aeGetApiName()`：返回当前使用的多路复用库的名字，如 "select"、"epoll" 等

### 12.1.5 - 文件事件的处理器
Redis 为文件事件编写了多个处理器，用于不同的网络通信需求。

#### 连接应答处理器
networking.c/acceptTcpHandler 函数，用于应答客户端的连接请求，实现为对 sys/socket.h/accept 函数的封装。

Redis 服务器启动的时候会自动把监听套接字的可读事件加入监听，并关联到 acceptTcpHandler 函数。

#### 命令请求处理器
networking.c/readQueryFromClient 函数，从连接套接字读取客户端发送的命令请求，实现为对 unistd.h/read 函数的封装。

当连接应答处理器建立一个连接以后，会把该套接字的可读事件加入监听，然后关联到 readQueryFromClient 函数。

#### 命令回复处理器
networking.c/sendReplyToClient 函数，将命令执行结果回复给客户端，实现为对 unistd.h/write 函数的封装。

当服务器有回复需要发送给客户端时，会把连接套接字的可写事件加入监听，然后关联到 sendReplyToClient 函数。当客户端准备好接收数据时，可写事件发生，调用 sendReplyToClient 函数发送数据。写入完毕以后就会解除监听。

## 12.2 - 时间事件
时间事件分为两类：
- 定时事件：让程序在指定的时间后执行一次
- 周期性事件：让程序每隔一段时间执行一次

时间事件主要有三个属性：
- id：时间事件的全局唯一 ID
- when：毫秒级 UNIX 时间戳，事件的触发时间
- timeProc：事件处理器，事件触发时调用

程序通过事件处理器的返回值来判断时间是定时的还是周期的：
- 如果返回 ae.h/AE_NOMORE，则表示不再重复
- 如果返回其他整数值，则该值被用于更新事件的 when 属性

当前 Redis 只使用周期性事件。

### 12.2.1 - 实现
所有时间事件被放在一个无序链表中，每次事件循环都会遍历链表，查看是否有事件需要执行。实际上它们是按照 id 形成倒序的，但是这对检查时间事件没有什么帮助。

当前，正常模式下的 Redis 服务器只使用 serverCron 一个时间事件；benchmark 模式下只使用两个时间事件。从而无需链表对性能没有什么影响。

### 12.2.2 - API
以下接口都在 ae.c 中：
- `aeCreateTimeEvent()`：接受一个毫秒数、一个事件处理器，创建一个时间事件，它在给定毫秒数后触发事件处理器
- `aeDeleteTimeEvent()`：删除一个时间事件
- `aeSearchNearTimer()`：返回距离当前时间最近的时间事件
- `aeProcessTimeEvents()`：遍历所有时间事件，对于超时的事件调用事件处理器

### 12.2.3 - 时间事件应用实例：serverCron 函数
redis.c/serverCron 函数会定期检查服务器自身的状态，确保服务器长期稳定运行，它的工作包括：
- 更新服务器的各类统计信息
- 清理数据库过期键值对
- 关闭和清理连接失效的客户端
- 尝试执行 AOF 和 RDB 持久化操作
- 如果服务器是主服务器，对服务器进行定期同步
- 如果处于集群模式，对集群进行定期同步和连接测试

在 Redis 2.6，它默认每秒运行 10 次；从 Redis 2.8 开始，可以通过 hz 配置项调整每秒运行次数。

## 12.3 - 事件的调度与执行
ae.c/aeProcessEvents 每次获取距离现在最近的时间事件，计算剩余超时时间，然后把它作为 aeApiPoll 的超时时间，等待文件事件或时间事件发生。当函数返回，尝试处理文件事件，再尝试处理时间事件。

通常，事件处理器会避免自己阻塞太久，从而会设置单次最大传输字节数等等限制，剩余的数据会在下次调用时继续处理。

由于这样的模型，时间事件通常会比预设的时间滞后一些。