# 1 - 认识分布式系统

## 1.1 - 什么是分布式系统
分布式系统是一个其组件分布在不同的、联网的计算机上，组件之间通过传递信息进行通信和协调，共同完成一个任务的系统。

分布式系统的设计关键是如何协调这些计算机来共同完成任务。虽然分布式系统的计算机是离散的，但在客户看来，它们可以视作同一台计算机。

因此，分布式系统通常有如下特点：
- 多进程，分布式系统中总是有多个进程并发运行
- 不共享操作系统，机器之间通过网络交换信息来协作
- 不共享时钟，因此多个机器对时间的认知可能有偏差，很难通过时间来定义两个事件的先后

## 1.2 - 为什么需要分布式系统
相比于单机，分布式系统有一些显著的优点：
- 高性能：由于硬件工艺的限制，单 CPU 的性能很早就达到了瓶颈。后面衍生出多核 CPU 的方案，但通过物理总线等方式来连接多个 CPU，随着 CPU 数量的增加成本也迅速提高。从而互联网企业按照多核 CPU 架构的思想，通过网络把多台廉价计算机连接起来，形成了分布式系统。
- 可扩展性：很多需求都是数据密集型的，随着数据的增长，单机的扩展能力非常有限。通过构建数据分布在多台计算机上的分布式存储系统，集群规模可以扩展到非常庞大的规模。
- 高可用性：如今很多服务要求 7x24 小时不间断提供服务，比如可能要求 99.999% 的可用性，从而一年之内平均只能停机 5 分钟。在单机上，由于硬件故障、人为因素或其他原因，这几乎是不可能实现的。而分布式系统通过冗余数据保证数据可用性，通过冗余计算保证故障时服务切换，都是非常常见的。
- 必要性：有些时候，业务在地理上分布在多个位置，分布式系统几乎是不可避免的。

## 1.3 - 分布式系统的示例
有非常多分布式系统的应用，如电子银行、多人在线游戏、视频会议、社交网络和点对点网络等。不同的应用可能需要不同的架构，从而分布式系统有非常多种架构。以下列举两个具有代表性的案例。

### 1.3.1 - 搜索引擎
搜索引擎是把多种分布式系统有机结合到一起的典型软件工程。

考虑当在 Google 搜索一个关键词时，有哪些分布式系统参与处理。

首先，DNS 把域名解析为 IP 地址。DNS 就是一个存储域名到 IP 地址映射的分布式数据库，主要特点是去中心化、可扩展性和健壮性，它能很好处理负载和故障。

除此之外，Google 在支持搜索和其他应用的分布式基础设施上做了巨大的努力，它们包括：
- 全球化、巨大的多数据中心，分布的单个数据中心就可以有数万台服务器。
- 分布式文件系统 GFS（Google File System），目前已经升级到 2 代
- 高性能、可扩展、存储大规模结构化数据的存储系统 Bigtable，它是非关系性数据库，更像 NoSQL 数据库，优势在于扩展性和查询性能
- 分布式锁服务 Chubby
- 并行和分布式计算的编程模式 MapReduce
- 分布式数据库 Spanner

可以看到，搜索一个关键词就牵动了许多的分布式系统。Google 借助它们构建了一套相当复杂的，全球高可用、高可扩展、高性能的基础架构，如下图所示：

![Google分布式架构](image/Google分布式架构.png)

### 1.3.2 - 加密货币
以比特币为例，从分布式系统的角度来看，它首次实现和验证了一种实用的、去中心化和拜占庭容错的共识算法，打开了通过区块链新时代的大门。

## 1.4 - 分布式系统的挑战
分布式系统同时也带来不少设计上的挑战。Leslie Lamport 指出：“分布式系统是指一台你根本不知道其存在的计算机发生了故障，会导致你自己的计算机无法使用。” 因此，分布式系统常常会面临许多棘手的问题。

上世纪 90 年代，L.Peter Deutsch 等人根据 Sun 公司内部出现的问题总结了分布式计算的常见认知谬误：
- 网络是可靠的
- 延迟为 0
- 带宽是无限的
- 网络是安全的
- 拓扑结构不会改变
- 只有一个管理员
- 传输成本为 0
- 网络是同构的

以上任何一个错误的假设都可能带来严重的问题。我们重点关注前两条，它们可以归结为网络延迟问题。实际上，还有两个常见的问题，即部分失效问题和时钟问题。

### 1.4.1 - 网络延迟问题
分布式系统的多个节点通过网络通信，但网络传输是不可靠的，因此可能遇到：
- 信息丢失
- 以为信息丢失，实际上只是延迟到达
- 重传信息使得对方收到重复信息
- 以为某个服务已经故障，实际上是消息延迟
- 消息没有按序到达，或者不同机器接收到的消息顺序不同

### 1.4.2 - 部分失效问题
单机上的程序要么正常工作，要么出现问题。

分布式系统中，可能出现一部分机器正常工作，一部分机器出现问题的情况（或者由于网络问题无法和它们交互）。这就称为部分失效。

难点在于不确定性。系统有时候可能正常工作，有时候可能出现问题。甚至有时都很难确定系统是否出现问题。

因此这样的问题是很难调试的。并且当有些服务要求原子性，如果某个节点不成功，所有节点都不能成功，部分失效会给设计带来很大的挑战。

### 1.4.3 - 时钟问题
单机中只有一个时钟，时间的先后就表示事件发生的先后。分布式系统中，每个机器有自己的时钟，时钟的偏差使得时间的参考性下降，从而很难确定各个事件的先后顺序。

一种常见的解决方式是，通过一个时间服务器同步时间。然而由于网络延迟的可变性，同一时间发出的信息可能在不同机器上到达的时间不同，从而导致同步后的时间也可能偏差。另一种解决方法，像 Google 构建的 TrueTime API，让应用能生成单调递增的时间戳，但这通常需要使用昂贵的原子钟和精心设计的系统。最普遍的方式是 Leslie Lamport 提出的逻辑时钟方案。

## 1.5 - 每个程序员都应该知道的数字
Jeff Dean 在 2009 年对计算机的各类操作的耗时做了大致估计，如下表给出：

| 操作 | 延迟 |
| --- | --- |
| 执行一个指令 | 1 ns |
| L1 缓存查询 | 0.5 ns |
| 分支预测错误 | 5 ns |
| L2 缓存查询 | 7 ns |
| 互斥锁/解锁 | 25 ns |
| 主存访问 | 100 ns |
| 使用 Zippy 算法压缩 1KB 的数据 | 3,000 ns |
| 在 1Gbps 的网络上发送 2KB 的数据 | 20,000 ns |
| 从内存顺序读取 1MB 的数据 | 250,000 ns |
| 同一个数据中心往返 | 500,000 ns |
| 磁盘寻址 | 10,000,000 ns |
| 从磁盘顺序读取 1MB 的数据 | 20,000,000 ns |
| 数据包往返美国到欧洲 | 150,000,000 ns |

不过随着计算机发展，这些数据有些过时，下表给出了 2020 年的版本：

| 操作 | 延迟 |
| --- | --- |
| 执行一个指令 | 1 ns |
| L1 缓存查询 | 0.5 ns |
| 分支预测错误 | 3 ns |
| L2 缓存查询 | 4 ns |
| 互斥锁/解锁 | 17 ns |
| 主存访问 | 100 ns |
| 使用 Zippy 算法压缩 1KB 的数据 | 2,000 ns |
| 从内存顺序读取 1MB 的数据 | 3,000 ns |
| SSD 随机读 | 39,000 ns |
| 从 SSD 顺序读取 1MB 的数据 | 49,000 ns |
| 同一个数据中心往返 | 500,000 ns |
| 从磁盘顺序读取 1MB 的数据 | 718,000 ns |
| 磁盘寻址 | 2,000,000 ns |
| 数据包往返美国到欧洲 | 150,000,000 ns |

可以看到，提升显著的是 SSD 和磁盘的顺序读取速度。