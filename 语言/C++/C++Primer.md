# 变量和基本类型

## 基本内置类型

### 算术类型
标准规定了算数类型的最小尺寸：
类型 | 含义 | 最小尺寸
---|---|---
bool | 布尔类型 | 未定义
char | 字符 | 8位
wchar_t | 宽字符 | 16位
char16_t | Unicode字符 | 16位
char32_t | Unicode字符 | 32位
short | 短整型 | 16位
int | 整型 | 16位
long | 长整型 | 32位
long long | 长整型 | 64位
float | 单精度浮点数 | 6位有效数字
double | 双精度浮点数 | 10位有效数字
long double | 扩展精度浮点数 | 10位有效数字

还有一些其他的规定，如：
$$
sizeof(short) \leq sizeof(int) \leq sizeof(long) \leq sizeof(long\ long)
$$

标准对于浮点类型的精度限制较为宽松，一般来说， `float` 支持7位有效数字， `double` 则支持16位有效数字。

#### 带符号类型和无符号类型
除了布尔型和字符型，其他的整型都分为带符号类型和无符号类型。默认情况下是带符号的，前面加 `unsigned` 则是无符号的。然而 `char` 就有三种，分别是 `char` 、 `signed char` 和 `unsigned char` ，单独的 `char` 并没有规定是带符号还是无符号。

### 类型转换
- 非 `bool` 赋值给 `bool` 时， `0` 转换为 `false` ，其他值转换为 `true`
- `bool` 赋值给非 `bool` 时， `false` 转换为 `0` ， `true` 转换为 `1`
- 浮点赋值给整型，只保留整数部分
- 整型赋值给浮点，保留整数部分，小数部分为 `0` ，如果超出浮点数的精度范围，那么会有精度损失
- 把过大的数赋值给无符号类型，得到的是取模后的结果
- 把超出范围的数赋值给带符号类型，结果是**未定义**的

#### 含有无符号类型的表达式
如果表达式中同时有带符号类型和无符号类型，那么带符号类型会转换为无符号类型。这可能导致负数转换成无符号类型，尽量避免混用带符号类型和无符号类型。

### 字面值常量
像 `42` 这样的，一看就知道其取值，称作字面值常量。

#### 整型和浮点型字面值
整型值可以是十进制、八进制、十六进制的，如20的三种表示形式：
```cpp
20      // 十进制
024     // 八进制
0x14    // 十六进制
```
十进制的字面值实际类型是带符号的，八进制和十六进制的字面值实际类型可能带符号也可能不带符号。十进制字面值的类型在 `int` 、 `long` 和 `long long` 中选取，八进制和十六进制的字面值的类型在 `int` 、 `unsigned int` 、 `long` 、 `unsigned long` 、 `long long` 和 `unsigned long long` 中选取。会采用能够容纳其值的最小的类型来存储。如果放不下，那么会报错。

浮点型字面值有如下形式：
```cpp
3.14159
3.14159E0
0.
0e0
.001
```

#### 字符和字符串字面值
像 `'a'` 这样的，称作字符字面值。像 `"Hello, World!"` 这样的，称作字符串字面值。当两个字符串字面值放在一起时，如：
```cpp
"Hello, " "World!"
```
它们实际上等价于 `"Hello, World!"` ，所以字符串过长时可以分行写。

#### 转义序列
表示 | 含义
--- | ---
`\n` | 换行
`\t` | 横向制表符
`\v` | 纵向制表符
`\a` | 响铃
`\b` | 退格
`\r` | 回车
`\"` | 双引号
`\'` | 单引号
`\\` | 反斜杠
`\?` | 问号
`\f` | 进纸符

可以使用泛化的转义序列，即用字符的ASCII码来表示字符，如：
- `'\7'` ：不加x则为八进制，不超过3个数字，否则截取前3个。响铃符
- `'\x4d` ：加x则为十六进制。字母M

#### 指定字面值的类型
加上特定的前缀和后缀，可以不使用字面值的默认类型，如字符和字符串字面量有：
| 前缀 | 含义 | 类型 |
--- | --- | ---
u | Unicode16字符 | char16_t
U | Unicode32字符 | char32_t
L | 宽字符 | wchar_t
u8 | UTF-8字符 | char

整型字面值有（其中也可以组合UL表示 `unsigned long` ）：
| 后缀 | 含义 | 类型 |
--- | --- | ---
u 或 U | 无符号 | unsigned
l 或 L | 长整型 | long
ll 或 LL | 长长整型 | long long

浮点型字面值有：
| 后缀 | 含义 | 类型 |
--- | --- | ---
f 或 F | 单精度浮点数 | float
l 或 L | 扩展精度浮点数 | long double

#### 布尔字面值
`true` 和 `false` 是布尔类型的字面值。

## 变量
具名的、可供程序操作的存储空间，在本书中与**对象**一词等价。

### 变量定义

#### 列表初始化
在C++11以后，对于一个 `int` 类型的变量，有以下四种初始化方式：
```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
```
其中使用花括号的初始化方式称为列表初始化，对于内置类型来说，如果存在丢失信息的风险，这种初始化方式将会出错。

#### 默认初始化
如果不指定初始值，称为进行了默认初始化。内置类型，对于全局变量，会被初始化为0；对于局部变量，不会被初始化，其值是未定义的。

### 变量声明和定义的关系
为了允许把程序拆分成多个逻辑部分进行开发，C++支持**分离式编译**，即程序可以被分割成多个文件，每个文件单独进行编译。为此，C++将声明和定义区分开来，声明使得名字为程序所知，定义负责创建与名字关联的实体，变量只能定义一次而可以声明多次。只声明而不定义一个变量的方法是使用 `extern` 关键字：
```cpp
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```
然而，任何声明只要赋予了初始值，就是定义，比如这里的 `extern` 就没有任何作用：
```cpp
extern int i = 0; // 定义
```
在函数体内部，试图初始化一个由 `extern` 关键字标记的变量是非法的。

### 标识符
C++的标识符是由字母、数字、下划线组成，必须以字母或下划线开头。标识符是大小写敏感的。C++保留了一些标识符用作关键字：
| 列1 | 列2 | 列3 | 列4 | 列5 |
| --- | --- | --- | --- | --- |
| alignas | continue | friend | register | true |
| alignof | decltype | goto | reinterpret_cast | try |
| asm | default | if | return | typedef |
| auto | delete | inline | short | typeid |
| bool | do | int | signed | typename |
| break | double | long | sizeof | union |
| case | dynamic_cast | mutable | static | unsigned |
| catch | else | namespace | static_assert | using |
| char | enum | new | static_cast | virtual |
| char16_t | explicit | noexcept | struct | void |
| char32_t | export | nullptr | switch | volatile |
| class | extern | operator | template | wchar_t |
| const | false | private | this | while |
| constexpr | float | protected | thread_local | |
| const_cast | for | public | throw | |

还有一些操作符替代名，似乎会被宏替换成操作符，有：
| 列1 | 列2 | 列3 | 列4 | 列5 | 列6 |
| --- | --- | --- | --- | --- | --- |
| and | bitand | compl | not_eq | or_eq | xor_eq |
| and_eq | bitor | not | or | xor | |

### 名字的作用域
定义在所有花括号外的名字具有**全局作用域**，否则具有**块作用域**。

### 嵌套作用域
作用域可以包含在其他的作用域之中，被包含的称为**内层作用域**，包含的称为**外层作用域**。内层作用域可以重新定义外层作用域的名字，再次使用这个名字时，实际上访问的是内层作用域中的名字。

## 复合类型
指基于其他类型定义的类型，包括引用和指针。

### 引用
是对象的别名，实际不是一个对象。它绑定到一个对象上，不可以更改绑定的对象。

### 指针

#### 空指针
有几种可以获取空指针的方法：
```cpp
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; // 需要包含cstdlib
```
`nullptr` 是C++11引入的，是一种特殊的指针类型，可以转换成任意指针类型。在新标准下，尽量使用 `nullptr` 代替 `0` 和 `NULL` 。

## const限定符

#### 默认状态下，const对象仅在文件内有效
对于一个const对象，编译器往往把它们的所有出现替换成它的初始值，为了做到这一点，编译器需要知道这个对象的定义，所以const对象默认情况下只在文件内有效。如果需要一个行为类似于常规对象的const对象，需要在声明和定义的时候都加上 `extern` 关键字。

### const的引用
引用可以绑定到const对象上：
```cpp
const int ci = 1024;
const int &r1 = ci;
```

#### 初始化和对const的引用
一般来说，引用的类型需要与赋值给它的对象类型一致。实际上有两个例外：
- 初始化常量引用时，还可以使用表达式的计算结果，编译器会创建一个临时量
    ```cpp
    const int &r = 42;```
- const引用可以绑定到一个普通的变量上，这时不可以通过引用 `r` 来修改 `i` 的值
    ```cpp
    int i = 42;
    const int &r = i;
    ```

### 指针和const
指向常量的指针，不能使用该指针来修改指向的对象。常量指针，不允许改变其指向的对象。

### 顶层const
顶层const表示指针本身是个常量，底层const表示指针所指的对象是个常量。它们的声明方式不同：
```cpp
const int *p; // 底层const
int *const p; // 顶层const
```

### constexpr和常量表达式
常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。

#### constexper变量
C++11引入了 `constexpr` 关键字，用于声明变量或函数是常量表达式，编译器会检查它的初始值是否是一个常量表达式。普通的函数返回值不是常量表达式，只有 `constexpr` 函数才能返回常量表达式。

#### 字面值类型
常量表达式的值需要在编译器计算，所以对于 `constexpr` 可以修饰类类型需要加以限制，因为它们的类型简单、值容易得到，这种类型称为**字面值类型**。算术类型、引用和指针都是字面值类型。类类型一般不是字面值类型，但存在一些特例。

虽然指针和引用都可以用 `constexpr` 修饰，然而 `constexpr` 指针的初始值只能是 `nullptr` 或者 `0` ，或者存储在某个固定地址中的对象（创建在函数体内的对象使用栈空间，不是固定地址的；全局变量和静态变量的地址是固定的）。 `constexpr` 只对当前语句声明的指针有效，并不意味着指向的对象是const的，如果要指向const对象，需要：
```cpp
const int i = 5;    // 全局变量（满足constexpr的要求）
constexpr const int *p = &i;
```

## 处理类型

### 类型别名
有两种方式创建类型别名：
```cpp
// 使用关键字typedef
typedef double wages;       // wages是double的同义词
typedef wages base, *p;     // base是double的同义词，p是double*的同义词

// C++11引入了别名生命
using SI = Sales_item;      // SI是Sales_item的同义词
```

#### 指针、常量和类型别名
使用类型别名时，并不总是等效于把类型别名换成它所表示的类型后的结果。比如：
```cpp
typedef char *pstring;
const pstring cstr = 0; // 这里是顶层const
const pstring *ps;      // 这里是底层const
```
也就是说，这里的 `const` 是修饰 `pstring` 的，然而替换回原类型的话：
```cpp
const char *cstr = 0;
```
这条语句和上面的声明是不等价的。

### auto类型说明符
C++11引入了 `auto` 关键字，可以自动推断对象的类型，如：
```cpp
auto item = val1 + val2;    // item的类型就是val1和val2相加的结果的类型
```
一条语句也可以声明多个变量，要求基本类型一致，如：
```cpp
auto i = 0, *p = &i;        // 正确：i是整数，p是整型指针
auto sz = 0, pi = 3.14;     // 错误：基本类型不一致
```

#### 复合类型、常量和auto
有两种情况 `auto` 获得的类型和原类型不一样：
- 引用会被忽略
    ```cpp
    int i = 0, &r = i;
    auto a = r;             // a是一个整数

    const auto a1 = r;      // 显式指出a1是一个引用
    ```
- 顶层const会被忽略
    ```cpp
    const int ci = i;
    auto b = ci;            // b是一个整数

    const auto b1 = ci;     // 显式指出b1是一个顶层const
    ```

### decltype类型指示符
C++11引入了 `decltype` 关键字，可以仅获取表达式的类型，而不使用它的值初始化变量，如：
```cpp
decltype(f()) sum = x;      // sum的类型就是函数f的返回类型
```
这里 `f()` 并不会实际被调用。与 `auto` 不同， `decltype` 会保留顶层const和引用，这要求谨慎使用该关键字：
```cpp
int i = 42, *p = &i;
decltype(*p) c = i;         // c是引用
decltype((i)) d = i;        // d是引用
```

## 自定义数据结构

### 定义Sales_data类型

#### 类数据成员
C++11引入了类内初始值，可以为类的数据成员提供一个初始值，可以使用 `=` 或者 `{}` ，但不能使用 `()` 。

### 编写自己的头文件

#### 预处理器概述
为了避免反复包含同一个头文件，可以借助预处理器指令和**预处理变量**来形成**头文件保护符**：
```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
// 头文件内容
#endif
```
预处理变量没有作用域规则，所以在整个程序中必须是唯一的。

<br><br>

# 字符串、向量和数组

## 命名空间的using声明
```cpp
using std::cin;
```

## 标准库类型string

### 定义和初始化string对象
有以下方式可以初始化一个string对象：
```cpp
string s1;              // 默认初始化，s1是一个空串
string s2(s1);          // s2是s1的副本
string s2 = s1;         // 等价于上一条
string s3("value");     // s3是字面值"value"的副本
string s3 = "value";    // 等价于上一条
string s4(10, 'c');     // s4的内容是cccccccccc
```
上面使用了等号的是**拷贝初始化**，其他的是**直接初始化**。

### string对象上的操作
```cpp
os << s;                // 将s写到输出流os中，返回os
is >> s;                // 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s);         // 从is中读取一行赋给s，返回is
s.empty();              // s为空则返回true，否则返回false
s.size();               // 返回s中字符的个数
s[n];                   // 返回s中第n个字符的引用
s1 + s2;                // 返回s1和s2连接后的结果
s1 = s2;                // 用s2的副本代替s1中原来的字符
s1 == s2;               // 如果两个字符串相等则返回true
s1 != s2;               // 如果两个字符串不相等则返回true
s1 < s2;
s1 > s2;
s1 <= s2;
s1 >= s2;               // 字典序比较两个字符串
```

#### 读写string对象
```cpp
string word;
cin >> word;            // 忽略开头空白，遇到空白停止
```

#### string::size_type类型
是一个无符号类型，可以存放下任何string对象的大小。

#### 比较string对象
规则是：
- 逐位比较，遇到不同的字符，两个字符比较的结果就是string比较的结果
- 如果前面都相同，但是一个string先结束，那么短string小于长string

### 处理string对象中的字符
在头文件 `cctype` 中定义了一些函数：
| 函数 | 描述 |
| --- | --- |
| isalnum(c) | c是字母或数字则返回true |
| isalpha(c) | c是字母则返回true |
| iscntrl(c) | c是控制字符则返回true |
| isdigit(c) | c是数字则返回true |
| isgraph(c) | c是除空格之外的可打印字符则返回true |
| islower(c) | c是小写字母则返回true |
| isprint(c) | c是可打印字符则返回true |
| ispunct(c) | c是标点符号则返回true |
| isspace(c) | c是空白字符则返回true（空格、制表符、回车、换行、进纸符） |
| isupper(c) | c是大写字母则返回true |
| isxdigit(c) | c是十六进制数字则返回true |
| tolower(c) | 如果c是大写字母则返回其小写形式，否则返回c |
| toupper(c) | 如果c是小写字母则返回其大写形式，否则返回c |

## 标准库类型vector
在C++11以前，如果vector的元素类型仍是vector，两个尖括号之间需要加一个空格；在C++11以后，不需要加空格。

### 定义和初始化vector对象
有以下方式可以初始化一个vector对象：
```cpp
vector<T> v1;               // v1是一个空的vector，其中的元素类型是T，执行默认初始化
vector<T> v2(v1);           // v2中包含v1所有元素的副本
vector<T> v2 = v1;          // 等价于上一条
vector<T> v3(n, val);       // v3包含了n个重复的元素，每个元素的值都是val
vector<T> v4(n);            // v4包含了n个重复的元素，执行值初始化
vector<T> v5{a, b, c};      // v5包含了三个元素，分别是a、b、c
vector<T> v6 = {a, b, c};   // 等价于上一条
```
这里最后两种初始化方式是C++11引入的列表初始化。

#### 值初始化
指具有某种默认值的初始化方式，对于内置类型，值初始化就是初始化为0；对于类类型，值初始化就是默认初始化。

#### 列表初始值还是元素数量？
当使用花括号的时候，程序会优先进行列表初始化，如果不行，会考虑通过给出的参数调用构造函数，即实现和圆括号一样的效果。

### 其他vector操作
```cpp
vector<int> v;

v.empty();                  // 如果v为空则返回true，否则返回false
v.size();                   // 返回v中元素的个数
v.push_back(t);             // 在v的末尾添加一个值为t的元素
v[n];                       // 返回v中第n个元素的引用
v1 = v2;                    // 用v2的副本代替v1中原来的元素
v1 = {a, b, c};             // 用列表中的元素代替v1中原来的元素
v1 == v2;                   // 如果两个vector相等则返回true
v1 != v2;                   // 如果两个vector不相等则返回true
v1 < v2;
v1 > v2;
v1 <= v2;
v1 >= v2;                   // 字典序比较两个vector
```
这里的 `v.size()` 返回的类型是 `vector<int>::size_type` 。

## 迭代器介绍

### 使用迭代器

#### 迭代器运算符
```cpp
*iter;                      // 返回iter所指元素的引用
iter->mem;                  // 返回iter所指元素的名为mem的成员的引用
++iter;                     // 令iter指向容器中的下一个元素
--iter;                     // 令iter指向容器中的上一个元素
iter1 == iter2;             // 如果两个迭代器指向的元素相等则返回true
iter1 != iter2;             // 如果两个迭代器指向的元素不相等则返回true
```

#### 迭代器类型
以一个 `vector<int>` 为例，它有两种迭代器类型：
- `vector<int>::iterator` ：可以读写元素
- `vector<int>::const_iterator` ：只能读元素

而 `begin()` 和 `end()` 返回的是 `vector<int>::iterator` 类型的迭代器。C++11引入了两个新的函数成员 `cbegin()` 和 `cend()` ，它们返回 `vector<int>::const_iterator` 类型的迭代器。

#### 结合解引用和成员访问操作
语句 `(*it).empty()` 中的圆括号是必须的，因为成员访问运算符 `.` 的优先级高于解引用运算符 `*` 。为了避开这个问题，可以使用箭头运算符 `->` ，即 `it->empty()` 。

### 迭代器运算
所有的迭代器都支持递增运算，而string和vector的迭代器则支持更多的运算（以下的前后似乎是从容器的头部指向容器的尾部来说的）：
| 运算 | 描述 |
| --- | --- |
| iter + n | 返回iter向前移动n个元素的迭代器，返回指向某元素的迭代器或者尾后迭代器 |
| iter - n | 返回iter向后移动n个元素的迭代器，返回指向某元素的迭代器或者尾后迭代器 |
| iter += n | iter = iter + n |
| iter -= n | iter = iter - n |
| iter1 - iter2 | 返回iter1和iter2之间的距离 |
| >、>=、<、<= | 两个迭代器位置的比较 |

其中的减法运算返回的是 `vector<int>::difference_type` 类型的值，它是一个带符号类型。

## 数组
数组比起vector或许性能好上一些。

### 指针和数组
数组名常常被转换成指针，以至于当使用 `auto` 关键字的时候，数组名会被推断为指针类型，而不是数组类型。然而 `decltype` 保留了数组类型以及数组的大小。

#### 标准库函数begin和end
在C++中，指针也被视作一种迭代器，并可以完成迭代器的基本操作。如果用指针遍历内置数组，需要获得首元素指针和尾后指针，可以通过计算获得，然而这样比较麻烦。C++11引入了两个新的标准库函数 `begin` 和 `end` ，可以返回指向数组首元素和尾后元素的指针：
```cpp
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
```

#### 指针运算
类似于vector的迭代器，指针也可以进行加减运算来一次性经过多个元素。指向同一个数组的两个指针可以相减，得到的结果是相距的元素个数，类型为定义在 `cstddef` 头文件中机器相关的带符号类型 `ptrdiff_t` 。

#### 下标和指针
相比于标准库容器的下标运算只能使用无符号索引，内置数组的下标甚至可以使用负数。

### C风格字符串

#### C标准库String函数
头文件 `cstring` 中定义了一些函数：
| 函数 | 描述 |
| --- | --- |
| strlen(s) | 返回s的长度，不包括空字符 |
| strcmp(s1, s2) | 比较s1和s2，如果s1小于s2则返回负数，如果s1大于s2则返回正数，如果s1等于s2则返回0 |
| strcat(s1, s2) | 将s2连接到s1的后面，返回s1 |
| strcpy(s1, s2) | 将s2复制给s1，返回s1 |

以上函数均不验证其参数的合法性，所以使用时要特别小心。

### 与旧代码的接口
如果要把string对象转换成C风格字符串，可以使用 `c_str` 函数，注意使用const指针：
```cpp
string s("Hello World!");
const char *str = s.c_str();
```
`c_str` 返回的指针不是一直有效的，所以最好得到指针后拷贝一个副本来使用。

#### 使用数组初始化vector对象
可以使用数组初始化vector对象，如：
```cpp
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```

### 多维数组

#### 多维数组的初始化
```cpp
// 显式初始化前三行所有元素
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};

// 这种情况下，可以不嵌套花括号
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};

// 每行只初始化首元素（内层的花括号是必须的）
int ia[3][4] = {
    {0},
    {4},
    {8}
};

// 不等价于上一条，只初始化第一行的前三个元素
int ia[3][4] = {0, 4, 8};
```

#### 使用范围for语句处理多维数组
C++11引入了范围for语句，可以用来遍历数组：
```cpp
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        ++cnt;
    }
}
```
外层的指针必须是引用类型，否则会导致其退化成指针，从而无法继续遍历。

#### 类型别名简化多维数组的指针
多维数组和指针交互时，类型会很复杂，可以使用类型别名来简化，不过在此 `using` 和 `typedef` 的使用有一些区别：
```cpp
// 两条语句等价
using int_array = int[4];
typedef int int_array[4];
```

<br><br>

# 表达式

## 基础

### 基本概念

#### 左值和右值
在C语言中，左值和右值的概念非常简单，可以放在赋值语句左侧的就是左值，否则就是右值。

然而来到C++之中，就没有那么简单了。左值表达式的求值结果是一个对象或者函数，常量对象也是左值，却不能作为赋值语句的左侧。虽然有的表达式求值结果是对象，却是右值。一般来说，一个对象被当做左值时，使用的是对象的身份；当做右值时，使用的是对象的值。

以下几种运算符是需要使用左值的：
- 赋值运算符的左侧需要一个非常量的左值，并且返回的也是一个左值
- 取地址符作用于左值，返回一个指向该左值的指针，这个指针是一个右值
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符，返回的是左值
- 内置类型和迭代器的递增和递减运算符作用于左值，前置版本返回的是左值

对于左值使用 `decltype` 得到的类型是引用类型。

### 优先级与结合律
**复合表达式**是指含有两个或多个运算符的表达式。

## 算术运算符
一元正号运算符作用于小于 `int` 的整数类型时，会将其提升为 `int` 类型，如 `bool` 类型。在 `%` 的运算中，可能遇到两个操作数一正一负的情况，早期的C++标准中，商怎么舍入没有规定。在C++11中，商一律向0舍入，即直接舍去小数部分。

## 赋值运算符
C++11允许使用花括号作为赋值语句的右侧，如：
```cpp
vector<int> v;                          // v是一个空的vector
v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

## 条件运算符
```cpp
expr1 ? expr2 : expr3;
```
程序只会对 `expr2` 或者 `expr3` 中的一个进行求值，取决于 `expr1` 的值。

## 位运算符
位运算符如何处理负数的符号位没有明确规定，是依赖于机器的。一般来说，如果运算对象是小整数类型，它会被[提升](#整型提升)为较大的整数类型，如 `char` 被提升成 `int` 。

#### 移位运算符
右侧的运算对象不能为负，且必须严格小于结果的位数，否则行为是未定义的。对于有符号数来说，右移时左侧补充什么是依赖于环境的；如果是无符号数，右移时左侧补充0。

## sizeof运算符
有两种形式：
```cpp
sizeof(type);
sizeof expr;
```
`sizeof` 并不对表达式进行求值，所以即使解引用一个无效指针也不会有问题。C++11允许通过类作用域运算符来获取类成员的大小，而不需要有一个类的对象：
```cpp
sizeof Sales_data::revenue;
```
对数组调用 `sizeof` 返回整个数组占用空间的大小，对 `vector` 这种类调用 `sizeof` 返回的是类固定部分的大小。 `sizeof` 返回的结果是常量表达式。

## 逗号运算符
首先对左侧表达式求值，然后丢弃结果，再对右侧表达式求值，返回右侧表达式的结果。

## 类型转换
C++中，如果两个类型之间可以相互转换，那么说这两个类型之间是关联的。

#### 何时发生隐式类型转换
- 在大多数表达式中，比 `int` 小的整数类型提升为较大的整数类型
- 在条件中，其他类型转换成 `bool` 类型
- 初始化时，初始值转换成变量的类型；赋值时，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算和关系运算中有多种类型，需要转换成一种类型
- 函数调用传参

### 算术转换
指把一种算术类型转换成另一种算术类型

#### 整型提升
指小整数类型转换成大整数类型。

对于 `bool` 、 `char` 、 `signed char` 、 `unsigned char` 、 `short` 和 `unsigned short` 来说，如果 `int` 能表示它们所有的可能取值，那么它们就会被提升为 `int` 类型；否则，它们会被提升为 `unsigned int` 类型。

较大的字符类型，如 `wchar_t` 、 `char16_t` 、 `char32_t` ，会被提升为 `int` 、 `unsigned int` 、 `long` 、 `unsigned long` 、 `long long` 、 `unsigned long long` 中最小可以容纳其所有取值的类型。

#### 无符号类型的运算对象
如果一个运算对象是无符号类型，另一个运算对象是带符号类型，转换会比较怪异。

如果无符号类型不小于带符号类型，如 `unsigned int` 相对于 `int` 来说，此时 `int` 会被转换成 `unsigned int` 。

如果无符号类型小于带符号类型，结果就依赖于机器。如果无符号类型的所有值都能被带符号类型容纳，那么无符号类型转换成带符号类型；否则，带符号类型转换成无符号类型。

### 其他隐式类型转换
- 数组转换成指针
- 指针的转换
    - 整数值0或者字面值nullptr可以转换成任意指针类型
    - 任意指向非常量的指针可以转换成 `void*` 类型
    - 任意指针可以转换成 `const void*` 类型
    - 类类型转换
    - 可以转换成布尔类型
    - 指向非常量的指针可以转换成指向常量的指针

### 显式转换

#### 命名的强制类型转换
- `static_cast` ：任何具有明确定义的、不含底层const的转换都可以使用
- `const_cast` ：只能改变底层const
- `reinterpret_cast` ：基本上用于指针的不保证安全的转换，如 `int*` 转换成 `char*` ，是对指针在底层上的重新解释，比较危险。
- `dynamic_cast` ：后面再说

#### 旧式的强制类型转换
```cpp
(type) expr;
type (expr);
```
同时具有上述前三种转换的功能，尽量不要使用。

## 运算符优先级表
优先级1：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `::` | 全局作用域 | `::name` | 左 |
| `::` | 类作用域 | `class::name` | 左 |
| `::` | 命名空间作用域 | `namespace::name` | 左 |

优先级2：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `.` | 成员选择 | `object.member` | 左 |
| `->` | 成员选择 | `pointer->member` | 左 |
| `[]` | 下标 | `expr[expr]` | 左 |
| `()` | 函数调用 | `name(expr-list)` | 左 |
| `()` | 类型构造 | `type(expr-list)` | 左 |

优先级3：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `++` | 后置递增运算 | `lvalue++` | 右 |
| `--` | 后置递减运算 | `lvalue--` | 右 |
| `typeid` | 类型ID | `typeid(type)` | 右 |
| `typeid` | 运行时类型ID | `typeid(expr)` | 右 |
| explicit cast | 类型转换 | `cast_name<type>(expr)` | 右 |

优先级4：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `++` | 前置递增运算 | `++lvalue` | 右 |
| `--` | 前置递减运算 | `--lvalue` | 右 |
| `~` | 位求反 | `~expr` | 右 |
| `!` | 逻辑非 | `!expr` | 右 |
| `-` | 一元负号 | `-expr` | 右 |
| `+` | 一元正号 | `+expr` | 右 |
| `*` | 解引用 | `*expr` | 右 |
| `&` | 取地址 | `&lvalue` | 右 |
| `()` | 类型转换 | `(type) expr` | 右 |
| `sizeof` | 对象的大小 | `sizeof expr` | 右 |
| `sizeof` | 类型的大小 | `sizeof(type)` | 右 |
| `sizeof...` | 参数包的大小 | `sizeof...(name)` | 右 |
| `new` | 创建对象 | `new type` | 右 |
| `new[]` | 创建数组 | `new type[size]` | 右 |
| `delete` | 释放对象 | `delete expr` | 右 |
| `delete[]` | 释放数组 | `delete[] expr` | 右 |
| `noexcept` | 能否抛出异常 | `noexcept(expr)` | 右 |

优先级5：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `->*` | 指向成员选择的指针 | `ptr->*member` | 左 |
| `.*` | 指向成员选择的指针 | `obj.*member` | 左 |

优先级6：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `*` | 乘法 | `expr * expr` | 左 |
| `/` | 除法 | `expr / expr` | 左 |
| `%` | 取模（取余） | `expr % expr` | 左 |

优先级7：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `+` | 加法 | `expr + expr` | 左 |
| `-` | 减法 | `expr - expr` | 左 |

优先级8：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `<<` | 向左移位 | `expr << expr` | 左 |
| `>>` | 向右移位 | `expr >> expr` | 左 |

优先级9：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `<` | 小于 | `expr < expr` | 左 |
| `<=` | 小于等于 | `expr <= expr` | 左 |
| `>` | 大于 | `expr > expr` | 左 |
| `>=` | 大于等于 | `expr >= expr` | 左 |

优先级10：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `==` | 等于 | `expr == expr` | 左 |
| `!=` | 不等于 | `expr != expr` | 左 |

优先级11：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `&` | 位与 | `expr & expr` | 左 |

优先级12：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `^` | 位异或 | `expr ^ expr` | 左 |

优先级13：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `\|` | 位或 | `expr \| expr` | 左 |

优先级14：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `&&` | 逻辑与 | `expr && expr` | 左 |

优先级15：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `\|\|` | 逻辑或 | `expr \|\| expr` | 左 |

优先级16：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `?:` | 条件 | `expr ? expr : expr` | 右 |

优先级17：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `=` | 赋值 | `lvalue = expr` | 右 |
| `*=` | 复合赋值 | `lvalue *= expr` | 右 |

优先级18：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `throw` | 抛出异常 | `throw expr` | 右 |

优先级19：
| 运算符 | 功能 | 用法 | 结合律 |
| --- | --- | --- | --- |
| `,` | 逗号 | `expr, expr` | 左 |

<br><br>

# 语句

## 简单语句
一个表达式后面加分号就形成**表达式语句**，它求值并丢弃结果。

#### 空语句
仅有一个分号，它什么也不做。

#### 复合语句
即用花括号括起来的语句和声明的序列，又称**块**。

## 语句作用域
可以在 `if` 、 `switch` 、 `while` 、 `for` 语句的控制结构中定义变量，这些变量只在相应的语句内可见，如：
```cpp
while (int i = get_num())
    cout << i << endl;
i = 0;                      // 错误：i在这里不可见
```

## 条件语句

### switch语句

#### switch内部的变量定义
在不使用花括号的情况下，如果在一个 `case` 标签中定义了一个变量，那么它的作用域实际上是从定义开始到 `switch` 语句结束。这可能导致 `switch` 语句跳过这条定义语句。

C++标准规定，不允许跨过变量的初始化语句直接跳转到该变量的作用域内的另一个位置。这条规定实际上允许变量先声明，而在后面才初始化，只要初始化语句在最后的 `case` 标签中或者 `default` 标签中即可。

这对 `switch` 语句内的变量定义是比较苛刻的约束，比如需要在第二个标签定义一个变量而后续标签不需要使用它，这样的情况下，可以使用花括号来限制变量的作用域，如：
```cpp
case 1:
    {
        int i = 0;
        // ...
    }
    break;
```
这样 `i` 的作用域就不会覆盖到后续的标签。

## 迭代语句

### 范围for语句
C++11引入了范围for语句，可以用来遍历一个序列，如：
```cpp
vector<int> v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto &r : v)
    r *= 2;
```
`r` 在每次迭代都会重新定义，并初始化成序列中的下一个元素。这段代码等价于：
```cpp
for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) {
    auto &r = *beg;
    r *= 2;
}
```

## 跳转语句

### goto语句
跟[上述情况](#switch内部的变量定义)类似，向下跳转不允许跨过某个变量的初始化；回向的跳转越过变量的定义则相当于销毁变量再重新定义，这是允许的。

## try语句块和异常处理

### throw表达式
如：
```cpp
throw runtime_error("error message");
```
构造异常类可以使用string或者C风格字符串。

### try语句块
```cpp
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // ...
```
这里 `exception-declaration` 称作**异常声明**，一般形式如：
```cpp
catch (runtime_error err)
```
如果某个 `catch` 子句被选中，那么执行对应的 `handler-statements` ，然后继续执行整个 `try` 语句块之后的语句。

#### 编写处理代码
所有的异常类都提供了名为 `what()` 成员函数，它返回一个 `const char*` 指针。对于携带额外信息的异常类，如 `runtime_error` 可以用它来获取用来构造异常对象的string包含的信息。对于不携带额外信息的异常类，如 `exception` ， `what()` 返回的内容由编译器决定。

#### 函数在寻找处理代码的过程中退出
在一个函数中，如果一个异常被抛出而没有被任何 `catch` 语句匹配，那么终止这个函数并在上级函数继续寻找 `catch` 语句。如果在 `main` 函数中也没有找到，那么程序转入标准库的 `terminate` 函数，它的行为和系统有关，一般来说这个函数会导致程序非正常退出。

### 标准异常
异常类定义在4个头文件中：
- `exception` ：定义了最通用的异常类 `exception` ，它只报告异常的发生，不包含任何额外信息
- `stdexcept` ：定义了几个常用的异常类，具体有：
    - `exception` ：最常见的问题
    - `runtime_error` ：只有在运行时才能检测到的问题
    - `range_error` ：运行时错误，生成的结果超出了有意义的值域范围
    - `overflow_error` ：运行时错误，计算上溢
    - `underflow_error` ：运行时错误，计算下溢
    - `logic_error` ：程序逻辑错误
    - `domain_error` ：逻辑错误，参数对应的结果值不存在
    - `invalid_argument` ：逻辑错误，无效参数
    - `length_error` ：逻辑错误，试图创建一个超出该类型最大长度的对象
    - `out_of_range` ：逻辑错误，使用一个超出有效范围的值
- `new` ：定义了 `bad_alloc` 异常
- `typeinfo` ：定义了 `bad_cast` 异常

`exception` 、 `bad_alloc` 、 `bad_cast` 只能默认初始化。其他的异常则必须提供异常信息。

<br><br>

# 函数

## 函数基础

#### 形参和实参
实参的求值顺序是任意的。

### 局部对象
名字具有作用域，指程序文本的某一部分，名字在其中可见。对象具有生命周期，指程序执行过程中对象存在的一段时间。定义在所有函数体之外的对象存在于程序的整个执行过程中，定义在函数体内的对象则依赖定义的方式。

#### 自动对象
当控制流经过定义语句时，对象被创建；当控制流到达语句块末尾时，对象被销毁。这种对象称为**自动对象**。

#### 局部静态对象
当控制流第一次经过定义语句时，对象被创建；当控制流到达程序的末尾时，对象被销毁。这种对象称为**局部静态对象**。

### 函数声明
包括函数的三要素：返回类型、函数名和形参列表。又称作**函数原型**。

### 含有可变形参的函数

#### initializer_list形参
C++11引入了 `initializer_list` 类型，定义在 `initializer_list` 头文件中，它支持如下操作：
```cpp
initializer_list<T> lst;                // 默认初始化，T类型元素的空列表
initializer_list<T> lst{a, b, c};       // lst包含三个元素，它们是const的
lst2 = lst;                             // lst2是lst的副本
lst2(lst);                              // 同上
lst.size();                             // 返回lst中元素的个数
lst.begin();                            // 返回指向lst中第一个元素的指针
lst.end();                              // 返回指向lst中尾元素之后位置的指针
```
为了初始化一个 `initializer_list` 形参，可以使用花括号括起来的元素列表，如：
```cpp
error_msg({"functionX", "expected", "actual"});
```

#### 省略符形参
为了兼容C语言，C++允许使用 `varargs` 。

## 返回类型和return语句

### 有返回值函数
一般编译器要求所有可能控制流都必须返回一个值，否则会报错。如果编译器没能检测出一条未返回值的路径，那这条路径引发的行为是未定义的。

#### 引用返回左值
由于C++中函数可以返回引用，此时返回的是左值，则函数调用表达式也可以放在赋值语句的左侧。

#### 列表初始化返回值
C++11规定，函数可以返回花括号包围的值的列表，如：
```cpp
vector<string> process()
{
    if (expected.empty())
        return {};
    else if (expected == actual)
        return {"functionX", "okay"};
    else
        return {"functionX", expected, actual};
}
```

#### 主函数main的返回值
main函数可以不带 `return` 语句，此时编译器隐式插入 `return 0;` 。实际上为了指示程序执行的成功和失败，在 `cstdlib` 头文件中定义了两个预处理变量 `EXIT_SUCCESS` 和 `EXIT_FAILURE` 。

### 返回数组指针

#### 声明一个返回数组指针的函数
当不使用类型别名时，这比较复杂，一般形式如：
```cpp
Type (*function(parameter_list))[dimension];
```

#### 尾置返回类型
C++11引入了尾置返回类型，对于上面返回数组指针的函数的声明，可以写成：
```cpp
auto func(parameter_list) -> Type(*)[dimension];
```

#### 使用decltype
对于上面返回数组指针的函数的声明，也可以写成：
```cpp
// arr是对应类型数组的数组名
decltype(arr) *func(parameter_list);
```

## 函数重载

#### 重载和const形参
顶层const不能区分两个函数声明，或者说，因为函数无法改变形参，顶层const参数根本没有意义。

对于底层const的指针来说，有无const可以区分两个函数声明。当传递一个指向非常量的指针时，编译器会选择非常量版本的函数；当传递一个指向常量的指针时，编译器会选择常量版本的函数。

#### 调用重载的函数
当调用到一个被重载的函数名时，需要把这个调用与一个具体的函数关联起来，这叫做**函数匹配**或者**重载确定**。目前需要掌握的是，当调用重载函数时有三种可能的结果：
- 编译器找到一个与实参最佳匹配的函数，生成调用这个函数的代码
- 找不到任何一个函数与实参匹配，编译器发出无匹配的错误信息
- 有多于一个函数匹配，但没有最佳匹配，编译器发出二义性调用的错误信息

### 重载与作用域
在内层作用域声明同名的函数，会隐藏外层作用域的所有同名函数。即使内层的函数无法匹配调用，也无法调用外层的函数。

## 特殊用途语言特性

### 默认实参
可以为函数参数提供默认实参，所有具有默认实参的参数都必须出现在参数列表的末尾。如果一个具有默认实参的函数已经具有一个声明，后续的声明不能修改已经提供的默认实参，但是可以补充提供新的默认实参，如：
```cpp
string screen(int, int, char = ' ');
string screen(int, int, char = '*');        // 错误：不能修改已经提供的默认实参
string screen(int = 24, int = 80, char);    // 正确：补充提供新的默认实参
```

#### 默认实参初始化
局部变量不能作为默认实参，其他只要类型符合都可以。当使用默认实参时，其名字的解析是在函数声明的作用域内进行的；默认实参的求值是在调用时进行的。也就是说，即使在调用处有名字隐藏了默认实参的名字，实际上指向的仍然是原来的默认实参；而如果更改了默认实参的值，那么调用处实际传参的值也会改变。

### 内联函数和constexpr函数

#### 内联函数可避免函数调用的开销
声明和定义函数时在前面加上 `inline` 关键字即可，但只是请求编译器展开函数体，编译器可以选择忽略此请求。（根据网上查到的资料，似乎声明中的 `inline` 不起任何作用，甚至可以删除）

#### constexpr函数
C++11引入的 `constexpr` 关键字同样可以用于修饰函数，表示函数返回值可以用于常量表达式。它要求函数：
- 返回值是字面值类型
- 形参是字面值类型
- 函数体只有一条 `return` 语句

编译的时候，编译器把函数的调用替换为它的结果。实际上它也可以包含其他语句，但是它们不能进行任何实际操作，如空语句、类型别名和 `using` 声明。当返回的内容包含非常量表达式时，该函数的调用就不是常量表达式，比如：
```cpp
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();           // 正确：foo是常量表达式

constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

scale(2);       // 是常量表达式

int i = 2;
scale(i)；      // 不是常量表达式           
```
如果该函数的调用不是常量表达式，那么编译器将会报错。

#### 把内联函数和constexpr函数放在头文件中
因为编译器要展开这两种函数需要看到函数的定义，为了保证定义的相同，一般把它们放在头文件中。

### 调试帮助

#### assert预处理宏
它定义在 `cassert` 头文件中，归预处理器管而不是编译器管，不需要指定 `std::` 的命名空间，用法是：
```cpp
assert(expr);
```
对 `expr` 求值。如果 `expr` 为假，那么程序终止执行，打印相关信息；否则什么也不做。

#### NDEBUG预处理变量
当定义了NDEBUG的时候，assert什么也不做，连求值也不进行。可以使用 `#define NDEBUG` 来定义，或者在编译时指定 `-D NDEBUG` 。除了使用 `assert` 也可以自己借助 `NDEBUG` 来调试：
```cpp
void print(const int ia[], size_t size)
{
    #ifndef NDEBUG
        cerr << __func__ << ": array size is " << size << endl;
    #endif
}
```
这里 `__func__` 是编译器定义的特殊变量，常用的有如下五个：
- `__func__` ：当前函数名的字符串字面值
- `__FILE__` ：当前文件名的字符串字面值
- `__TIME__` ：当前文件编译时间的字符串字面值
- `__DATE__` ：当前文件编译日期的字符串字面值

### 函数匹配

#### 确定候选函数和可行函数
首先选定本次调用对应的重载函数集，这些函数称为**候选函数**。要求：
- 与被调用的函数同名
- 声明在调用点可见

然后考察实参，选出能被这些实参调用的函数，这些函数称为**可行函数**。要求：
- 形参数量和实参数量相等（还有默认实参的情况）
- 实参类型与形参类型相同，或者能转换成形参类型

如果找不到可行函数，编译器报无匹配函数的错误。

#### 寻找最佳匹配（如果有的话）
两种类型越接近，它们匹配得越好，规则在[下方](实参类型转换)。

#### 含有多个形参的函数匹配
如果函数有多个参数，寻找最佳匹配会很困难。其中的最佳匹配要满足：
- 每个实参的匹配都不劣于其他可行函数
- 至少有一个实参的匹配优于其他可行函数

如果没有函数能符合这个条件，则为二义性调用，编译器报错。

### 实参类型转换
为了确定最佳匹配，编译器把匹配程度从高到低划分为以下等级：
1. 精确匹配，有以下情况：
    - 实参类型和形参类型相同
    - 实参从数组类型或函数类型转换成对应指针类型
    - 添加或移除顶层const
1. 通过const转换实现的匹配（底层const）
1. 通过[类型提升](#整型提升)实现的匹配
1. 通过算术类型转换或指针转换实现的匹配
1. 通过类类型转换实现的匹配

#### 需要类型提升和算术类型转换的匹配
如果传入的实参是 `char` ，候选的重载函数有 `int` 和 `short` 版本， `char` 也是直接提升为 `int` 。所有的算术类型转换都是同级的。

## 函数指针

#### 使用函数指针
如果有函数指针 `pf` ，那么有以下两种方式调用函数：
```cpp
pf(args);
(*pf)(args);
```
通过函数名赋值给函数指针时，如果函数名有多个重载版本，被选择的函数名必须是精确匹配的。

#### 函数指针形参
下面两个声明是等价的：
```cpp
void useBigger(const string &s1, const string &s2, 
                bool (*pf)(const string &, const string &));

void useBigger(const string &s1, const string &s2,
                bool pf(const string &, const string &));
```
这比较冗长，可以使用 `typedef` 和 `decltype` 来简化：
```cpp
// 这两个声明是等价的，Func和Func2是函数类型
typedef bool Func(const string &, const string &);
typedef decltype(lengthCompare) Func2;

// 下面两个声明是等价的，FuncP和FuncP2是函数指针类型
typedef bool (*FuncP)(const string &, const string &);
typedef decltype(lengthCompare) *FuncP2;
```

#### 返回指向函数的指针
类似之前返回指向数组的指针，直接的写法类似于：
```cpp
int (*f1(int))(int, int);
```

<br><br>

# 类

## 定义抽象数据类型

#### =default的含义
如果希望编译器合成一个默认的构造函数，可以使用C++11引入的 `=default` ，如：
```cpp
Sales_data() = default;
```

## 访问控制与封装

#### 使用class或struct关键字
两者唯一的区别是， `class` 的默认访问权限是 `private` ，而 `struct` 的默认访问权限是 `public` 。

### 友元
有时候希望把某些成员声明成 `private` ，但又希望把某些操作它们的函数声明在类外，可以把它们声明成友元。方法是在类内重复它们的声明，并在声明前加上 `friend` 关键字：
```cpp
class Sales_data {
    friend Sales_data add(const Sales_data &, const Sales_data &);
    friend istream &read(istream &, Sales_data &);
    friend ostream &print(ostream &, const Sales_data &);
};
```
它们可以出现在类内的任何位置，不受访问控制符的影响。

值得一提的是，很多编译器并不强制限定友元函数必须在使用之前在类外声明。

## 类的其他特性

### 类成员再探

#### 定义一个类型成员
类可以自定义类型成员，它也受到访问控制符的影响，如：
```cpp
class Screen {
public:
    typedef std::string::size_type pos;
    using pos1 = std::string::size_type;
    // ...
};
```

#### 令成员作为内联函数
类内定义的成员函数是默认内联的，也可以显式用 `inline` 关键字指定内联。无需在声明处加上 `inline` ，虽然可以，但是只在定义加上 `inline` 其实更好理解。

#### 可变数据成员
使用关键字 `mutable` 声明的数据成员永远不会是 `const` ，即使它是 `const` 对象的的成员，所以 `const` 成员函数也可以修改它。

### 友元再探
也可以把类声明成友元，或者把其他类的成员函数声明成友元。可以把友元函数定义在类内，它们也是隐式内联的。

#### 类之间的友元关系
如果把某个类声明成友元，那么这个类的成员函数可以访问当前类的所有成员。友元关系没有传递性。语法如下：
```cpp
class Screen {
    friend class Window_mgr;
    // ...
};
```

#### 令成员函数作为友元
可以只把别的类中某个成员函数声明成友元，语法如下：
```cpp
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
    // ...
};
```

#### 友元声明和作用域
友元声明实际上不是一个函数声明，如果在类内声明了一个友元函数，但此时并没有该函数的实际声明（这是允许的），直到看到真正的声明之前，都无法调用这个友元函数。（有的编译器并不强制执行这样的限制）

## 类的作用域
如果在类外定义一个成员函数，需要指明它属于哪个类，语法如下：
```cpp
return-type ClassName::function-name(parameter-list)
{
    // ...
}
```
而在编译器看到了 `ClassName::` 之后的所有名字解析都是在类的作用域内进行的，所有参数中的类型和函数体中的变量都不再需要指出它们属于哪个类。由于 `return-type` 在这之前，当它也是类中的成员时，需要显式指出它属于哪个类。

### 名字查找与类的作用域
名字查找指寻找与所用名字最匹配的实体，它的规则如下：
1. 在名字所在的块中查找声明语句，只考虑在使用之前出现的声明。
1. 查找外层作用域。
1. 找不到则报错。

对于定义在类内的成员函数中的名字查找则有些区别。类的定义分两步处理：
1. 编译成员的声明
1. 直到类全部可见后才编译函数体

这就使得成员函数可以使用类中所有的名字，即使它们的声明出现在函数体之后。

#### 类型名要特殊处理
因为类型名可能会用于成员函数的声明，这需要在编译器读到的时候就进行解析，所有并不能像其他名字一样等到类全部可见后再解析。当某个成员函数使用了外层作用域中的某个名字，在该函数后就不允许再重新声明这个名字。因此，尽量把类型别名的声明放在类的开始处。

#### 成员定义中的普通块作用域的名字查找
成员函数中名字解析方式：
1. 在函数中查找声明语句，只考虑在使用之前出现的声明
1. 在类内查找
1. 在**函数定义**之前的作用域中查找

#### 类作用域之后，在外围的作用域中查找
如果明确需要使用全局作用域中的同名对象，可以使用作用域运算符 `::` ，如 `::object` 。

## 构造函数再探

### 构造函数初始值列表
所有成员的初始化会在构造函数体发生之前就完成。出现在初始值列表中的成员按照声明顺序使用给定的值进行初始化，有类内初始值的成员用该值初始化，其他成员会被默认初始化。在构造函数体中进行的是赋值操作而不是初始化。

#### 构造函数的初始值有时必不可少
像 `const` 常量和引用类型的成员，它们必须在构造函数体执行前就被赋予初始值。

### 委托构造函数
C++11扩展了构造函数初始值的功能，使得可以定义委托构造函数。执行的顺序是：
1. 受委托的构造函数的初始值列表
1. 受委托的构造函数的函数体
1. 委托构造函数的函数体

### 默认构造函数的作用
当对象被默认初始化或值初始化时自动执行默认构造函数。

默认构造函数在以下情况发生：
- 在块作用域内不使用初始值定义一个非静态变量
- 当一个类含有类类型成员且使用合成的默认构造函数时
- 当类类型成员没有在构造函数初始值列表中显式初始化时

值初始化在以下情况发生：
- 数组初始化时提供初始值数量少于数组大小
- 不使用初始值定义一个局部静态变量
- 写出如 `string()` 这样显式请求值初始化的表达式

#### 使用默认构造函数
注意不要写出 `string s();` ，这是一个函数声明，而不是一个默认初始化的 `string` 对象的声明。如果需要默认初始化的对象，直接写成 `string s;` 即可。

### 隐式的类类型转换
只有一个参数的构造函数被称为**转换构造函数**。

#### 只允许一步类类型转换
隐式的转换只能是一步转换，即必须有参数刚好匹配的构造函数。然而显式构造则不同，可以从C风格字符串隐式构造出string对象再进一步传递给接受string的构造函数。

#### 抑制构造函数定义的隐式转换
在构造函数前加上 `explicit` 关键字即可。它只对单参数的构造函数起作用，并且只能在类内声明时使用。使用它之后，隐式的转换就不再允许了。但是显式的转换仍然可以使用：
```cpp
Sales_data(null_book);
static_cast<Sales_data>(cin);
```

### 聚合类
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法。它需要满足以下条件成为聚合类：
- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有虚函数

它可以用初始值列表来初始化，如：
```cpp
struct Data {
    int ival;
    string s;
};

Data val1 = {0, "Anna"};
```
提供的初始值顺序必须和成员的声明顺序一致，初始值数量少于成员数量时后面的成员被值初始化，初始值数量不允许多于成员数量。这样的初始化方式有三个缺点：
- 所有成员都需要是public的
- 把正确初始化的任务交给了用户
- 添加或删除一个成员后，所有的初始化语句都需要修改

### 字面值常量类
它们也是字面值，可以拥有 `constexpr` 的函数成员，这些成员是隐式 `const` 的。数据成员都是字面值类型的聚合类是字面值常量类。如果类不是一个聚合类，满足以下条件时同样是字面值常量类：
- 数据成员都是字面值类型
- 类至少含有一个 `constexpr` 构造函数
- 如果一个数据成员含有类内初始值，那么它必须是一个常量表达式；如果是类类型成员，则初始值必须使用成员自己的 `constexpr` 构造函数
- 类必须使用析构函数的默认定义

#### constexpr构造函数
`constexpr` 函数要求只能包含一条 `return` 语句，由于构造函数没有返回值，所以函数体只能为空。它必须借助初始化列表来初始化所有成员，初始值要么使用 `constexpr` 构造函数，要么是常量表达式。

`constexpr` 构造函数用于生成 `constexpr` 对象以及 `constexpr` 函数的参数或返回类型。

## 类的静态成员

#### 定义静态成员
`static` 只能用于类内声明，在类外定义时不能重复使用 `static` 关键字。一般来说，不能再类的内部初始化静态成员，必须在类的外部定义和初始化它。类似于全局变量，它定义在任何函数之外，定义方式如下：
```cpp
double Account::interestRate = initRate();
```
这里的 `initRate` 是 `Account` 类的私有函数，但也能直接使用，因为类名 `Account` 提供了作用域。

#### 静态成员的类内初始化
一般来说不应该在类内初始化静态成员。然而可以为静态成员提供 `const` 整型的类内初始值，这要求该成员是 `constexpr` 的字面值常量类型，初始值必须是常量表达式。这可以用于类内数组的大小，如：
```cpp
class Account {
public:
    static constexpr int period = 30;
    double daily_tbl[period];
};
```
当程序只会用到该静态成员的值时，编译器可以替换掉它的所有出现，此时不需要在类的外部定义它。如果不能替换，如传递给一个接收引用的函数，此时需要左值，就需要在类的外部定义它。由于类内已经提供了初始值，类外定义时不允许再次提供初始值：
```cpp
constexpr int Account::period;
```
通常，即使类内提供了初始值，也应该在类的外部定义它。

#### 静态成员能用于某些场景，而普通成员不能
静态成员可以是不完全类型，甚至可以是类本身的类型。静态成员可以作为默认实参，普通成员不能。
