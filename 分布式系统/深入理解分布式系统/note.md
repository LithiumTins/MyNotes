# 1 - 认识分布式系统

## 1.1 - 什么是分布式系统
分布式系统是一个其组件分布在不同的、联网的计算机上，组件之间通过传递信息进行通信和协调，共同完成一个任务的系统。

分布式系统的设计关键是如何协调这些计算机来共同完成任务。虽然分布式系统的计算机是离散的，但在客户看来，它们可以视作同一台计算机。

因此，分布式系统通常有如下特点：
- 多进程，分布式系统中总是有多个进程并发运行
- 不共享操作系统，机器之间通过网络交换信息来协作
- 不共享时钟，因此多个机器对时间的认知可能有偏差，很难通过时间来定义两个事件的先后

## 1.2 - 为什么需要分布式系统
相比于单机，分布式系统有一些显著的优点：
- 高性能：由于硬件工艺的限制，单 CPU 的性能很早就达到了瓶颈。后面衍生出多核 CPU 的方案，但通过物理总线等方式来连接多个 CPU，随着 CPU 数量的增加成本也迅速提高。从而互联网企业按照多核 CPU 架构的思想，通过网络把多台廉价计算机连接起来，形成了分布式系统。
- 可扩展性：很多需求都是数据密集型的，随着数据的增长，单机的扩展能力非常有限。通过构建数据分布在多台计算机上的分布式存储系统，集群规模可以扩展到非常庞大的规模。
- 高可用性：如今很多服务要求 7x24 小时不间断提供服务，比如可能要求 99.999% 的可用性，从而一年之内平均只能停机 5 分钟。在单机上，由于硬件故障、人为因素或其他原因，这几乎是不可能实现的。而分布式系统通过冗余数据保证数据可用性，通过冗余计算保证故障时服务切换，都是非常常见的。
- 必要性：有些时候，业务在地理上分布在多个位置，分布式系统几乎是不可避免的。

## 1.3 - 分布式系统的示例
有非常多分布式系统的应用，如电子银行、多人在线游戏、视频会议、社交网络和点对点网络等。不同的应用可能需要不同的架构，从而分布式系统有非常多种架构。以下列举两个具有代表性的案例。

### 1.3.1 - 搜索引擎
搜索引擎是把多种分布式系统有机结合到一起的典型软件工程。

考虑当在 Google 搜索一个关键词时，有哪些分布式系统参与处理。

首先，DNS 把域名解析为 IP 地址。DNS 就是一个存储域名到 IP 地址映射的分布式数据库，主要特点是去中心化、可扩展性和健壮性，它能很好处理负载和故障。

除此之外，Google 在支持搜索和其他应用的分布式基础设施上做了巨大的努力，它们包括：
- 全球化、巨大的多数据中心，分布的单个数据中心就可以有数万台服务器。
- 分布式文件系统 GFS（Google File System），目前已经升级到 2 代
- 高性能、可扩展、存储大规模结构化数据的存储系统 Bigtable，它是非关系性数据库，更像 NoSQL 数据库，优势在于扩展性和查询性能
- 分布式锁服务 Chubby
- 并行和分布式计算的编程模式 MapReduce
- 分布式数据库 Spanner

可以看到，搜索一个关键词就牵动了许多的分布式系统。Google 借助它们构建了一套相当复杂的，全球高可用、高可扩展、高性能的基础架构，如下图所示：

![Google分布式架构](image/Google分布式架构.png)

### 1.3.2 - 加密货币
以比特币为例，从分布式系统的角度来看，它首次实现和验证了一种实用的、去中心化和拜占庭容错的共识算法，打开了通过区块链新时代的大门。

## 1.4 - 分布式系统的挑战
分布式系统同时也带来不少设计上的挑战。Leslie Lamport 指出：“分布式系统是指一台你根本不知道其存在的计算机发生了故障，会导致你自己的计算机无法使用。” 因此，分布式系统常常会面临许多棘手的问题。

上世纪 90 年代，L.Peter Deutsch 等人根据 Sun 公司内部出现的问题总结了分布式计算的常见认知谬误：
- 网络是可靠的
- 延迟为 0
- 带宽是无限的
- 网络是安全的
- 拓扑结构不会改变
- 只有一个管理员
- 传输成本为 0
- 网络是同构的

以上任何一个错误的假设都可能带来严重的问题。我们重点关注前两条，它们可以归结为网络延迟问题。实际上，还有两个常见的问题，即部分失效问题和时钟问题。

### 1.4.1 - 网络延迟问题
分布式系统的多个节点通过网络通信，但网络传输是不可靠的，因此可能遇到：
- 信息丢失
- 以为信息丢失，实际上只是延迟到达
- 重传信息使得对方收到重复信息
- 以为某个服务已经故障，实际上是消息延迟
- 消息没有按序到达，或者不同机器接收到的消息顺序不同

### 1.4.2 - 部分失效问题
单机上的程序要么正常工作，要么出现问题。

分布式系统中，可能出现一部分机器正常工作，一部分机器出现问题的情况（或者由于网络问题无法和它们交互）。这就称为部分失效。

难点在于不确定性。系统有时候可能正常工作，有时候可能出现问题。甚至有时都很难确定系统是否出现问题。

因此这样的问题是很难调试的。并且当有些服务要求原子性，如果某个节点不成功，所有节点都不能成功，部分失效会给设计带来很大的挑战。

### 1.4.3 - 时钟问题
单机中只有一个时钟，时间的先后就表示事件发生的先后。分布式系统中，每个机器有自己的时钟，时钟的偏差使得时间的参考性下降，从而很难确定各个事件的先后顺序。

一种常见的解决方式是，通过一个时间服务器同步时间。然而由于网络延迟的可变性，同一时间发出的信息可能在不同机器上到达的时间不同，从而导致同步后的时间也可能偏差。另一种解决方法，像 Google 构建的 TrueTime API，让应用能生成单调递增的时间戳，但这通常需要使用昂贵的原子钟和精心设计的系统。最普遍的方式是 Leslie Lamport 提出的逻辑时钟方案。

## 1.5 - 每个程序员都应该知道的数字
Jeff Dean 在 2009 年对计算机的各类操作的耗时做了大致估计，如下表给出：

| 操作 | 延迟 |
| --- | --- |
| 执行一个指令 | 1 ns |
| L1 缓存查询 | 0.5 ns |
| 分支预测错误 | 5 ns |
| L2 缓存查询 | 7 ns |
| 互斥锁/解锁 | 25 ns |
| 主存访问 | 100 ns |
| 使用 Zippy 算法压缩 1KB 的数据 | 3,000 ns |
| 在 1Gbps 的网络上发送 2KB 的数据 | 20,000 ns |
| 从内存顺序读取 1MB 的数据 | 250,000 ns |
| 同一个数据中心往返 | 500,000 ns |
| 磁盘寻址 | 10,000,000 ns |
| 从磁盘顺序读取 1MB 的数据 | 20,000,000 ns |
| 数据包往返美国到欧洲 | 150,000,000 ns |

不过随着计算机发展，这些数据有些过时，下表给出了 2020 年的版本：

| 操作 | 延迟 |
| --- | --- |
| 执行一个指令 | 1 ns |
| L1 缓存查询 | 0.5 ns |
| 分支预测错误 | 3 ns |
| L2 缓存查询 | 4 ns |
| 互斥锁/解锁 | 17 ns |
| 主存访问 | 100 ns |
| 使用 Zippy 算法压缩 1KB 的数据 | 2,000 ns |
| 从内存顺序读取 1MB 的数据 | 3,000 ns |
| SSD 随机读 | 39,000 ns |
| 从 SSD 顺序读取 1MB 的数据 | 49,000 ns |
| 同一个数据中心往返 | 500,000 ns |
| 从磁盘顺序读取 1MB 的数据 | 718,000 ns |
| 磁盘寻址 | 2,000,000 ns |
| 数据包往返美国到欧洲 | 150,000,000 ns |

可以看到，提升显著的是 SSD 和磁盘的顺序读取速度。

<br><br>

# 2 - 分布式系统模型
分布式系统有上百种架构，为了分析它们，需要抽象出一些通用模型，它们可以用于解决一些常见问题。先看两个经典的思想实验。

## 2.1 - 两将军问题
两支由不同将军领导的军队，准备协作进攻一座坚固的城市，要想成功占领它两个军队必须同时发起进攻。现在两支军队在城市附近两个山丘扎营，被一座山谷隔开，它们交流的唯一办法是派信使穿越山谷，但是山谷由敌军占领，信使可能会被俘虏。它们需要某种方法来达成共识，从而同时发起进攻，然而这是困难的。

问题如下：
1. A 如果希望进攻，它要通知 B，但信使可能被俘，它无法知道 B 是否收到消息
1. 为了解决这个问题，B 可以用信使传递确认信息，但这个信使也可能被俘，从而 B 需要考虑 A 是否收到确认信息，它无法确认自己是否应该进攻
1. 进一步地，可以让 A 对 B 的确认再次确认
1. ...

这样下去问题永远无法解决，事实上它已被证明是无解的。然而实际工程中，足够小的问题出现概率可以被接受，从而有像 TCP 三次握手这样的工程解。

这个实验表明，分布式系统中，一个节点是无法确认另一个节点的状态的，它们只能互相传递信息尽可能了解对方可能的状态。

## 2.2 - 拜占庭将军问题
类似于两将军问题，但问题升级为多个拜占庭将军共同攻占一座城市，他们仍旧只能通过信使传递信息。每支军队可以选择进攻或者撤离，部分军队进攻、部分军队撤离会导致灾难性后果，从而它们需要通过投票达成共识，选择进攻或者撤离。

这里的问题在于，可能有将军是叛徒，他们故意传递错误的信息来误导其他的将军。比如，C 可能从 A 和 B 处收到了两个不同的信息，它一般无法判断谁是判读，因为有两种可能的情况：
- A 告诉 B 和 C 进攻，B 却告诉 C 撤退，此时 B 是叛徒
- A 告诉 B 撤退，又告诉 C 进攻，此时 A 是叛徒

更坏的情况是，可能出现多个叛徒协同起来发送错误的信息，破坏整个行动。从而拜占庭将军问题就是要确保所有忠实将军能够达成共识，尽可能做到最好（我们显然没办法决定叛徒的行为）。

在实际的分布式系统中，将军就是计算机，信使就是通信系统。拜占庭故障模型描述的是，当某些节点发生故障和出现错误，甚至它们恶意篡改、破坏和控制系统的情况。

## 2.3 - 系统模型
根据上述实验，在分布式系统中，节点和网络都可能出现各种问题。系统模型根据不同类型的故障抽象出来，为了解决故障通常有不同的算法和架构。

### 2.3.1 - 网络链路模型
总是认为网络是不可靠的，可能出现各种各样的问题。在分布式系统中，网络出错导致常见问题称为网络分区，即网络设备故障使得网络分裂成多个独立的组，它们无法相互通信。

对于网络进行抽象，忽略造成问题的具体原因。同时，姑且假定网络是点对点的单播通信（虽然实际上有广播组播等）。假定有一个发送者和一个接收者，通过一个双向链路通信，链路上有两个基本事件：发送事件，把一条信息发送到链路上；接收事件，从链路上收到一条信息。

在这样的假设下，可以把链路分为以下 3 种，它们可以互相转换（如 TCP 所做的工作）：

#### 可靠链路
又称完美链路，不会丢失损坏信息，但可能出现信息的重排。它的特点是：
- 可靠传递：发送的每条信息都能被正确传递
- 没有重复：每条信息最多被传递一次
- 不会无中生有：链路不会自己产生一条信息

TCP 提供的服务模型可以看做一条可靠链路，不过它还提供了更多保证，如它保证消息有序交付。

#### 公平损失链路
信息可能丢失、重复、重新排序，但它最终总会到达，它的特点是：
- 公平损失：如果发送方和接收方正常运行，并且发送方持续重传信息，那么信息最终会送达
- 有限重复：消息只需重复发送有限次数
- 不会无中生有：链路不会自己产生一条信息

这意味着，网络分区的时间是有限的，一段时间以后它会恢复。

#### 任意链路
任意的问题都可能出现，包括丢失、重复、重新排序，还可能有恶意软件监听、篡改、伪造信息。这是最接近真实网络的模型。

### 2.3.2 - 节点故障模型
在消息丢失的时候，发送方可以持续重传消息来保证消息最终送达，但如果此时发送方出现故障，消息就可能永久丢失。这就引入了节点故障模型。节点的故障主要有 3 种类型：
- 崩溃-停止：节点停止工作以后，永远不会恢复。算法不能期望节点恢复来解决问题。
- 崩溃-恢复：节点停止工作以后，可能重新启动，并继续执行之前的工作。一般通过存储状态信息来实现。
- 拜占庭故障：故障的节点可能遍历算法的正常执行方式，从而可能恶意破坏系统

一般来说，公司内部的分布式系统处于私有的安全环境中，只需要处理前两种问题。而正确性非常关键的航空航天、区块链等系统，必须能够处理拜占庭故障。

### 2.3.3 - 按时间划分系统模型
基于时间是否同步，分布式系统可以分为 2 种模型：
- 同步系统：一个消息的响应时间在一个有限且确定的时间范围内
- 异步系统：一个消息的响应时间可能是无限的，无法知道消息何时到达

在同步系统中很多问题是好解决的，可惜现实情况是异步系统更接近于真正的网络环境。我们无法保证所有组件正常工作，因此无法提供消息到达的一个最大时间保证，即使在同一个数据中心也有过数据包超过 1 分钟才到达的案例。即使这些情况很少发生，但它们确实可能发生，这会使得按同步系统方式设计的系统出现问题。

为异步系统设计的算法不受网络中断或延迟的影响，通常非常健壮。然而，一些问题在异步系统中被证明是无法解决的，如 ELP 不可能定理证明了异步系统中找不到一个足够好的共识算法。

因此，产生了第三种模型，部分同步模型。它认为大多数情况下系统是同步的，偶尔因为故障转换成异步系统，它很贴近真实情况，也更好处理。

## 2.4 - 消息传递语义
因为消息可能消失，会使用重传来处理，但是这也引入了重复消息的问题。必须仔细设计消息传递协议来保证语义正确。比如，传递的消息如果表示支出 500 元，重复的消息就会带来错误的结果，而且很严重。

常见的解决方案是令消息具有幂等的语义，重复的消息和单个消息的效果是一样的。但这对系统有严格的约束，在知道消息是否传递到对面之前，可能必须等待接收对方的确认。更好的方案是给每个消息一个唯一的标识符，这样接收方可以识别重复的消息。

根据消息传递和处理次数，有几种消息传递语义：
- 最多一次：消息最多传递一次，可能丢失，但不会重复
- 至少一次：消息至少传递一次，不会丢失，但在故障时可能重复
- 精确一次：消息只传递一次，不会丢失，也不会重复。人们希望得到这样的语义

实际上很多时候更关键的消息仅被处理一次。毕竟链路大多是不可靠的，精确传递一次几乎是不可能的，但如果重复消息只会被处理一次，那效果是一样的。